<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGPU Sky / Atmosphere</title>
</head>
<body>
    <div class="container">
        <canvas id="canvas" style="width: 99%; height: 99%; position: absolute"></canvas>
        <div id="ui" style="position: absolute; right: 0; z-index: 1;"></div>
    </div>

    <script src="https://wgpu-matrix.org/dist/3.x/wgpu-matrix.min.js"></script>

    <script type="module">
        import { vec3n, mat4n, quatn } from 'https://wgpu-matrix.org/dist/3.x/wgpu-matrix.module.min.js';
        import { FPSCameraController } from './fps-camera.js';
        import { makeDragonRenderer } from './stanford-dragon.js';
        import { makeUi } from './ui.js';

        import { SkyAtmosphereComputeRenderer, SkyAtmosphereRasterRenderer } from '../dist/1.x/webgpu-sky-atmosphere.module.min.js';

        const urlParams = new URLSearchParams(window.location.search);
        const useTimestampQuery = new URLSearchParams(window.location.search).has('timestamp_query');

        async function main() {
            const canvas = document.querySelector('canvas');
            const resolution = [canvas.clientWidth, canvas.clientHeight].map(s => s * window.devicePixelRatio);
            canvas.width = resolution[0];
            canvas.height = resolution[1];

            const adapter = await navigator.gpu.requestAdapter();
            console.info('Available adapter features', [...adapter.features]);

            const deviceFeatures = adapter.features.has('dual-source-blending') ? ['dual-source-blending'] : [];
            if (useTimestampQuery && adapter.features.has('timestamp-query')) {
                deviceFeatures.push('timestamp-query');
            }

            const device = await adapter.requestDevice({requiredFeatures: deviceFeatures});
            console.info('Enabled device features', [...device.features]);
        
            let useDualSourceBlending = device.features.has('dual-source-blending');
            if (useDualSourceBlending) {
                // older chromium versions allow enabling dual source blending but don't allow use of 'src1' in blend state
                // --> check if dummy pipeline throws
                try {
                    const module = device.createShaderModule({code: `
                        enable dual_source_blending;
                        @vertex
                        fn vertex() -> @builtin(position) vec4<f32> {
                            return vec4(0, 0, 0, 1);
                        }
                        struct FragOut {
                            @location(0) @blend_src(0) c1: vec4<f32>,
                            @location(0) @blend_src(1) c2: vec4<f32>,
                        }
                        @fragment
                        fn fragment() -> FragOut {
                            return FragOut();
                        }
                    `});
                    device.createRenderPipeline({
                        layout: 'auto',
                        vertex: {
                            module,
                        },
                        fragment: {
                            module,
                            targets: [{
                                format: 'rgba16float',
                                blend: {
                                    color: {
                                        operation: 'add',
                                        srcFactor: 'one',
                                        dstFactor: 'src1',
                                    },
                                    alpha: {
                                        operation: 'add',
                                        srcFactor: 'zero',
                                        dstFactor: 'one',
                                    },
                                },
                            }],
                        }
                    });
                } catch (e) {
                    console.warn('dual source blending check failed', e);
                    useDualSourceBlending = false;
                }
            }
            if (!useDualSourceBlending) {
                console.warn('dual source blending not supported - disabling colored transmittance for render passes');
            }

            let timeStampQuery = null;
            const numTimestamps = 10;
            let queryBuffers = [];
            if (device.features.has('timestamp-query')) {
                timeStampQuery = device.createQuerySet({
                    type: 'timestamp',
                    count: numTimestamps,
                });
                for (let i = 0; i < 5; ++i) {
                    queryBuffers.push({
                        read: device.createBuffer({
                            size: numTimestamps * 8,
                            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                        }),
                        resolve: device.createBuffer({
                            size: numTimestamps * 8,
                            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
                        }),
                    });
                }
            }

            const context = canvas.getContext('webgpu');
            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
            });

            const cameraController = new FPSCameraController(canvas);

            const projection = mat4n.perspectiveReverseZ(
                45.0 * (Math.PI / 180.0),
                resolution[0] / resolution[1],
                1.0,
            );

            const backBuffer = device.createTexture({
                size: resolution,
                format: 'rgba16float',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            const backBufferView = backBuffer.createView();
            const depthBuffer = device.createTexture({
                size: resolution,
                format: 'depth24plus',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            const depthBufferView = depthBuffer.createView();

            const shadowMapSize = 1024;
            const shadowMap = device.createTexture({
                size: [shadowMapSize, shadowMapSize, 1],
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
                format: 'depth32float',
            });
            const shadowMapView = shadowMap.createView();

            const skyRenderTarget = device.createTexture({
                size: resolution,
                format: 'rgba16float',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
            });

            const shadowBindGroupLayout = device.createBindGroupLayout({
                label: 'shadow',
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                        buffer: {
                            type: 'uniform',
                            minBindingSize: 16 * Float32Array.BYTES_PER_ELEMENT,
                        },
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                        sampler: {
                            type: 'comparison',
                        },
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                        texture: {
                            sampleType: 'depth',
                            viewDimension: '2d',
                        },
                    },
                ],
            });
            const shadowBuffer = device.createBuffer({
                size: Float32Array.BYTES_PER_ELEMENT * 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            const distanceScaleFactor = 1.0;
            const skyAtmosphereConfigBase = {
                distanceScaleFactor,
                shadow: {
                    bindGroupLayouts: [shadowBindGroupLayout],
                    bindGroups: [device.createBindGroup({
                        label: 'shadow',
                        layout: shadowBindGroupLayout,
                        entries: [
                            {binding: 0, resource: {buffer: shadowBuffer}},
                            {binding: 1, resource: device.createSampler({compare: 'less'})},
                            {binding: 2, resource: shadowMapView},
                        ],
                    })],
                    wgslCode: `
                        @group(1) @binding(0) var<uniform> sun_view_projection: mat4x4<f32>;
                        @group(1) @binding(1) var shadow_sampler: sampler_comparison;
                        @group(1) @binding(2) var shadow_map: texture_depth_2d;
                        
                        fn get_shadow(p: vec3<f32>, light_index: u32) -> f32 {
                            if light_index == 0 {
                                var shadow_pos = (sun_view_projection * vec4(p, 1.0)).xyz;
                                shadow_pos = vec3(shadow_pos.xy * vec2(0.5, -0.5) + 0.5, shadow_pos.z);
                                if all(shadow_pos >= vec3<f32>()) && all(shadow_pos < vec3(1.0)) {
                                    return textureSampleCompareLevel(shadow_map, shadow_sampler, shadow_pos.xy, shadow_pos.z);
                                }
                            }
                            return 1.0;
                        }
                    `
                },
            };
            const computePassConfigBase = {
                backBuffer: {
                    texture: backBuffer,
                    view: backBufferView,
                },
                renderTarget: {
                    texture: skyRenderTarget,
                    view: skyRenderTarget.createView(),
                },
                depthBuffer: {
                    texture: depthBuffer,
                    view: depthBufferView,
                    reverseZ: true,
                },
                rayMarch: {
                    useColoredTransmittance: true,
                },
            };
            const renderPassConfigBase = {
                renderTargetFormat: skyRenderTarget.format,
                depthBuffer: {
                    texture: depthBuffer,
                    view: depthBufferView,
                    reverseZ: true,
                },
                rayMarch: {
                    useColoredTransmittance: useDualSourceBlending,
                },
            };

            const skyRenderers = [];
            for (let inMeters = 0; inMeters < 2; ++inMeters) {
                if (inMeters === 1) {
                    skyAtmosphereConfigBase.distanceScaleFactor = 1000.0;
                }
                skyRenderers.push([]);
                for (let compute = 0; compute < 2; ++compute) {
                    skyRenderers[inMeters].push([]);
                    for (let colored = 0; colored < 2; ++colored) {
                        skyRenderers[inMeters][compute].push([]);
                        for (let skyLut = 0; skyLut < 2; ++skyLut) {
                            const existing = compute + colored + skyLut > 0 ? skyRenderers[inMeters][0][0][0] : undefined;
                            skyRenderers[inMeters][compute][colored].push(
                                (compute === 1 ? 
                                    SkyAtmosphereComputeRenderer.create(
                                        device,
                                        {
                                            ...skyAtmosphereConfigBase,
                                            skyRenderer: {
                                                ...computePassConfigBase,
                                                rayMarch: {
                                                    useColoredTransmittance: colored === 1,
                                                    rayMarchDistantSky: skyLut === 1,
                                                },
                                            },
                                        },
                                        (existing ? existing.skyAtmospherePipelines : undefined),
                                        (existing ? existing.resources : undefined),
                                    ) :
                                    SkyAtmosphereRasterRenderer.create(
                                        device,
                                        {
                                            ...skyAtmosphereConfigBase,
                                            skyRenderer: {
                                                ...renderPassConfigBase,
                                                rayMarch: {
                                                    useColoredTransmittance: colored === 1,
                                                    rayMarchDistantSky: skyLut === 1,
                                                },
                                            },
                                        },
                                        (existing ? existing.skyAtmospherePipelines : undefined),
                                        (existing ? existing.resources : undefined),
                                    )
                                )
                            );
                        }
                    }
                }
            }

            const skyAtmosphereRenderer = skyRenderers[0][1][1][0];

            function makePipeline() {
                const module = device.createShaderModule({
                    code: `
                    struct Config {
                        show_transmittance_lut: u32,
                        show_multi_scattering_lut: u32,
                        multi_scattering_scale: u32,
                        show_sky_view_lut: u32,
                        sky_view_lut_scale: u32,
                        show_aerial_perspective: u32,
                        aerial_perspective_scale: u32,
                        aerial_perspective_slice: u32,
                    }
                    @group(0) @binding(0) var<uniform> config: Config;
                    @group(0) @binding(1) var transmittance_lut: texture_2d<f32>;
                    @group(0) @binding(2) var multi_scattering_lut: texture_2d<f32>;
                    @group(0) @binding(3) var sky_view_lut: texture_2d<f32>;
                    @group(0) @binding(4) var aerial_perspective_lut: texture_3d<f32>;
                    @group(0) @binding(5) var backbuffer: texture_2d<f32>;
                        
                    @vertex
                    fn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
                        return vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);
                    }
                    
                    fn coords_in_rect(coords: vec2<u32>, rect_min: vec2<u32>, rect_max: vec2<u32>) -> bool {
                        return all(coords >= rect_min) && all(coords < rect_max);
                    }
                    
                    fn tonemap(rgb: vec3<f32>) -> vec3<f32> {
                        let white_point = vec3(1.08241, 0.96756, 0.95003);
                        let exposure = 10.0;
                        return pow(vec3(1.0) - exp(-rgb / white_point * exposure), vec3(1.0 / 2.2));
                    }

                    fn sample_interleaved_gradient_noise(pixel_pos: vec2<f32>) -> f32 {
                        let magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
                        return fract(magic.z * fract(dot(pixel_pos.xy, magic.xy)));
                    }

                    // reduce banding: https://github.com/sebh/UnrealEngineSkyAtmosphere/issues/15
                    // TAA would be nicer
                    fn apply_dither_to_pixel_color(color: vec3<f32>, pixel_pos: vec2<f32>) -> vec3<f32> {
                        let scale_bias = vec2(1.0 / 255.0, -0.5 / 255.0);
                        return color + sample_interleaved_gradient_noise(pixel_pos) * scale_bias.x + scale_bias.y;
                    }

                    @fragment
                    fn fragment(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
                        let texture_coords = vec2<u32>(floor(coord.xy));
                        
                        let transmittance_lut_size = textureDimensions(transmittance_lut, 0);
                        let multi_scattering_lut_size = textureDimensions(multi_scattering_lut, 0);
                        let sky_view_lut_size = textureDimensions(sky_view_lut, 0);
                        let aerial_perspective_lut_size = textureDimensions(aerial_perspective_lut, 0).xy;
                        let backbuffer_size = textureDimensions(backbuffer, 0).xy;

                        let transmittance_lut_min_rect = vec2<u32>();
                        let multi_scattering_lut_min_rect = transmittance_lut_min_rect + vec2<u32>(0, transmittance_lut_size.y);
                        let sky_view_lut_min_rect = multi_scattering_lut_min_rect + vec2<u32>(0, multi_scattering_lut_size.y);
                        let aerial_perspective_lut_min_rect = sky_view_lut_min_rect + vec2<u32>(0, sky_view_lut_size.y);
                        
                        if config.show_transmittance_lut == 1 && coords_in_rect(texture_coords, transmittance_lut_min_rect, transmittance_lut_min_rect + transmittance_lut_size) {
                            return vec4(textureLoad(transmittance_lut, texture_coords, 0).rgb, 1.0);
                        } else if config.show_multi_scattering_lut == 1 && coords_in_rect(texture_coords, multi_scattering_lut_min_rect, multi_scattering_lut_min_rect + multi_scattering_lut_size) {
                            return vec4(textureLoad(multi_scattering_lut, vec2<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y), 0).rgb * f32(config.multi_scattering_scale), 1.0);
                        } else if config.show_sky_view_lut == 1 && coords_in_rect(texture_coords, sky_view_lut_min_rect, sky_view_lut_min_rect + sky_view_lut_size) {
                            return vec4(textureLoad(sky_view_lut, vec2<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y - multi_scattering_lut_size.y), 0).rgb * f32(config.sky_view_lut_scale), 1.0);
                        } else if config.show_aerial_perspective == 1 && coords_in_rect(texture_coords, aerial_perspective_lut_min_rect, aerial_perspective_lut_min_rect + aerial_perspective_lut_size) {
                            return vec4(textureLoad(aerial_perspective_lut, vec3<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y - multi_scattering_lut_size.y - sky_view_lut_size.y, config.aerial_perspective_slice), 0).rgb * f32(config.aerial_perspective_scale), 1.0);
                        } else if coords_in_rect(texture_coords, vec2<u32>(), backbuffer_size) {
                            let rgb = textureLoad(backbuffer, texture_coords, 0).rgb;
                            return vec4(apply_dither_to_pixel_color(tonemap(rgb), coord.xy), 1.0);
                        } else {
                            return vec4(0.5, 0.5, 0.5, 1.0);
                        }
                    }
                    `,
                });
                return device.createRenderPipeline({
                    layout: 'auto',
                    vertex: {
                        module,
                        entryPoint: 'vertex',
                    },
                    fragment: {
                        module,
                        entryPoint: 'fragment',
                        targets: [{ format: presentationFormat }],
                    },
                });
            }

            const presentPipeline = makePipeline();
            const debugViewConfigBuffer = device.createBuffer({
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const bindGroup = device.createBindGroup({
                layout: presentPipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: debugViewConfigBuffer,
                        },
                    },
                    {
                        binding: 1,
                        resource: skyAtmosphereRenderer.resources.transmittanceLut.view,
                    },
                    {
                        binding: 2,
                        resource: skyAtmosphereRenderer.resources.multiScatteringLut.view,
                    },
                    {
                        binding: 3,
                        resource: skyAtmosphereRenderer.resources.skyViewLut.view,
                    },
                    {
                        binding: 4,
                        resource: skyAtmosphereRenderer.resources.aerialPerspectiveLut.view,
                    },
                    {
                        binding: 5,
                        resource: skyRenderTarget.createView(),
                    },
                ],
            });
            const bindGroupRender = device.createBindGroup({
                layout: presentPipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: debugViewConfigBuffer,
                        },
                    },
                    {
                        binding: 1,
                        resource: skyAtmosphereRenderer.resources.transmittanceLut.view,
                    },
                    {
                        binding: 2,
                        resource: skyAtmosphereRenderer.resources.multiScatteringLut.view,
                    },
                    {
                        binding: 3,
                        resource: skyAtmosphereRenderer.resources.skyViewLut.view,
                    },
                    {
                        binding: 4,
                        resource: skyAtmosphereRenderer.resources.aerialPerspectiveLut.view,
                    },
                    {
                        binding: 5,
                        resource: backBuffer.createView(),
                    },
                ],
            });

            const dragonRenderer = makeDragonRenderer(device, backBuffer.format, depthBuffer.format, true, shadowMap);

            const sunProjection = mat4n.ortho(-80, 80, -80, 80, -200, 300);

            const sunProjectionMeters = mat4n.ortho(-80000, 80000, -80000, 80000, -200000, 300000);

            const params = makeUi(skyAtmosphereRenderer.resources.atmosphere, cameraController, timeStampQuery !== null);

            const resolutionDependentStuff = {
                projection,
                backBuffer,
                backBufferView,
                depthBuffer,
                depthBufferView,
                skyRenderTarget,
                bindGroup,
                bindGroupRender,
            };

            let resizeInProgress = false;
            const handleResize = _ => {
                resolution[0] = canvas.clientWidth * window.devicePixelRatio;
                resolution[1] = canvas.clientHeight * window.devicePixelRatio;

                canvas.width = resolution[0];
                canvas.height = resolution[1];

                resolutionDependentStuff.projection = mat4n.perspectiveReverseZ(
                    45.0 * (Math.PI / 180.0),
                    resolution[0] / resolution[1],
                    1.0,
                );
                resolutionDependentStuff.backBuffer = device.createTexture({
                    size: resolution,
                    format: 'rgba16float',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                });
                resolutionDependentStuff.backBufferView = resolutionDependentStuff.backBuffer.createView();
                resolutionDependentStuff.depthBuffer = device.createTexture({
                    size: resolution,
                    format: 'depth24plus',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                });
                resolutionDependentStuff.depthBufferView = resolutionDependentStuff.depthBuffer.createView();
                resolutionDependentStuff.skyRenderTarget = device.createTexture({
                    size: resolution,
                    format: 'rgba16float',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
                });
                resolutionDependentStuff.bindGroup = device.createBindGroup({
                    layout: presentPipeline.getBindGroupLayout(0),
                    entries: [
                        {
                            binding: 0,
                            resource: {
                                buffer: debugViewConfigBuffer,
                            },
                        },
                        {
                            binding: 1,
                            resource: skyAtmosphereRenderer.resources.transmittanceLut.view,
                        },
                        {
                            binding: 2,
                            resource: skyAtmosphereRenderer.resources.multiScatteringLut.view,
                        },
                        {
                            binding: 3,
                            resource: skyAtmosphereRenderer.resources.skyViewLut.view,
                        },
                        {
                            binding: 4,
                            resource: skyAtmosphereRenderer.resources.aerialPerspectiveLut.view,
                        },
                        {
                            binding: 5,
                            resource: resolutionDependentStuff.skyRenderTarget.createView(),
                        },
                    ],
                });
                resolutionDependentStuff.bindGroupRender = device.createBindGroup({
                    layout: presentPipeline.getBindGroupLayout(0),
                    entries: [
                        {
                            binding: 0,
                            resource: {
                                buffer: debugViewConfigBuffer,
                            },
                        },
                        {
                            binding: 1,
                            resource: skyAtmosphereRenderer.resources.transmittanceLut.view,
                        },
                        {
                            binding: 2,
                            resource: skyAtmosphereRenderer.resources.multiScatteringLut.view,
                        },
                        {
                            binding: 3,
                            resource: skyAtmosphereRenderer.resources.skyViewLut.view,
                        },
                        {
                            binding: 4,
                            resource: skyAtmosphereRenderer.resources.aerialPerspectiveLut.view,
                        },
                        {
                            binding: 5,
                            resource: resolutionDependentStuff.backBufferView,
                        },
                    ],
                });

                const resizeConfigCompute = {
                    backBuffer: resolutionDependentStuff.backBuffer,
                    depthBuffer: resolutionDependentStuff.depthBuffer,
                    renderTarget: resolutionDependentStuff.skyRenderTarget,
                };

                for (let inMeters = 0; inMeters < 2; ++inMeters) {
                    for (let compute = 0; compute < 2; ++compute) {
                        for (let colored = 0; colored < 2; ++colored) {
                            for (let skyLut = 0; skyLut < 2; ++skyLut) {
                                skyRenderers[inMeters][compute][colored][skyLut].onResize(
                                    compute === 1 ? resizeConfigCompute : resolutionDependentStuff.depthBuffer
                                );
                            }
                        }
                    }
                }

                resizeInProgress = false;
            };

            let timeout = false;
            window.addEventListener('resize', _ => {
                resizeInProgress = true;
                clearTimeout(timeout);
                timeout = setTimeout(handleResize, 250);
            });

            let lastTime = new Date();
            let frameId = 0;
            const render = () => {
                const now = new Date();
                const dt = (now - lastTime);
                lastTime = now;

                ++frameId;

                if (resizeInProgress) {
                    setTimeout(render, 250);
                    return;
                }

                cameraController.update(dt);

                const encoder = device.createCommandEncoder();

                device.queue.writeBuffer(debugViewConfigBuffer, 0, new Uint32Array([
                    params.debugViews.showTransmittanceLut,
                    params.debugViews.showMultiScatteringLut,
                    params.debugViews.multiScatteringLutFactor,
                    params.debugViews.showSkyViewLut,
                    params.debugViews.skyViewLutFactor,
                    params.debugViews.showAerialPerspectiveLut,
                    params.debugViews.aerialPerspectiveLutFactor,
                    params.debugViews.aerialPerspectiveSlice,
                ]));

                const cameraView = cameraController.view;

                const config = {
                    camera: {
                        position: cameraController.position,
                        inverseView: mat4n.inverse(cameraView),
                        inverseProjection: mat4n.inverse(resolutionDependentStuff.projection),
                    },
                    sun: {
                        illuminance: [
                            params.renderSettings.sun.illuminance.r,
                            params.renderSettings.sun.illuminance.g,
                            params.renderSettings.sun.illuminance.b,
                        ].map(c => c * params.renderSettings.sun.illuminanceFactor),
                        direction: vec3n.normalize([
                            0.0,
                            params.renderSettings.sun.direction.y,
                            params.renderSettings.sun.direction.x,
                        ]),
                        diskLuminanceScale: params.renderSettings.sun.diskIlluminance,
                        diskAngularDiameter: params.renderSettings.sun.diskDiameter * Math.PI / 180.0,
                    },
                    moon: {
                        illuminance: [
                            params.renderSettings.sun.illuminance.r,
                            params.renderSettings.sun.illuminance.g,
                            params.renderSettings.sun.illuminance.b,
                        ].map(c => 0.0 * c * params.renderSettings.sun.illuminanceFactor / 100000),
                        direction: vec3n.normalize([
                            0.0,
                            -params.renderSettings.sun.direction.y,
                            -params.renderSettings.sun.direction.x,
                        ]),
                        diskLuminanceScale: 0.26,
                        diskAngularDiameter: 0.568 * Math.PI / 180.0,
                    },
                    screenResolution: resolution,
                    rayMarchMinSPP: params.renderSettings.rayMarchingMinSpp,
                    rayMarchMaxSPP: params.renderSettings.rayMarchingMaxSpp,
                    frameId,
                };

                const model = mat4n.multiply(mat4n.scaling(Array(3).fill(params.scaleFromKilometers())), mat4n.translation([0.0, -20.0, 0.0]));
                const sunView = mat4n.lookAt(
                    config.sun.direction.map(c => c * params.scaleFromKilometers()),
                    vec3n.fromValues(0, 0, 0),
                    vec3n.normalize(vec3n.fromValues(0, 0, 1))
                );
                const sunViewProjection = mat4n.multiply(params.renderSettings.inMeters ? sunProjectionMeters : sunProjection, sunView);

                device.queue.writeBuffer(shadowBuffer, 0, new Float32Array(sunViewProjection));
                
                dragonRenderer.update(
                    {view: cameraView, projection: resolutionDependentStuff.projection},
                    {model, normal: mat4n.transpose(mat4n.inverse(model))},
                    {
                        direction: config.sun.direction,
                        illuminance: config.sun.illuminance,
                        lightViewProjection: sunViewProjection,
                    },
                    {
                        sunView,
                        sunProjection: params.renderSettings.inMeters ? sunProjectionMeters : sunProjection,
                    }
                );

                const shadowMapPass = encoder.beginRenderPass({
                    colorAttachments: [],
                    depthStencilAttachment: {
                        view: shadowMapView,
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store',
                    },
                });
                dragonRenderer.encodeShadow(shadowMapPass);
                shadowMapPass.end();

                const geometryPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: resolutionDependentStuff.backBufferView,
                        clearValue: [0,0,0,1],
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: resolutionDependentStuff.depthBufferView,
                        depthClearValue: 0.0, // reverse z
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store',
                    },
                });
                dragonRenderer.encode(geometryPass);
                geometryPass.end();

                const skyRenderer = (skyRenderers
                    [+params.renderSettings.inMeters]
                    [+params.renderSettings.compute]
                    [+params.renderSettings.coloredTransmittance]
                    [+params.renderSettings.rayMarchDistantSky]
                );
                
                if (timeStampQuery) {
                    skyRenderer.updateAtmosphere(params.atmosphere);
                    skyRenderer.updateUniforms(config);

                    const transmittanceLutPass = encoder.beginComputePass({
                        timestampWrites: {
                            querySet: timeStampQuery,
                            beginningOfPassWriteIndex: 0,
                            endOfPassWriteIndex: 1,
                        },
                    });
                    skyRenderer.renderTransmittanceLut(transmittanceLutPass);
                    transmittanceLutPass.end();

                    const multiScatteringLutPass = encoder.beginComputePass({
                        timestampWrites: {
                            querySet: timeStampQuery,
                            beginningOfPassWriteIndex: 2,
                            endOfPassWriteIndex: 3,
                        },
                    });
                    skyRenderer.renderMultiScatteringLut(multiScatteringLutPass);
                    multiScatteringLutPass.end();

                    if (!params.renderSettings.rayMarch || !params.renderSettings.rayMarchDistantSky) {
                        const skyViewLutPass = encoder.beginComputePass({
                            timestampWrites: {
                                querySet: timeStampQuery,
                                beginningOfPassWriteIndex: 4,
                                endOfPassWriteIndex: 5,
                            },
                        });
                        skyRenderer.renderSkyViewLut(skyViewLutPass);
                        skyViewLutPass.end();
                    }

                    if (!params.renderSettings.rayMarch) {
                        const aerialPerspectiveLutPass = encoder.beginComputePass({
                            timestampWrites: {
                                querySet: timeStampQuery,
                                beginningOfPassWriteIndex: 6,
                                endOfPassWriteIndex: 7,
                            },
                        });
                        skyRenderer.renderAerialPerspectiveLut(aerialPerspectiveLutPass);
                        aerialPerspectiveLutPass.end();
                    }
                    if (params.renderSettings.compute) {
                        const skyPass = encoder.beginComputePass({
                            timestampWrites: {
                                querySet: timeStampQuery,
                                beginningOfPassWriteIndex: 8,
                                endOfPassWriteIndex: 9,
                            },
                        });
                        skyRenderer.renderSky(skyPass, params.renderSettings.rayMarch);
                        skyPass.end();
                    }
                } else {
                    const computePass = encoder.beginComputePass();
                    if (params.renderSettings.compute) {
                        skyRenderer.renderLutsAndSky(computePass, config, params.atmosphere, params.renderSettings.rayMarch);
                    } else {
                        skyRenderer.renderLuts(computePass, config, params.atmosphere, params.renderSettings.rayMarch);
                    }
                    computePass.end();
                }

                if (!params.renderSettings.compute) {
                    const renderPass = encoder.beginRenderPass({
                        colorAttachments: [{
                            view: resolutionDependentStuff.backBufferView,
                            loadOp: 'load',
                            storeOp: 'store',
                        }],
                        timestampWrites: timeStampQuery ? {
                            querySet: timeStampQuery,
                            beginningOfPassWriteIndex: 8,
                            endOfPassWriteIndex: 9,
                        } : undefined,
                    });
                    skyRenderer.renderSky(renderPass, params.renderSettings.rayMarch);
                    renderPass.end();
                }

                if (timeStampQuery) {
                    const resolveBuffer = queryBuffers[frameId % queryBuffers.length].resolve;
                    const readBuffer = queryBuffers[frameId % queryBuffers.length].read;
                    encoder.resolveQuerySet(timeStampQuery, 0, numTimestamps, resolveBuffer, 0);
                    if (readBuffer.mapState === 'unmapped') {
                        encoder.copyBufferToBuffer(resolveBuffer, 0, readBuffer, 0, resolveBuffer.size);
                    } else {
                        console.warn('timestamp query: buffer mapping lags behind', readBuffer.mapState);
                    }
                }

                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: [0,0,0,1],
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });
                pass.setPipeline(presentPipeline);
                pass.setBindGroup(0, params.renderSettings.compute ? resolutionDependentStuff.bindGroup : resolutionDependentStuff.bindGroupRender);
                pass.draw(3);
                pass.end();

                device.queue.submit([encoder.finish()]);

                if (timeStampQuery) {
                    const readBuffer = queryBuffers[frameId % queryBuffers.length].read;
                    if (readBuffer.mapState === 'unmapped') {
                        readBuffer.mapAsync(GPUMapMode.READ)
                            .then(_ => {
                                const timestamps = new BigInt64Array(readBuffer.getMappedRange());
                                const transmittanceLutDuration = Number(timestamps[1] - timestamps[0]) / 1_000_000;
                                const multiScatteringLutDruation = Number(timestamps[3] - timestamps[2]) / 1_000_000;
                                const skyViewLutDuration = params.renderSettings.rayMarch ? 0 : Number(timestamps[5] - timestamps[4]) / 1_000_000;
                                const aerialPerspectiveLutDuration = params.renderSettings.rayMarch ? 0 : Number(timestamps[7] - timestamps[6]) / 1_000_000;
                                const skyDuration = Number(timestamps[9] - timestamps[8]) / 1_000_000;
                                readBuffer.unmap();

                                const constantDuration = transmittanceLutDuration + multiScatteringLutDruation;
                                const dynamicDuration = skyViewLutDuration + aerialPerspectiveLutDuration;
                                const lutsDuration = constantDuration + dynamicDuration;
                                const totalDuration = lutsDuration + skyDuration;

                                params.monitoring.transtmittance = transmittanceLutDuration;
                                params.monitoring.multiScattering = multiScatteringLutDruation;
                                params.monitoring.skyView = skyViewLutDuration;
                                params.monitoring.aerialPerspective = aerialPerspectiveLutDuration;
                                params.monitoring.sky = skyDuration;
                                params.monitoring.constant = constantDuration;
                                params.monitoring.dynamic = dynamicDuration;
                                params.monitoring.luts = lutsDuration;
                                params.monitoring.total = totalDuration;
                            });
                    }
                }

                requestAnimationFrame(render);
            };
            render();
        }
        main();
    </script>
</body>
</html>