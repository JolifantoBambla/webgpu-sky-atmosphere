<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGPU Sky / Atmosphere</title>
</head>
<body>
    <div class="container">
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://wgpu-matrix.org/dist/3.x/wgpu-matrix.min.js"></script>

    <script type="module">
        import { vec3n, mat4n, quatn } from 'https://wgpu-matrix.org/dist/3.x/wgpu-matrix.module.min.js';
        import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js';
        import stanfordDragon from './stanford-dragon.js';

        import { SkyAtmosphereRenderer, makeEarthAtmosphere, makeDefaultConfig } from '../dist/1.x/webgpu-sky-atmosphere.module.min.js';

        class CameraController {
            #pitch = 0.0;
            #yaw = 0.0;
            #velocity = vec3n.fromValues(0, 0, 0);
            #acceleration = 20.0;
            #maxSpeed = 1;
            #decay = 0.9;
            #pointerSensitivity = 0.002;
            #keys = [];
            #pointerMoveHandler;
            #position = vec3n.create(0, 1, 0);
            #rotation = quatn.identity();

            constructor(canvas) {
                this.#pointerMoveHandler = e => this.#onMouseMove(e);
                canvas.ownerDocument.addEventListener('keydown', e => { this.#keys[e.code] = true; });
                canvas.ownerDocument.addEventListener('keyup', e => { this.#keys[e.code] = false; });
                canvas.addEventListener('click', _ => { canvas.requestPointerLock(); });
                canvas.ownerDocument.addEventListener('pointerlockchange', _ => {
                    if (canvas.ownerDocument.pointerLockElement === canvas) {
                        canvas.ownerDocument.addEventListener('pointermove', this.#pointerMoveHandler);
                    } else {
                        canvas.ownerDocument.removeEventListener('pointermove', this.#pointerMoveHandler);
                    }
                });
            }

            #onMouseMove(e) {
                this.#pitch -= e.movementY * this.#pointerSensitivity;
                this.#yaw -= e.movementX * this.#pointerSensitivity;
                const tau = Math.PI * 2;
                const halfpi = Math.PI / 2;
                this.#pitch = Math.min(Math.max(this.#pitch, -halfpi), halfpi);
                this.#yaw = ((this.#yaw % tau) + tau) % tau;
            }

            update(dt = 0.0) {
                const keyFront = 'KeyW';
                const keyBack = 'KeyS';
                const keyLeft = 'KeyA';
                const keyRight = 'KeyD';

                const cos = Math.cos(this.#yaw);
                const sin = Math.sin(this.#yaw);
                const forward = [-sin, 0, -cos];
                const right = [cos, 0, -sin];

                const acc = vec3n.create(0, 0, 0);
                if (this.#keys[keyFront]) {
                    vec3n.add(acc, forward, acc);
                }
                if (this.#keys[keyBack]) {
                    vec3n.sub(acc, forward, acc);
                }
                if (this.#keys[keyRight]) {
                    vec3n.add(acc, right, acc);
                }
                if (this.#keys[keyLeft]) {
                    vec3n.sub(acc, right, acc);
                }
                vec3n.addScaled(this.#velocity, acc, dt * this.#acceleration, this.#velocity);

                if (![keyFront, keyBack, keyLeft, keyRight].some(code => this.#keys[code])) {
                    vec3n.scale(this.#velocity, Math.exp(dt * Math.log(1 - this.#decay)), this.#velocity);
                }
                const speed = vec3n.length(this.#velocity);
                if (speed > this.#maxSpeed) {
                    vec3n.scale(this.#velocity, this.#maxSpeed / speed, this.#velocity);
                }
                vec3n.addScaled(this.#position, this.#velocity, dt, this.#position);
                
                const rotation = quatn.identity();
                quatn.rotateY(rotation, this.#yaw, rotation);
                quatn.rotateX(rotation, this.#pitch, rotation);
                this.#rotation = rotation;
            }

            get position() {
                return this.#position;
            }

            get view() {
                const mat = mat4n.fromQuat(this.#rotation);
                mat4n.setTranslation(mat, this.#position, mat);
                return mat4n.inverse(mat);
            }
        }

        async function main() {
            const resolution = [1920, 1080];

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            console.log([...adapter.features]);

            const canvas = document.querySelector('canvas');
            canvas.width = resolution[0];
            canvas.height = resolution[1];

            const context = canvas.getContext('webgpu');
            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
            });

            const cameraController = new CameraController(canvas);

            const params = {
                debugViews: {
                    showTransmittanceLut: true,

                    showMultiScatteringLut: true,
                    multiScatteringLutFactor: 50,
                    
                    showSkyViewLut: true,
                    skyViewLutFactor: 50,
                    
                    showAerialPerspectiveLut: true,
                    aerialPerspectiveLutFactor: 50,
                    aerialPerspectiveSlice: 0,
                },
                config: makeDefaultConfig(),
                renderSettings: {
                    sun: {
                        illuminance: {r: 1.0, g: 1.0, b: 1.0},
                        illuminanceFactor: 1.0,
                    },
                    rayMarchingMinSpp: 14,
                    rayMarchingMaxSpp: 30,
                },
                atmosphere: makeEarthAtmosphere(),
                atmosphereHelper: {
                    rayleigh: {
                        scaleHeight: 8.0,
                        // per 100 m
                        scattering: {
                            r: 0.05802,
                            g: 0.13558,
                            b: 0.33100,
                        },
                    },
                    mie: {
                        scaleHeight: 1.2,
                        // per 10 m
                        scattering: {
                            r: 0.3996,
                            g: 0.3996,
                            b: 0.3996,
                        },
                        // per 10 m
                        extinction: {
                            r: 0.4440,
                            g: 0.4440,
                            b: 0.4440,
                        },
                    },
                    absorption: {
                        // per 10 m
                        extinction: {
                            r: 0.0650,
                            g: 0.1881,
                            b: 0.0085,
                        },
                    },
                },
            };

            function makeUi() {
                const pane = new Pane({
                    title: 'WebGPU Sky / Atmosphere',
                    expanded: true,
                });
                const debugViewFolder = pane.addFolder({
                    title: 'Debug views',
                    expanded: false,
                });
                debugViewFolder.addBinding(params.debugViews, 'showTransmittanceLut', {label: 'Show transmittance LUT'});

                debugViewFolder.addBinding(params.debugViews, 'showMultiScatteringLut', {label: 'Show multi. scat. LUT'});
                debugViewFolder.addBinding(params.debugViews, 'multiScatteringLutFactor', {min: 1, max: 100, step: 1, label: 'Multi. scat. scale'});
                
                debugViewFolder.addBinding(params.debugViews, 'showSkyViewLut', {label: 'Show sky view LUT'});
                debugViewFolder.addBinding(params.debugViews, 'skyViewLutFactor', {min: 1, max: 100, step: 1, label: 'Sky view scale'});
                
                debugViewFolder.addBinding(params.debugViews, 'showAerialPerspectiveLut', {label: 'Show aerial persp. LUT'});
                debugViewFolder.addBinding(params.debugViews, 'aerialPerspectiveLutFactor', {min: 1, max: 100, step: 1, label: 'Aerial persp. scale'});
                debugViewFolder.addBinding(params.debugViews, 'aerialPerspectiveSlice', {min: 0, max: 31, step: 1, label: 'Aerial persp. slice'});

                const renderSettingsFolder = pane.addFolder({
                    title: 'Render settings',
                    expanded: true,
                });
                renderSettingsFolder.addBinding(params.renderSettings.sun, 'illuminance', {color: {type: 'float'}, label: 'Sun illuminance'});
                renderSettingsFolder.addBinding(params.renderSettings.sun, 'illuminanceFactor', {min: 0.1, max: 10.0, step: 0.1, label: 'Sun illum. scale'});

                const atmosphereFolder = pane.addFolder({
                    title: 'Atmosphere',
                    expanded: true,
                });
                atmosphereFolder.addBinding(params.atmosphere, 'bottomRadius', {min: 100.0, max: 10000.0, step: 10.0, label: 'ground radius'});
                atmosphereFolder.addBinding(params.atmosphere, 'height', {min: 10.0, max: 500.0, step: 1.0, label: 'height'});
                //atmosphereFolder.addBinding(params.atmosphere, 'groundAlbedo', )

                const rayleighFolder = atmosphereFolder.addFolder({
                    title: 'Rayleigh',
                    expanded: true,
                });
                rayleighFolder.addBinding(params.atmosphereHelper.rayleigh, 'scaleHeight', {min: 0.0, max: 10.0, step: 0.1, label: 'scale height'})
                    .on('change', e => {
                        params.atmosphere.rayleigh.densityExpScale = -1.0 / e.value;
                    });
                rayleighFolder.addBinding(params.atmosphereHelper.rayleigh, 'scattering', {color: {type: 'float'}, label: 'scattering (per 100 m)'})
                    .on('change', e => {
                        params.atmosphere.rayleigh.scattering = [e.value.r, e.value.g, e.value.b].map(c => c / 10.0);
                    });

                const mieFolder = atmosphereFolder.addFolder({
                    title: 'Mie',
                    expanded: true,
                });
                mieFolder.addBinding(params.atmosphereHelper.mie, 'scaleHeight', {min: 0.0, max: 10.0, step: 0.1, label: 'scale height'})
                    .on('change', e => {
                        params.atmosphere.mie.densityExpScale = -1.0 / e.value;
                    });
                mieFolder.addBinding(params.atmosphereHelper.mie, 'scattering', {color: {type: 'float'}, label: 'scattering (per 10 m)'})
                    .on('change', e => {
                        params.atmosphere.mie.scattering = [e.value.r, e.value.g, e.value.b].map(c => c / 100.0);
                    });
                mieFolder.addBinding(params.atmosphereHelper.mie, 'extinction', {color: {type: 'float'}, label: 'extinction (per 10 m)'})
                    .on('change', e => {
                        params.atmosphere.mie.extinction = [e.value.r, e.value.g, e.value.b].map(c => c / 100.0);
                    });            
                mieFolder.addBinding(params.atmosphere.mie, 'phaseG', {min: 0.0, max: 1.0, step: 0.1, label: 'phase g'});

                const absorptionFolder = atmosphereFolder.addFolder({
                    title: 'Ozone',
                    expanded: true,
                });
                absorptionFolder.addBinding(params.atmosphereHelper.absorption, 'extinction', {color: {type: 'float'}, label: 'extinction (per 10 m)'})
                    .on('change', e => {
                        params.atmosphere.absorption.extinction = [e.value.r, e.value.g, e.value.b].map(c => c / 100.0);
                    });
            }
            makeUi();

            const projection = mat4n.perspectiveReverseZ(
                90.0 * (Math.PI / 180.0),
                resolution[0] / resolution[1],
                1.0,
            );

            const backBuffer = device.createTexture({
                size: resolution,
                format: 'rgba16float',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            const backBufferView = backBuffer.createView();
            const depthBuffer = device.createTexture({
                size: resolution,
                format: 'depth24plus',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            const depthBufferView = depthBuffer.createView();

            const geometryPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    // todo: actually draw geometry
                    module: device.createShaderModule({
                        code: `
                        @vertex
                        fn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
                            return vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);
                        }
                        `,
                    }),
                    entryPoint: 'vertex',
                },
            });

            const skyRenderTarget = device.createTexture({
                size: resolution,
                format: 'rgba16float',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
            });

            const skyAtmosphereRenderer = new SkyAtmosphereRenderer(device, {
                initializeConstantLutsAtCreation: true,
                useYup: true,
                useRightHanded: true,
                useReverseZ: true,
                compute: {
                    backBuffer: {
                        texture: backBuffer,
                        view: backBufferView,
                    },
                    depthBuffer: {
                        texture: depthBuffer,
                        view: depthBufferView,
                    },
                    renderTarget: {
                        texture: skyRenderTarget,
                        view: skyRenderTarget.createView(),
                    }
                }
            });

            function makePipeline() {
                const module = device.createShaderModule({
                    code: `
                    struct Config {
                        show_transmittance_lut: u32,
                        show_multi_scattering_lut: u32,
                        multi_scattering_scale: u32,
                        show_sky_view_lut: u32,
                        sky_view_lut_scale: u32,
                        show_aerial_perspective: u32,
                        aerial_perspective_scale: u32,
                        aerial_perspective_slice: u32,
                    }
                    @group(0) @binding(0) var<uniform> config: Config;
                    @group(0) @binding(1) var transmittance_lut: texture_2d<f32>;
                    @group(0) @binding(2) var multi_scattering_lut: texture_2d<f32>;
                    @group(0) @binding(3) var sky_view_lut: texture_2d<f32>;
                    @group(0) @binding(4) var aerial_perspective_lut: texture_3d<f32>;
                    @group(0) @binding(5) var backbuffer: texture_2d<f32>;
                        
                    @vertex
                    fn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
                        return vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);
                    }
                    
                    fn coords_in_rect(coords: vec2<u32>, rect_min: vec2<u32>, rect_max: vec2<u32>) -> bool {
                        return all(coords >= rect_min) && all(coords < rect_max);
                    }

                    @fragment
                    fn fragment(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
                        let texture_coords = vec2<u32>(floor(coord.xy));
                        
                        let transmittance_lut_size = textureDimensions(transmittance_lut, 0);
                        let multi_scattering_lut_size = textureDimensions(multi_scattering_lut, 0);
                        let sky_view_lut_size = textureDimensions(sky_view_lut, 0);
                        let aerial_perspective_lut_size = textureDimensions(aerial_perspective_lut, 0).xy;
                        let backbuffer_size = textureDimensions(backbuffer, 0).xy;

                        let transmittance_lut_min_rect = vec2<u32>();
                        let multi_scattering_lut_min_rect = transmittance_lut_min_rect + vec2<u32>(0, transmittance_lut_size.y);
                        let sky_view_lut_min_rect = multi_scattering_lut_min_rect + vec2<u32>(0, multi_scattering_lut_size.y);
                        let aerial_perspective_lut_min_rect = sky_view_lut_min_rect + vec2<u32>(0, sky_view_lut_size.y);
                        
                        if config.show_transmittance_lut == 1 && coords_in_rect(texture_coords, transmittance_lut_min_rect, transmittance_lut_min_rect + transmittance_lut_size) {
                            return vec4(textureLoad(transmittance_lut, texture_coords, 0).rgb, 1.0);
                        } else if config.show_multi_scattering_lut == 1 && coords_in_rect(texture_coords, multi_scattering_lut_min_rect, multi_scattering_lut_min_rect + multi_scattering_lut_size) {
                            return vec4(textureLoad(multi_scattering_lut, vec2<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y), 0).rgb * f32(config.multi_scattering_scale), 1.0);
                        } else if config.show_sky_view_lut == 1 && coords_in_rect(texture_coords, sky_view_lut_min_rect, sky_view_lut_min_rect + sky_view_lut_size) {
                            return vec4(textureLoad(sky_view_lut, vec2<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y - multi_scattering_lut_size.y), 0).rgb * f32(config.sky_view_lut_scale), 1.0);
                        } else if config.show_aerial_perspective == 1 && coords_in_rect(texture_coords, aerial_perspective_lut_min_rect, aerial_perspective_lut_min_rect + aerial_perspective_lut_size) {
                            return vec4(textureLoad(aerial_perspective_lut, vec3<u32>(texture_coords.x, texture_coords.y - transmittance_lut_size.y - multi_scattering_lut_size.y - sky_view_lut_size.y, config.aerial_perspective_slice), 0).rgb * f32(config.aerial_perspective_scale), 1.0);
                        } else if coords_in_rect(texture_coords, vec2<u32>(), backbuffer_size) {
                            let white_point = vec3(1.08241, 0.96756, 0.95003);
                            let exposure = 10.0;
                            let rgb = textureLoad(backbuffer, texture_coords, 0).rgb;
                            return vec4(pow(vec3(1.0) - exp(-rgb / white_point * exposure), vec3(1.0 / 2.2)), 1.0);
                        } else {
                            return vec4(0.5, 0.5, 0.5, 1.0);
                        }
                    }
                    `,
                });
                return device.createRenderPipeline({
                    layout: 'auto',
                    vertex: {
                        module,
                        entryPoint: 'vertex',
                    },
                    fragment: {
                        module,
                        entryPoint: 'fragment',
                        targets: [{ format: presentationFormat }],
                    },
                });
            }

            const presentPipeline = makePipeline();
            const debugViewConfigBuffer = device.createBuffer({
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const bindGroup = device.createBindGroup({
                layout: presentPipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: debugViewConfigBuffer,
                        },
                    },
                    {
                        binding: 1,
                        resource: skyAtmosphereRenderer.resources.transmittanceLut.view,
                    },
                    {
                        binding: 2,
                        resource: skyAtmosphereRenderer.resources.multiScatteringLut.view,
                    },
                    {
                        binding: 3,
                        resource: skyAtmosphereRenderer.resources.skyViewLut.view,
                    },
                    {
                        binding: 4,
                        resource: skyAtmosphereRenderer.resources.aerialPerspectiveLut.view,
                    },
                    {
                        binding: 5,
                        resource: skyRenderTarget.createView(),
                    },
                ],
            });

            let lastTime = new Date();
            const render = () => {
                const now = new Date();
                const dt = (now - lastTime);// / 1000.0;
                lastTime = now;
                cameraController.update(dt);

                const encoder = device.createCommandEncoder();

                device.queue.writeBuffer(debugViewConfigBuffer, 0, new Uint32Array([
                    params.debugViews.showTransmittanceLut,
                    params.debugViews.showMultiScatteringLut,
                    params.debugViews.multiScatteringLutFactor,
                    params.debugViews.showSkyViewLut,
                    params.debugViews.skyViewLutFactor,
                    params.debugViews.showAerialPerspectiveLut,
                    params.debugViews.aerialPerspectiveLutFactor,
                    params.debugViews.aerialPerspectiveSlice,
                ]));

                const config = makeDefaultConfig();
                config.camera.position = cameraController.position;
                config.camera.inverseView = mat4n.inverse(cameraController.view);
                config.camera.inverseProjection = mat4n.inverse(projection);
                config.sun.illuminance = [
                    params.renderSettings.sun.illuminance.r,
                    params.renderSettings.sun.illuminance.g,
                    params.renderSettings.sun.illuminance.b,
                ].map(c => c * params.renderSettings.sun.illuminanceFactor);

                const geometryPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: backBufferView,
                        clearValue: [0,0,0,1],
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthBufferView,
                        depthClearValue: 0.0, // reverse z
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store',
                    },
                });
                geometryPass.end();

                const computePass = encoder.beginComputePass();
                skyAtmosphereRenderer.renderSkyAtmosphere(computePass, false, false, config, params.atmosphere);
                computePass.end();

                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: [0,0,0,1],
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });
                pass.setPipeline(presentPipeline);
                pass.setBindGroup(0, bindGroup);
                pass.draw(3);
                pass.end();

                device.queue.submit([encoder.finish()]);

                requestAnimationFrame(render);
            };
            render();
        }
        main();
    </script>
</body>
</html>