{"version":3,"file":"webgpu-sky-atmosphere.module.min.js","sources":["../../../src/atmosphere.ts","../../../src/util.ts","../../../src/resources.ts","../../src/shaders/common/aerial_perspective.wgsl","../../src/shaders/common/blend.wgsl","../../src/shaders/common/constants.wgsl","../../src/shaders/common/custom_uniforms.wgsl","../../src/shaders/common/coordinate_system.wgsl","../../src/shaders/common/vertex_full_screen.wgsl","../../src/shaders/common/hg_draine_phase_const.wgsl","../../src/shaders/common/hg_draine_large.wgsl","../../src/shaders/common/hg_draine_mid2.wgsl","../../src/shaders/common/hg_draine_mid1.wgsl","../../src/shaders/common/hg_draine_small.wgsl","../../src/shaders/common/intersection.wgsl","../../src/shaders/common/medium.wgsl","../../src/shaders/common/multiple_scattering.wgsl","../../src/shaders/common/phase.wgsl","../../src/shaders/common/sample_sagment_t.wgsl","../../src/shaders/common/shadow_base.wgsl","../../src/shaders/common/sky_view.wgsl","../../src/shaders/common/sun_disk.wgsl","../../src/shaders/common/uniforms.wgsl","../../src/shaders/common/uv.wgsl","../../../src/shaders.ts","../../src/shaders/render_sky_view_lut.wgsl","../../src/shaders/render_aerial_perspective_lut.wgsl","../../src/shaders/render_sky_with_luts.wgsl","../../src/shaders/render_sky_raymarching.wgsl","../../src/shaders/render_sky_luts_and_raymarch.wgsl","../../../src/pipelines.ts","../../../src/lut-renderer.ts","../../../src/sky-renderer-utils.ts","../../../src/sky-compute-renderer.ts","../../../src/sky-raster-renderer.ts"],"sourcesContent":["/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * Rayleigh scattering parameters.\n */\nexport interface Rayleigh {\n\t/**\n     * Rayleigh scattering exponential distribution scale in the atmosphere in `km^-1`.\n     */\n\tdensityExpScale: number,\n\n    /**\n     * Rayleigh scattering coefficients in `km^-1`.\n     */\n\tscattering: [number, number, number],\n}\n\n/**\n * Mie scattering parameters.\n *\n * The Mie phase function is approximated using the Cornette-Shanks phase function.\n */\nexport interface Mie {\n\t/**\n     * Mie scattering exponential distribution scale in the atmosphere in `km^-1`.\n     */\n\tdensityExpScale: number,\n\n    /**\n     * Mie scattering coefficients in `km^-1`.\n     */\n\tscattering: [number, number, number],\n\n    /**\n     * Mie extinction coefficients in `km^-1`.\n     */\n\textinction: [number, number, number],\n\n    /**\n     * Mie phase function parameter.\n     *\n     * For Cornette-Shanks, this is the excentricity, i.e., the asymmetry paraemter of the phase function in range ]-1, 1[.\n     *\n     * For Henyey-Greenstein + Draine, this is the droplet diameter in µm. This should be in range ]2, 20[ (according to the paper, the lower bound for plausible fog particle sizes is 5 µm).\n     * For Henyey-Greenstein + Draine using a constant droplet diameter, this parameter has no effect.\n     */\n\tphaseParam: number,\n}\n\nexport interface AbsorptionLayer0 {\n    /**\n     * The height of the first layer of the absorption component in kilometers.\n     */\n    height: number,\n\n    /**\n     * The constant term of the absorption component's first layer.\n     *\n     * This is unitless.\n     */\n    constantTerm: number,\n\n    /**\n     * The linear term of the absorption component's first layer in `km^-1`.\n     */\n    linearTerm: number,\n}\n\nexport interface AbsorptionLayer1 {\n    /**\n     * The constant term of the absorption component's second layer.\n     *\n     * This is unitless.\n     */\n    constantTerm: number,\n\n    /**\n     * The linear term of the absorption component's second layer in `km^-1`.\n     */\n    linearTerm: number,\n}\n\n/**\n * A medium type in the atmosphere that only absorbs light with two layers.\n * In Earth's atmosphere this is used to model ozone.\n *\n * Computed as:\n *\n *      extinction * (linearTerm * h + constantTerm),\n *\n * where `h` is the altitude and `linearTerm` and `constantTerm` are the first or second layer's linear and constant terms.\n * If `h` is lower than {@link AbsorptionLayer0.height}, {@link Absorption.layer0} is used, otherwise {@link Absorption.layer1} is used.\n */\nexport interface Absorption {\n    /**\n     * The lower layer of the absorption component.\n     */\n    layer0: AbsorptionLayer0,\n\n    /**\n     * The upper layer of the absorption component.\n     */\n    layer1: AbsorptionLayer1,\n\n    /**\n    * The extinction coefficients of the absorption component in `km^-1`.\n    */\n   extinction: [number, number, number],\n}\n\n/**\n * Atmosphere parameters.\n *\n * The atmosphere is modelled as a sphere around a spherical planet.\n */\nexport interface Atmosphere {\n    /**\n     * Center of the atmosphere.\n     */\n    center: [number, number, number],\n\n    /**\n     * Radius of the planet (center to ground) in kilometers.\n     */\n\tbottomRadius: number,\n\n    /**\n     * Height of atmosphere (distance from {@link bottomRadius} to atmosphere top) in kilometers.\n     *\n     * Clamped to `max(height, 0)`\n     */\n\theight: number,\n\n    /**\n     * Rayleigh scattering component.\n     */\n    rayleigh: Rayleigh,\n\n    /**\n     * Mie scattering component.\n     */\n    mie: Mie,\n\n    /**\n     * Absorption / Ozone component.\n     */\n\tabsorption: Absorption,\n\n\t/**\n     * The average albedo of the ground used to model light bounced off the planet's surface.\n     */\n\tgroundAlbedo: [number, number, number],\n\n    /**\n     * A weight for multiple scattering in the atmosphere.\n     */\n    multipleScatteringFactor: number,\n}\n\n/**\n * Create a default atmosphere that corresponds to earth's atmosphere.\n *\n * @param center The center of the atmosphere. Defaults to `upDirection * -{@link Atmosphere.bottomRadius}` (`upDirection` depends on `yUp`).\n * @param yUp If true, the up direction for the default center will be `[0, 1, 0]`, otherwise `[0, 0, 1]` will be used.\n * @param useHenyeyGreenstein If this is true, {@link Mie.phaseParam} will be set to a value suitable for the Cornette-Shanks approximation (`0.8`), otherwise it is set to `3.4` for use with the Henyey-Greenstein + Draine approximation.\n *\n * @returns Atmosphere parameters corresponding to earth's atmosphere.\n */\nexport function makeEarthAtmosphere(center?: [number, number, number], yUp = true, useHenyeyGreenstein = true): Atmosphere {\n    const rayleighScaleHeight = 8.0;\n    const mieScaleHeight = 1.2;\n    const bottomRadius = 6360.0;\n    return {\n        center: center ?? [0.0, yUp ? -bottomRadius : 0.0, yUp ? 0.0 : -bottomRadius],\n        bottomRadius,\n        height: 100.0,\n        rayleigh: {\n            densityExpScale: -1.0 / rayleighScaleHeight,\n            scattering: [0.005802, 0.013558, 0.033100],\n        },\n        mie: {\n            densityExpScale: -1.0 / mieScaleHeight,\n            scattering: [0.003996, 0.003996, 0.003996],\n            extinction: [0.004440, 0.004440, 0.004440],\n            phaseParam: useHenyeyGreenstein ? 0.8 : 3.4,\n        },\n        absorption: {\n            layer0: {\n                height: 25.0,\n                constantTerm: -2.0 / 3.0,\n                linearTerm: 1.0 / 15.0,\n            },\n            layer1: {\n                constantTerm: 8.0 / 3.0,\n                linearTerm: -1.0 / 15.0,\n            },\n            extinction: [0.000650, 0.001881, 0.000085],\n        },\n        groundAlbedo: [0.4, 0.4, 0.4],\n        multipleScatteringFactor: 1.0,\n    };\n}\n","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * A helper class for textures.\n */\nexport class LookUpTable {\n    readonly texture: GPUTexture;\n    readonly view: GPUTextureView;\n\n    constructor(texture: GPUTexture) {\n        this.texture = texture;\n        this.view = texture.createView({\n            label: texture.label,\n        });\n    }\n}\n\n/**\n * A helper class for compute passes\n */\nexport class ComputePass {\n    constructor(readonly pipeline: GPUComputePipeline, readonly bindGroups: GPUBindGroup[], readonly dispatchDimensions: [number, number, number]) {}\n    encode(computePassEncoder: GPUComputePassEncoder, resetBindGroups: boolean = false) {\n        computePassEncoder.setPipeline(this.pipeline);\n        for (let i = 0; i < this.bindGroups.length; ++i) {\n            computePassEncoder.setBindGroup(i, this.bindGroups[i]);\n        }\n        computePassEncoder.dispatchWorkgroups(...this.dispatchDimensions);\n        if (resetBindGroups) {\n            for (let i = 0; i < this.bindGroups.length; ++i) {\n                computePassEncoder.setBindGroup(i, null);\n            }\n        }\n    }\n    replaceBindGroup(index: number, bindGroup: GPUBindGroup) {\n        this.bindGroups[index] = bindGroup;\n    }\n    replaceDispatchDimensions(dispatchDimensions: [number, number, number]) {\n        this.dispatchDimensions[0] = dispatchDimensions[0];\n        this.dispatchDimensions[1] = dispatchDimensions[1];\n        this.dispatchDimensions[2] = dispatchDimensions[2];\n    }\n}\n\n/**\n * A helper class for render passes\n */\nexport class RenderPass {\n    constructor(readonly pipeline: GPURenderPipeline, readonly bindGroups: GPUBindGroup[]) {}\n    encode(passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder, resetBindGroups: boolean = false) {\n        passEncoder.setPipeline(this.pipeline);\n        for (let i = 0; i < this.bindGroups.length; ++i) {\n            passEncoder.setBindGroup(i, this.bindGroups[i]);\n        }\n        passEncoder.draw(3);\n        if (resetBindGroups) {\n            for (let i = 0; i < this.bindGroups.length; ++i) {\n                passEncoder.setBindGroup(i, null);\n            }\n        }\n    }\n    replaceBindGroup(index: number, bindGroup: GPUBindGroup) {\n        this.bindGroups[index] = bindGroup;\n    }\n}\n\nexport function makeLutSampler(device: GPUDevice): GPUSampler {\n    return device.createSampler({\n        label: 'LUT sampler',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n        addressModeW: 'clamp-to-edge',\n        minFilter: 'linear',\n        magFilter: 'linear',\n        mipmapFilter: 'linear',\n        lodMinClamp: 0,\n        lodMaxClamp: 32,\n        maxAnisotropy: 1,\n    });\n}\n","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { Atmosphere, makeEarthAtmosphere } from './atmosphere.js';\nimport { SkyAtmosphereRendererConfig } from './config.js';\nimport { Uniforms } from './uniforms.js';\nimport { LookUpTable, makeLutSampler } from './util.js';\n\nexport const DEFAULT_TRANSMITTANCE_LUT_SIZE: [number, number] = [256, 64];\nexport const DEFAULT_MULTISCATTERING_LUT_SIZE: number = 32;\nexport const DEFAULT_SKY_VIEW_LUT_SIZE: [number, number] = [192, 108];\nexport const DEFAULT_AERIAL_PERSPECTIVE_LUT_SIZE: [number, number, number] = [32, 32, 32];\n\nexport const TRANSMITTANCE_LUT_FORMAT: GPUTextureFormat = 'rgba16float';\nexport const MULTI_SCATTERING_LUT_FORMAT: GPUTextureFormat = TRANSMITTANCE_LUT_FORMAT;\nexport const SKY_VIEW_LUT_FORMAT: GPUTextureFormat = TRANSMITTANCE_LUT_FORMAT;\nexport const AERIAL_PERSPECTIVE_LUT_FORMAT: GPUTextureFormat = TRANSMITTANCE_LUT_FORMAT;\n\nexport const ATMOSPHERE_BUFFER_SIZE: number = 128;\nexport const UNIFORMS_BUFFER_SIZE: number = 224;\n\nexport class SkyAtmosphereResources {\n    /**\n     * A name that is propagated to the WebGPU resources.\n     */\n    readonly label: string;\n\n    /**\n     * The WebGPU device the resources are allocated from.\n     */\n    readonly device: GPUDevice;\n\n    /**\n     * A uniform buffer of size {@link ATMOSPHERE_BUFFER_SIZE} storing the {@link Atmosphere}'s parameters.\n     */\n    readonly atmosphereBuffer: GPUBuffer;\n\n    /**\n     * A uniform buffer of size {@link UNIFORMS_BUFFER_SIZE} storing parameters set through {@link Uniforms}.\n     *\n     * If custom uniform buffers are used, this is undefined (see {@link CustomUniformsSourceConfig}).\n     */\n    readonly uniformsBuffer?: GPUBuffer;\n\n    /**\n     * A linear sampler used to sample the look up tables.\n     */\n    readonly lutSampler: GPUSampler;\n\n    /**\n     * The transmittance look up table.\n     * Stores the medium transmittance toward the sun.\n     *\n     * Parameterized by the view / zenith angle in x and the altitude in y.\n     */\n    readonly transmittanceLut: LookUpTable;\n\n    /**\n     * The multiple scattering look up table.\n     * Stores multiple scattering contribution.\n     *\n     * Paramterized by the sun / zenith angle in x (range: [π, 0]) and the altitude in y (range: [0, top], where top is the height of the atmosphere).\n     */\n    readonly multiScatteringLut: LookUpTable;\n\n    /**\n     * The sky view look up table.\n     * Stores the distant sky around the camera with respect to it's altitude within the atmosphere.\n     *\n     * Parameterized by the longitude in x (range: [0, 2π]) and latitude in y (range: [-π/2, π/2]).\n     */\n    readonly skyViewLut: LookUpTable;\n\n    /**\n     * The aerial perspective look up table.\n     * Stores the aerial perspective in a volume fit to the view frustum.\n     *\n     * Parameterized by x and y corresponding to the image plane and z being the view depth (range: [0, {@link AerialPerspectiveLutConfig.size}[2] * {@link AerialPerspectiveLutConfig.distancePerSlice}]).\n     */\n    readonly aerialPerspectiveLut: LookUpTable;\n\n    /**\n     * {@link Atmosphere} parameters.\n     *\n     * Set using {@link updateAtmosphere}.\n     *\n     * @see {@link updateAtmosphere}\n     */\n    #atmosphere: Atmosphere;\n\n    constructor(device: GPUDevice, config: SkyAtmosphereRendererConfig, lutSampler?: GPUSampler) {\n        this.label = config.label ?? 'atmosphere';\n        this.device = device;\n\n        this.#atmosphere = config.atmosphere ?? makeEarthAtmosphere();\n\n        this.atmosphereBuffer = device.createBuffer({\n            label: `atmosphere buffer [${this.label}]`,\n            size: ATMOSPHERE_BUFFER_SIZE,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n        this.updateAtmosphere(this.#atmosphere);\n\n        if (config.customUniformsSource) {\n            this.uniformsBuffer = undefined;\n        } else {\n            this.uniformsBuffer = device.createBuffer({\n                label: `config buffer [${this.label}]`,\n                size: UNIFORMS_BUFFER_SIZE,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n        }\n\n        this.lutSampler = lutSampler || makeLutSampler(device);\n\n        this.transmittanceLut = new LookUpTable(device.createTexture({\n            label: `transmittance LUT [${this.label}]`,\n            size: config.lookUpTables?.transmittanceLut?.size ?? DEFAULT_TRANSMITTANCE_LUT_SIZE,\n            format: config.lookUpTables?.transmittanceLut?.format ?? TRANSMITTANCE_LUT_FORMAT,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,\n        }));\n\n        this.multiScatteringLut = new LookUpTable(device.createTexture({\n            label: `multi scattering LUT [${this.label}]`,\n            size: config.lookUpTables?.multiScatteringLut?.size ?? [DEFAULT_MULTISCATTERING_LUT_SIZE, DEFAULT_MULTISCATTERING_LUT_SIZE],\n            format: config.lookUpTables?.multiScatteringLut?.format ?? MULTI_SCATTERING_LUT_FORMAT,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,\n        }));\n\n        this.skyViewLut = new LookUpTable(device.createTexture({\n            label: `sky view LUT [${this.label}]`,\n            size: config.lookUpTables?.skyViewLut?.size ?? DEFAULT_SKY_VIEW_LUT_SIZE,\n            format: config.lookUpTables?.skyViewLut?.format ?? SKY_VIEW_LUT_FORMAT,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,\n        }));\n\n        this.aerialPerspectiveLut = new LookUpTable(device.createTexture({\n            label: `aerial perspective LUT [${this.label}]`,\n            size: config.lookUpTables?.aerialPerspectiveLut?.size ?? DEFAULT_AERIAL_PERSPECTIVE_LUT_SIZE,\n            format: config.lookUpTables?.aerialPerspectiveLut?.format ?? AERIAL_PERSPECTIVE_LUT_FORMAT,\n            dimension: '3d',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,\n        }));\n    }\n\n    get atmosphere() {\n        return this.#atmosphere;\n    }\n\n    /**\n     * Updates the {@link SkyAtmosphereResources.atmosphereBuffer} using a given {@link Atmosphere}.\n     *\n     * Overwrites this instance's internal {@link Atmosphere} parameters.\n     *\n     * @param atmosphere the {@link Atmosphere} to write to the {@link atmosphereBuffer}.\n     * @see atmosphereToFloatArray Internally call {@link atmosphereToFloatArray} to convert the {@link Atmosphere} to a `Float32Array`.\n     */\n    public updateAtmosphere(atmosphere: Atmosphere) {\n        this.#atmosphere = atmosphere;\n        this.device.queue.writeBuffer(this.atmosphereBuffer, 0, atmosphereToFloatArray(this.#atmosphere));\n    }\n\n    /**\n     * Updates the {@link SkyAtmosphereResources.uniformsBuffer} using a given {@link Uniforms}.\n     * @param uniforms the {@link Uniforms} to write to the {@link atmosphereBuffer}.\n     * @see uniformsToFloatArray Internally call {@link uniformsToFloatArray} to convert the {@link Uniforms} to a `Float32Array`.\n     */\n    public updateUniforms(uniforms: Uniforms) {\n        if (this.uniformsBuffer) {\n            this.device.queue.writeBuffer(this.uniformsBuffer, 0, uniformsToFloatArray(uniforms));\n        }\n    }\n}\n\n/**\n * Converts an {@link Atmosphere} to a tightly packed `Float32Array` of size {@link ATMOSPHERE_BUFFER_SIZE}.\n * @param atmosphere the {@link Atmosphere} to convert.\n * @returns a `Float32Array` containing the {@link Atmosphere} parameters.\n */\nexport function atmosphereToFloatArray(atmosphere: Atmosphere): Float32Array {\n    return new Float32Array([\n        atmosphere.rayleigh.scattering[0],\n        atmosphere.rayleigh.scattering[1],\n        atmosphere.rayleigh.scattering[2],\n        atmosphere.rayleigh.densityExpScale,\n        atmosphere.mie.scattering[0],\n        atmosphere.mie.scattering[1],\n        atmosphere.mie.scattering[2],\n        atmosphere.mie.densityExpScale,\n        atmosphere.mie.extinction[0],\n        atmosphere.mie.extinction[1],\n        atmosphere.mie.extinction[2],\n        atmosphere.mie.phaseParam,\n        Math.max(atmosphere.mie.extinction[0] - atmosphere.mie.scattering[0], 0.0),\n        Math.max(atmosphere.mie.extinction[1] - atmosphere.mie.scattering[1], 0.0),\n        Math.max(atmosphere.mie.extinction[2] - atmosphere.mie.scattering[2], 0.0),\n        atmosphere.absorption.layer0.height,\n        atmosphere.absorption.layer0.constantTerm,\n        atmosphere.absorption.layer0.linearTerm,\n        atmosphere.absorption.layer1.constantTerm,\n        atmosphere.absorption.layer1.linearTerm,\n        atmosphere.absorption.extinction[0],\n        atmosphere.absorption.extinction[1],\n        atmosphere.absorption.extinction[2],\n        atmosphere.bottomRadius,\n        atmosphere.groundAlbedo[0],\n        atmosphere.groundAlbedo[1],\n        atmosphere.groundAlbedo[2],\n        atmosphere.bottomRadius + Math.max(atmosphere.height, 0.0),\n        ...atmosphere.center,\n        atmosphere.multipleScatteringFactor,\n    ]);\n}\n\n/**\n * Converts an {@link Uniforms} to a tightly packed `Float32Array` of size {@link UNIFORMS_BUFFER_SIZE}.\n * @param uniforms the {@link Uniforms} to convert.\n * @returns a `Float32Array` containing the {@link Uniforms} parameters.\n */\nexport function uniformsToFloatArray(uniforms: Uniforms): Float32Array {\n    return new Float32Array([\n        ...uniforms.camera.inverseProjection,\n        ...uniforms.camera.inverseView,\n        ...uniforms.camera.position,\n        uniforms.frameId ?? 0.0,\n        ...uniforms.screenResolution,\n        uniforms.rayMarchMinSPP ?? 14.0,\n        uniforms.rayMarchMaxSPP ?? 30.0,\n        ...(uniforms.sun.illuminance ?? [1.0, 1.0, 1.0]),\n        uniforms.sun.diskAngularDiameter ?? (0.545 * (Math.PI / 180.0)),\n        ...uniforms.sun.direction,\n        uniforms.sun.diskLuminanceScale ?? 1.0,\n        ...(uniforms.moon?.illuminance ?? [1.0, 1.0, 1.0]),\n        uniforms.moon?.diskAngularDiameter ?? (0.568 * Math.PI / 180.0),\n        ...(uniforms.moon?.direction ?? uniforms.sun.direction.map(d => d * -1)),\n        uniforms.moon?.diskLuminanceScale ?? 1.0,\n    ]);\n}\n\n","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride AP_SLICE_COUNT: f32 = 32.0;\\noverride AP_DISTANCE_PER_SLICE: f32 = 4.0;\\n\\noverride AP_INV_DISTANCE_PER_SLICE: f32 = 1.0 / AP_DISTANCE_PER_SLICE;\\n\\nfn aerial_perspective_depth_to_slice(depth: f32) -> f32 {\\n\\treturn depth * AP_INV_DISTANCE_PER_SLICE;\\n}\\nfn aerial_perspective_slice_to_depth(slice: f32) -> f32 {\\n\\treturn slice * AP_DISTANCE_PER_SLICE;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\nfn blend(pix: vec2<u32>, src: vec4<f32>) {\\n\\tlet dst = textureLoad(backbuffer, pix, 0);\\n\\t// blend op:        src*1 + dst * (1.0 - srcA)\\n\\t// alpha blend op:  src  * 0 + dst * 1\\n\\tlet rgb = src.rgb + dst.rgb * (1.0 - saturate(src.a));\\n\\tlet a = dst.a;\\n\\ttextureStore(render_target, pix, vec4<f32>(rgb, a));\\n}\\n\\nfn dual_source_blend(pix: vec2<u32>, src0: vec4<f32>, src1: vec4<f32>) {\\n\\tlet dst = textureLoad(backbuffer, pix, 0);\\n\\t// blend op:        src0 * 1 + dst * src1\\n\\t// alpha blend op:  src  * 0 + dst * 1\\n\\tlet rgb = src0.rgb + dst.rgb * src1.rgb;\\n\\tlet a = dst.a;\\n\\ttextureStore(render_target, pix, vec4<f32>(rgb, a));\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\nconst pi: f32 = radians(180.0);\\nconst tau: f32 = pi * 2.0;\\nconst golden_ratio: f32 = (1.0 + sqrt(5.0)) / 2.0;\\n\\nconst u32_max: f32 = 4294967296.0;\\n\\nconst sphere_solid_angle: f32 = 4.0 * pi;\\n\\nconst t_max_max: f32 = 9000000.0;\\nconst planet_radius_offset: f32 = 0.01;\\n\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\nfn get_uniforms() -> Uniforms {\\n\\tUniforms uniforms;\\n\\tuniforms.inverse_projection = get_inverse_projection();\\n\\tuniforms.inverse_view = get_inverse_view();\\n\\tuniforms.camera_world_position = get_camera_world_position();\\n\\tuniforms.frame_id = get_frame_id();\\n\\tuniforms.screen_resolution = get_screen_resolution();\\n\\tuniforms.ray_march_min_spp = get_ray_march_min_spp();\\n\\tuniforms.ray_march_max_spp = get_ray_march_max_spp();\\n\\tuniforms.sun.illuminance = get_sun_illuminance();\\n\\tuniforms.sun.direction = get_sun_direction();\\n\\tuniforms.sun.disk_diameter =  get_sun_disk_diameter();\\n\\tuniforms.sun.disk_luminance_scale = get_sun_disk_luminance_scale();\\n\\tuniforms.moon.illuminance = get_moon_illuminance();\\n\\tuniforms.moon.direction = get_moon_direction();\\n\\tuniforms.moon.disk_diameter =  get_moon_disk_diameter();\\n\\tuniforms.moon.disk_luminance_scale = get_moon_disk_luminance_scale();\\n\\treturn uniforms;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride IS_REVERSE_Z: bool = true;\\n\\noverride FROM_KM_SCALE: f32 = 1.0;\\noverride TO_KM_SCALE: f32 = 1.0 / FROM_KM_SCALE;\\n\\nfn depth_max() -> f32 {\\n\\tif IS_REVERSE_Z {\\n\\t\\treturn 0.0000001;\\n\\t} else {\\n\\t\\treturn 1.0;\\n\\t}\\n}\\n\\nfn is_valid_depth(depth: f32) -> bool {\\n\\tif IS_REVERSE_Z {\\n\\t\\treturn depth > 0.0 && depth <= 1.0;\\n\\t} else {\\n\\t\\treturn depth < 1.0 && depth >= 0.0;\\n\\t}\\n}\\n\\nfn uv_to_world_dir(uv: vec2<f32>, inv_proj: mat4x4<f32>, inv_view: mat4x4<f32>) -> vec3<f32> {\\n\\tlet hom_view_space = inv_proj * vec4(vec3(uv * vec2(2.0, -2.0) - vec2(1.0, -1.0), depth_max()), 1.0);\\n\\treturn normalize((inv_view * vec4(hom_view_space.xyz / hom_view_space.w, 0.0)).xyz);\\n}\\n\\nfn uv_and_depth_to_world_pos(uv: vec2<f32>, inv_proj: mat4x4<f32>, inv_view: mat4x4<f32>, depth: f32) -> vec3<f32> {\\n\\tlet hom_view_space = inv_proj * vec4(vec3(uv * vec2(2.0, -2.0) - vec2(1.0, -1.0), depth), 1.0);\\n\\treturn (inv_view * vec4(hom_view_space.xyz / hom_view_space.w, 1.0)).xyz * TO_KM_SCALE;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\n@vertex\\nfn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {\\n\\treturn vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride HG_DRAINE_ALPHA_THIRDS = HG_DRAINE_ALPHA / 3.0;\\noverride HG_DRAINE_G_HG_2 = HG_DRAINE_G_HG * HG_DRAINE_G_HG;\\noverride HG_DRAINE_G_D_2 = HG_DRAINE_G_D * HG_DRAINE_G_D;\\noverride HG_DRAINE_CONST_DENOM = 1.0 / (1.0 + (HG_DRAINE_ALPHA * (1.0 / 3.0) * (1.0 + (2.0 * HG_DRAINE_G_D_2))));\\n\\nfn draine_phase_hg(cos_theta: f32) -> f32 {\\n    return one_over_four_pi *\\n        ((1.0 - HG_DRAINE_G_HG_2) / pow((1.0 + HG_DRAINE_G_HG_2 - (2.0 * HG_DRAINE_G_HG * cos_theta)), 1.5));\\n}\\n\\nfn draine_phase_d(cos_theta: f32) -> f32 {\\n    return one_over_four_pi *\\n          ((1.0 - HG_DRAINE_G_D_2) / pow((1.0 + HG_DRAINE_G_D_2 - (2.0 * HG_DRAINE_G_D * cos_theta)), 1.5)) *\\n          ((1.0 + (HG_DRAINE_ALPHA * cos_theta * cos_theta)) * HG_DRAINE_CONST_DENOM);\\n}\\n\\nfn hg_draine_phase(cos_theta: f32) -> f32 {\\n    return mix(draine_phase_hg(cos_theta), draine_phase_d(cos_theta), HG_DRAINE_W_D);\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// 5 µm ≤ 𝑑 ≤ 50 µm\\noverride HG_DRAINE_G_HG = exp(-(0.0990567 / (HG_DRAINE_DROPLET_DIAMETER - 1.67154)));\\noverride HG_DRAINE_G_D = exp(-(2.20679 / (HG_DRAINE_DROPLET_DIAMETER + 3.91029)) - 0.428934);\\noverride HG_DRAINE_ALPHA = exp(3.62489 - (8.29288 / (HG_DRAINE_DROPLET_DIAMETER + 5.52825)));\\noverride HG_DRAINE_W_D = exp(-(0.599085 / (HG_DRAINE_DROPLET_DIAMETER - 0.641583)) - 0.665888);\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// 1.5 µm <= 𝑑 < 5 µm\\noverride HG_DRAINE_G_HG = 0.0604931 * log(log(HG_DRAINE_DROPLET_DIAMETER)) + 0.940256;\\noverride HG_DRAINE_G_D = 0.500411 - 0.081287 / (-2.0 * log(HG_DRAINE_DROPLET_DIAMETER) + tan(log(HG_DRAINE_DROPLET_DIAMETER)) + 1.27551);\\noverride HG_DRAINE_ALPHA = 7.30354 * log(HG_DRAINE_DROPLET_DIAMETER) + 6.31675;\\noverride HG_DRAINE_W_D = 0.026914 * (log(HG_DRAINE_DROPLET_DIAMETER) - cos(5.68947 * (log(log(HG_DRAINE_DROPLET_DIAMETER)) - 0.0292149))) + 0.376475;\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// 0.1 µm < 𝑑 < 1.5 µm\\noverride HG_DRAINE_G_HG = 0.862 - 0.143 * log(HG_DRAINE_DROPLET_DIAMETER) * log(HG_DRAINE_DROPLET_DIAMETER);\\noverride HG_DRAINE_G_D = 0.379685 * cos(1.19692 * cos(((log(HG_DRAINE_DROPLET_DIAMETER) - 0.238604) * (log(HG_DRAINE_DROPLET_DIAMETER) + 1.00667)) / (0.507522 - 0.15677 * log(HG_DRAINE_DROPLET_DIAMETER))) + 1.37932 * log(HG_DRAINE_DROPLET_DIAMETER) + 0.0625835) + 0.344213;\\noverride HG_DRAINE_ALPHA = 250.0;\\noverride HG_DRAINE_W_D = 0.146209 * cos(3.38707 * log(HG_DRAINE_DROPLET_DIAMETER) + 2.11193) + 0.316072 + 0.0778917 * log(HG_DRAINE_DROPLET_DIAMETER);\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// 𝑑 <= 0.1 µm\\noverride HG_DRAINE_G_HG = 13.8 * HG_DRAINE_DROPLET_DIAMETER * HG_DRAINE_DROPLET_DIAMETER;\\noverride HG_DRAINE_G_D = 1.1456 * HG_DRAINE_DROPLET_DIAMETER * sin(9.29044 * HG_DRAINE_DROPLET_DIAMETER);\\noverride HG_DRAINE_ALPHA = 250.0;\\noverride HG_DRAINE_W_D = 0.252977 - pow(312.983 * HG_DRAINE_DROPLET_DIAMETER, 4.3);\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// If there are no positive real solutions, returns -1.0\\nfn solve_quadratic_for_positive_reals(a: f32, b: f32, c: f32) -> f32 {\\n\\tlet delta = b * b - 4.0 * a * c;\\n\\tif delta < 0.0 || a == 0.0 {\\n\\t\\treturn -1.0;\\n\\t}\\n\\tlet solution0 = (-b - sqrt(delta)) / (2.0 * a);\\n\\tlet solution1 = (-b + sqrt(delta)) / (2.0 * a);\\n\\tif solution0 < 0.0 && solution1 < 0.0 {\\n\\t\\treturn -1.0;\\n\\t}\\n\\tif solution0 < 0.0 {\\n\\t\\treturn max(0.0, solution1);\\n\\t}\\n\\telse if solution1 < 0.0 {\\n\\t\\treturn max(0.0, solution0);\\n\\t}\\n\\treturn max(0.0, min(solution0, solution1));\\n}\\n\\nfn quadratic_has_positive_real_solutions(a: f32, b: f32, c: f32) -> bool {\\n\\tlet delta = b * b - 4.0 * a * c;\\n\\treturn (delta >= 0.0 && a != 0.0) && (((-b - sqrt(delta)) / (2.0 * a)) >= 0.0 || ((-b + sqrt(delta)) / (2.0 * a)) >= 0.0);\\n}\\n\\nfn find_closest_ray_sphere_intersection(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {\\n\\tlet dist = o - c;\\n\\treturn solve_quadratic_for_positive_reals(dot(d, d), 2.0 * dot(d, dist), dot(dist, dist) - (r * r));\\n}\\n\\nfn ray_intersects_sphere(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> bool {\\n\\tlet dist = o - c;\\n\\treturn quadratic_has_positive_real_solutions(dot(d, d), 2.0 * dot(d, dist), dot(dist, dist) - (r * r));\\n}\\n\\nfn compute_planet_shadow(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {\\n\\treturn f32(!ray_intersects_sphere(o, d, c, r));\\n}\\n\\nfn find_atmosphere_t_max(t_max: ptr<function, f32>, o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, bottom_radius: f32, top_radius: f32) -> bool {\\n\\tlet t_bottom = find_closest_ray_sphere_intersection(o, d, c, bottom_radius);\\n\\tlet t_top = find_closest_ray_sphere_intersection(o, d, c, top_radius);\\n\\tif t_bottom < 0.0 {\\n\\t\\tif t_top < 0.0 {\\n\\t\\t\\t*t_max = 0.0;\\n\\t\\t\\treturn false;\\n\\t\\t} else {\\n\\t\\t\\t*t_max = t_top;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif t_top > 0.0 {\\n\\t\\t\\t*t_max = min(t_top, t_bottom);\\n\\t\\t} else {\\n\\t\\t\\t*t_max = t_bottom;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\nfn find_atmosphere_t_max_t_bottom(t_max: ptr<function, f32>, t_bottom: ptr<function, f32>, o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, bottom_radius: f32, top_radius: f32) -> bool {\\n\\t*t_bottom = find_closest_ray_sphere_intersection(o, d, c, bottom_radius);\\n\\tlet t_top = find_closest_ray_sphere_intersection(o, d, c, top_radius);\\n\\tif *t_bottom < 0.0 {\\n\\t\\tif t_top < 0.0 {\\n\\t\\t\\t*t_max = 0.0;\\n\\t\\t\\treturn false;\\n\\t\\t} else {\\n\\t\\t\\t*t_max = t_top;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif t_top > 0.0 {\\n\\t\\t\\t*t_max = min(t_top, *t_bottom);\\n\\t\\t} else {\\n\\t\\t\\t*t_max = *t_bottom;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\nfn move_to_atmosphere_top(world_pos: ptr<function, vec3<f32>>, world_dir: vec3<f32>, top_radius: f32) -> bool {\\n\\tlet view_height = length(*world_pos);\\n\\tif view_height > top_radius {\\n\\t\\tlet t_top = find_closest_ray_sphere_intersection(*world_pos, world_dir, vec3(), top_radius * 0.9999);\\n\\t\\tif t_top >= 0.0 {\\n\\t\\t\\t*world_pos = *world_pos + world_dir * t_top;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\nstruct Atmosphere {\\n\\t// Rayleigh scattering coefficients\\n\\trayleigh_scattering: vec3<f32>,\\n\\t// Rayleigh scattering exponential distribution scale in the atmosphere\\n\\trayleigh_density_exp_scale: f32,\\n\\n\\t// Mie scattering coefficients\\n\\tmie_scattering: vec3<f32>,\\n\\t// Mie scattering exponential distribution scale in the atmosphere\\n\\tmie_density_exp_scale: f32,\\n\\t// Mie extinction coefficients\\n\\tmie_extinction: vec3<f32>,\\n\\t// Mie phase parameter (Cornette-Shanks excentricity or Henyey-Greenstein-Draine droplet diameter)\\n\\tmie_phase_param: f32,\\n\\t// Mie absorption coefficients\\n\\tmie_absorption: vec3<f32>,\\n\\t\\n\\t// Another medium type in the atmosphere\\n\\tabsorption_density_0_layer_height: f32,\\n\\tabsorption_density_0_constant_term: f32,\\n\\tabsorption_density_0_linear_term: f32,\\n\\tabsorption_density_1_constant_term: f32,\\n\\tabsorption_density_1_linear_term: f32,\\n\\t// This other medium only absorb light, e.g. useful to represent ozone in the earth atmosphere\\n\\tabsorption_extinction: vec3<f32>,\\n\\n\\t// Radius of the planet (center to ground)\\n\\tbottom_radius: f32,\\n\\n\\t// The albedo of the ground.\\n\\tground_albedo: vec3<f32>,\\n\\n\\t// Maximum considered atmosphere height (center to atmosphere top)\\n\\ttop_radius: f32,\\n\\n\\t// planet center in world space (z up)\\n\\t// used to transform the camera's position to the atmosphere's object space\\n\\tplanet_center: vec3<f32>,\\n\\t\\n\\tmulti_scattering_factor: f32,\\n}\\n\\nfn make_earth_atmosphere(use_henyey_greenstein: bool) -> Atmosphere {\\n\\tlet earth_rayleigh_scale_height = 8.0;\\n\\tlet earth_mie_scale_height = 1.2;\\n\\n\\tvar atmosphere: Atmosphere;\\n\\n\\tatmosphere.bottom_radius = 6360.0;\\n\\tatmosphere.top_radius = 6460.0;\\n\\n\\tatmosphere.rayleigh_density_exp_scale = -1.0 / earth_rayleigh_scale_height;\\n\\tatmosphere.rayleigh_scattering = vec3(0.005802, 0.013558, 0.033100);    // 1/km\\n\\n\\tatmosphere.mie_density_exp_scale = -1.0 / earth_mie_scale_height;\\n\\tatmosphere.mie_scattering = vec3(0.003996, 0.003996, 0.003996);\\t\\t\\t// 1/km\\n\\tatmosphere.mie_extinction = vec3(0.004440, 0.004440, 0.004440);\\t\\t\\t// 1/km\\n\\tatmosphere.mie_absorption = max(atmosphere.mie_extinction - atmosphere.mie_scattering, vec3());\\n\\tif use_henyey_greenstein {\\n\\t\\tatmosphere.mie_phase_param = 0.8;\\n\\t} else {\\n\\t\\tatmosphere.mie_phase_param = 5.0;\\n\\t}\\n\\t\\n\\tatmosphere.absorption_extinction = vec3(0.000650, 0.001881, 0.000085);\\t// 1/km\\n\\tatmosphere.absorption_density_0_layer_height = 25.0;\\n\\tatmosphere.absorption_density_0_constant_term = -2.0 / 3.0;\\n\\tatmosphere.absorption_density_0_linear_term = 1.0 / 15.0;\\n\\tatmosphere.absorption_density_1_constant_term = 8.0 / 3.0;\\n\\tatmosphere.absorption_density_1_linear_term = -1.0 / 15.0;\\n\\n\\tatmosphere.ground_albedo = vec3(0.0, 0.0, 0.0);\\n\\n\\tatmosphere.multi_scattering_factor = 1.0;\\n\\t\\n\\treturn atmosphere;\\n}\\n\\nstruct MediumSample {\\n\\tscattering: vec3<f32>,\\n\\textinction: vec3<f32>,\\n\\n\\tmie_scattering: vec3<f32>,\\n\\trayleigh_scattering: vec3<f32>,\\n}\\n\\n/*\\n * origin is the planet's center\\n */\\nfn sample_medium_extinction(height: f32, atmosphere: Atmosphere) -> vec3<f32> {\\n\\tlet mie_density: f32 = exp(atmosphere.mie_density_exp_scale * height);\\n\\tlet rayleigh_density: f32 = exp(atmosphere.rayleigh_density_exp_scale * height);\\n\\tvar absorption_density: f32;\\n\\tif height < atmosphere.absorption_density_0_layer_height {\\n\\t\\tabsorption_density = saturate(atmosphere.absorption_density_0_linear_term * height + atmosphere.absorption_density_0_constant_term);\\n\\t} else {\\n\\t\\tabsorption_density = saturate(atmosphere.absorption_density_1_linear_term * height + atmosphere.absorption_density_1_constant_term);\\n\\t}\\n\\n\\tlet mie_extinction = mie_density * atmosphere.mie_extinction;\\n\\tlet rayleigh_extinction = rayleigh_density * atmosphere.rayleigh_scattering;\\n\\tlet absorption_extinction = absorption_density * atmosphere.absorption_extinction;\\n\\n\\treturn mie_extinction + rayleigh_extinction + absorption_extinction;\\n}\\n\\nfn sample_medium(height: f32, atmosphere: Atmosphere) -> MediumSample {\\n\\tlet mie_density: f32 = exp(atmosphere.mie_density_exp_scale * height);\\n\\tlet rayleigh_density: f32 = exp(atmosphere.rayleigh_density_exp_scale * height);\\n\\tvar absorption_density: f32;\\n\\tif height < atmosphere.absorption_density_0_layer_height {\\n\\t\\tabsorption_density = saturate(atmosphere.absorption_density_0_linear_term * height + atmosphere.absorption_density_0_constant_term);\\n\\t} else {\\n\\t\\tabsorption_density = saturate(atmosphere.absorption_density_1_linear_term * height + atmosphere.absorption_density_1_constant_term);\\n\\t}\\n\\n\\tvar s: MediumSample;\\n\\ts.mie_scattering = mie_density * atmosphere.mie_scattering;\\n\\ts.rayleigh_scattering = rayleigh_density * atmosphere.rayleigh_scattering;\\n\\ts.scattering = s.mie_scattering + s.rayleigh_scattering;\\n\\n\\tlet mie_extinction = mie_density * atmosphere.mie_extinction;\\n\\tlet rayleigh_extinction = s.rayleigh_scattering;\\n\\tlet absorption_extinction = absorption_density * atmosphere.absorption_extinction;\\n\\ts.extinction = mie_extinction + rayleigh_extinction + absorption_extinction;\\n\\n\\treturn s;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride MULTI_SCATTERING_LUT_RES_X: f32 = 32.0;\\noverride MULTI_SCATTERING_LUT_RES_Y: f32 = MULTI_SCATTERING_LUT_RES_X;\\n\\nfn get_multiple_scattering(atmosphere: Atmosphere, scattering: vec3<f32>, extinction: vec3<f32>, worl_pos: vec3<f32>, cos_view_zenith: f32) -> vec3<f32> {\\n\\tvar uv = saturate(vec2(cos_view_zenith * 0.5 + 0.5, (length(worl_pos) - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius)));\\n\\tuv = vec2(from_unit_to_sub_uvs(uv.x, MULTI_SCATTERING_LUT_RES_X), from_unit_to_sub_uvs(uv.y, MULTI_SCATTERING_LUT_RES_Y));\\n\\treturn textureSampleLevel(multi_scattering_lut, lut_sampler, uv, 0).rgb;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride MIE_USE_HG_DRAINE: bool = false;\\noverride MIE_USE_HG_DRAINE_DYNAMIC: bool = false;\\n\\n// https://research.nvidia.com/labs/rtr/approximate-mie/publications/approximate-mie.pdf\\n// cloud water droplet diameter in µm (should be 5 µm < d < 50 µm)\\noverride HG_DRAINE_DROPLET_DIAMETER: f32 = 3.4;\\n// include hg_draine_size\\n// include hg_draine_const\\n\\nconst one_over_four_pi = 1.0 / (2.0 * tau);\\n\\nconst isotropic_phase: f32 = 1.0 / sphere_solid_angle;\\n\\nfn draine_phase_dynamic(alpha: f32, g: f32, cos_theta: f32) -> f32 {\\n    let g2 = g * g;\\n   return one_over_four_pi *\\n          ((1.0 - g2) / pow((1.0 + g2 - (2.0 * g * cos_theta)), 1.5)) *\\n          ((1.0 + (alpha * cos_theta * cos_theta)) / (1.0 + (alpha * (1.0 / 3.0) * (1.0 + (2.0 * g2)))));\\n}\\n\\nfn hg_draine_phase_dynamic(cos_theta: f32, g_hg: f32, g_d: f32, alpha: f32, w_d: f32) -> f32 {\\n    return mix(draine_phase_dynamic(0, g_hg, cos_theta), draine_phase_dynamic(alpha, g_d, cos_theta), w_d);\\n}\\n\\nfn hg_draine_phase_dynamic_dispatch(cos_theta: f32, diameter: f32) -> f32 {\\n    if diameter >= 5.0 {\\n        return hg_draine_phase_dynamic(\\n            cos_theta,\\n            exp(-(0.0990567 / (diameter - 1.67154))),\\n            exp(-(2.20679 / (diameter + 3.91029)) - 0.428934),\\n            exp(3.62489 - (8.29288 / (diameter + 5.52825))),\\n            exp(-(0.599085 / (diameter - 0.641583)) - 0.665888),\\n        );\\n    } else if diameter >= 1.5 {\\n        return hg_draine_phase_dynamic(\\n            cos_theta,\\n            0.0604931 * log(log(diameter)) + 0.940256,\\n            0.500411 - 0.081287 / (-2.0 * log(diameter) + tan(log(diameter)) + 1.27551),\\n            7.30354 * log(diameter) + 6.31675,\\n            0.026914 * (log(diameter) - cos(5.68947 * (log(log(diameter)) - 0.0292149))) + 0.376475,\\n        );\\n    } else if diameter > 0.1 {\\n        return hg_draine_phase_dynamic(\\n            cos_theta,\\n            0.862 - 0.143 * log(diameter) * log(diameter),\\n            0.379685 * cos(1.19692 * cos(((log(diameter) - 0.238604) * (log(diameter) + 1.00667)) / (0.507522 - 0.15677 * log(diameter))) + 1.37932 * log(diameter) + 0.0625835) + 0.344213,\\n            250.0,\\n            0.146209 * cos(3.38707 * log(diameter) + 2.11193) + 0.316072 + 0.0778917 * log(diameter),\\n        );\\n    } else {\\n        return hg_draine_phase_dynamic(\\n            cos_theta,\\n            13.8 * diameter * diameter,\\n            1.1456 * diameter * sin(9.29044 * diameter),\\n            250.0,\\n            0.252977 - pow(312.983 * diameter, 4.3),\\n        );\\n    }\\n}\\n\\nfn cornette_shanks_phase(cos_theta: f32, g: f32) -> f32 {\\n\\tlet k: f32 = 3.0 / (8.0 * pi) * (1.0 - g * g) / (2.0 + g * g);\\n\\treturn k * (1.0 + cos_theta * cos_theta) / pow(1.0 + g * g - 2.0 * g * -cos_theta, 1.5);\\n}\\n\\nfn mie_phase(cos_theta: f32, g_or_d: f32) -> f32 {\\n    if MIE_USE_HG_DRAINE {\\n        if MIE_USE_HG_DRAINE_DYNAMIC {\\n            return hg_draine_phase_dynamic_dispatch(cos_theta, g_or_d);\\n        } else {\\n            return hg_draine_phase(cos_theta);\\n        }\\n    } else {\\n        return cornette_shanks_phase(-cos_theta, g_or_d);\\n    }\\n}\\n\\nfn rayleigh_phase(cos_theta: f32) -> f32 {\\n\\tlet factor: f32 = 3.0f / (16.0f * pi);\\n\\treturn factor * (1.0f + cos_theta * cos_theta);\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride RANDOMIZE_SAMPLE_OFFSET: bool = true;\\n\\nfn pcg_hash(seed: u32) -> u32 {\\n\\tlet state = seed * 747796405u + 2891336453u;\\n\\tlet word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\\n\\treturn (word >> 22u) ^ word;\\n}\\n\\nfn pcg_hashf(seed: u32) -> f32 {\\n\\treturn f32(pcg_hash(seed)) / 4294967296.0;\\n}\\n\\nfn pcg_hash3(x: u32, y: u32, z: u32) -> f32 {\\n\\treturn pcg_hashf((x * 1664525 + y) + z);\\n}\\n\\nfn get_sample_segment_t(uv: vec2<f32>, config: Uniforms) -> f32 {\\n\\tif RANDOMIZE_SAMPLE_OFFSET {\\n\\t\\tlet seed = vec3<u32>(\\n\\t\\t\\tu32(uv.x * config.screen_resolution.x),\\n\\t\\t\\tu32(uv.y * config.screen_resolution.y),\\n\\t\\t\\tpcg_hash(u32(config.frame_id)),\\n\\t\\t);\\n\\t\\treturn pcg_hash3(seed.x, seed.y, seed.z);\\n\\t} else {\\n\\t\\treturn 0.3;\\n\\t}\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\nfn get_sample_shadow(atmosphere: Atmosphere, sample_position: vec3<f32>, light_index: u32) -> f32 {\\n\\treturn get_shadow((sample_position + atmosphere.planet_center) * FROM_KM_SCALE, light_index);\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n \\noverride SKY_VIEW_LUT_RES_X: f32 = 192.0;\\noverride SKY_VIEW_LUT_RES_Y: f32 = 108.0;\\n\\nfn sky_view_lut_params_to_uv(atmosphere: Atmosphere, intersects_ground: bool, cos_view_zenith: f32, cos_light_view: f32, view_height: f32) -> vec2<f32> {\\n\\tlet v_horizon = sqrt(max(view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius, 0.0));\\n\\tlet ground_to_horizon = acos(v_horizon / view_height);\\n\\tlet zenith_horizon_angle = pi - ground_to_horizon;\\n\\n\\tvar uv = vec2<f32>();\\n\\tif !intersects_ground {\\n\\t\\tlet coord = 1.0 - sqrt(max(1.0 - acos(cos_view_zenith) / zenith_horizon_angle, 0.0));\\n\\t\\tuv.y = coord * 0.5;\\n\\t} else {\\n\\t\\tlet coord = (acos(cos_view_zenith) - zenith_horizon_angle) / ground_to_horizon;\\n\\t\\tuv.y = sqrt(max(coord, 0.0)) * 0.5 + 0.5;\\n\\t}\\n\\tuv.x = sqrt(-cos_light_view * 0.5 + 0.5);\\n\\n\\treturn vec2(from_unit_to_sub_uvs(uv.x, SKY_VIEW_LUT_RES_X), from_unit_to_sub_uvs(uv.y, SKY_VIEW_LUT_RES_Y));\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride RENDER_SUN_DISK: bool = true;\\noverride RENDER_MOON_DISK: bool = true;\\noverride LIMB_DARKENING_ON_SUN: bool = true;\\noverride LIMB_DARKENING_ON_MOON: bool = false;\\n\\nfn limb_darkeining_factor(center_to_edge: f32) -> vec3<f32> {\\n\\tlet u = vec3<f32>(1.0);\\n\\tlet a = vec3<f32>(0.397 , 0.503 , 0.652);\\n\\tlet inv_center_to_edge = 1.0 - center_to_edge;\\n\\tlet mu = sqrt(max(1.0 - inv_center_to_edge * inv_center_to_edge, 0.0));\\n\\treturn 1.0 - u * (1.0 - pow(vec3<f32>(mu), a));\\n}\\n\\nfn sun_disk_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, light: AtmosphereLight, apply_limb_darkening: bool) -> vec3<f32> {\\n\\tlet cos_view_sun = dot(world_dir, light.direction);\\n\\tlet cos_disk_radius = cos(0.5 * light.disk_diameter);\\n\\t\\n\\tif cos_view_sun <= cos_disk_radius || ray_intersects_sphere(world_pos, world_dir, vec3<f32>(), atmosphere.bottom_radius) {\\n\\t\\treturn vec3<f32>();\\n\\t}\\n\\n\\tlet disk_solid_angle = tau * cos_disk_radius;\\n\\tlet l_outer_space = (light.illuminance / disk_solid_angle) * light.disk_luminance_scale;\\n\\n\\tlet height = length(world_pos);\\n\\tlet zenith = world_pos / height;\\n\\tlet cos_view_zenith = dot(world_dir, zenith);\\n\\tlet uv = transmittance_lut_params_to_uv(atmosphere, height, cos_view_zenith);\\n\\tlet transmittance_sun = textureSampleLevel(transmittance_lut, lut_sampler, uv, 0).rgb;\\n\\n\\tif apply_limb_darkening {\\n\\t\\tlet center_to_edge = 1.0 - ((2.0 * acos(cos_view_sun)) / light.disk_diameter);\\n\\t\\treturn transmittance_sun * l_outer_space * limb_darkeining_factor(center_to_edge);\\n\\t} else {\\n\\t\\treturn transmittance_sun * l_outer_space;\\n\\t}\\n}\\n\\nfn get_sun_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, uniforms: Uniforms) -> vec3<f32> {\\n\\tvar sun_luminance = vec3<f32>();\\n\\tif RENDER_SUN_DISK {\\n\\t\\tsun_luminance += sun_disk_luminance(world_pos, world_dir, atmosphere, uniforms.sun, LIMB_DARKENING_ON_SUN);\\n\\t}\\n\\tif RENDER_MOON_DISK && USE_MOON {\\n\\t\\tsun_luminance += sun_disk_luminance(world_pos, world_dir, atmosphere, uniforms.moon, LIMB_DARKENING_ON_MOON);\\n\\t}\\n\\treturn sun_luminance;\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\nstruct AtmosphereLight {\\n\\t// Sun light's illuminance\\n\\tilluminance: vec3<f32>,\\n\\t\\n\\t// Sun disk's angular diameter in radians\\n\\tdisk_diameter: f32,\\n\\t\\n\\t// Sun light's direction (direction pointing to the sun)\\n\\tdirection: vec3<f32>,\\n\\n\\t// Sun disk's luminance\\n\\tdisk_luminance_scale: f32,\\n}\\n\\nstruct Uniforms {\\n\\t// Inverse projection matrix for the current camera view\\n\\tinverse_projection: mat4x4<f32>,\\n\\n\\t// Inverse view matrix for the current camera view\\n\\tinverse_view: mat4x4<f32>,\\n\\n\\t// World position of the current camera view\\n\\tcamera_world_position: vec3<f32>,\\n\\n\\t// Resolution of the multiscattering LUT (width = height)\\n\\tframe_id: f32,\\n\\n\\t// Resolution of the output texture\\n\\tscreen_resolution: vec2<f32>,\\n\\n\\t// Minimum number of ray marching samples per pixel\\n\\tray_march_min_spp: f32,\\n\\n\\t// Maximum number of ray marching samples per pixel\\n\\tray_march_max_spp: f32,\\n\\n\\t// Sun parameters\\n\\tsun: AtmosphereLight,\\n\\n\\t// Moon / second sun parameters \\n\\tmoon: AtmosphereLight,\\n}\\n\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\nfn from_sub_uvs_to_unit(u: f32, resolution: f32) -> f32 {\\n\\treturn (u - 0.5 / resolution) * (resolution / (resolution - 1.0));\\n}\\n\\nfn from_unit_to_sub_uvs(u: f32, resolution: f32) -> f32 {\\n\\treturn (u + 0.5 / resolution) * (resolution / (resolution + 1.0));\\n}\\n\\nfn transmittance_lut_params_to_uv(atmosphere: Atmosphere, view_height: f32, cos_view_zenith: f32) -> vec2<f32> {\\n\\tlet height_sq = view_height * view_height;\\n\\tlet bottom_radius_sq = atmosphere.bottom_radius * atmosphere.bottom_radius;\\n\\tlet top_radius_sq = atmosphere.top_radius * atmosphere.top_radius;\\n\\tlet h = sqrt(max(0.0, top_radius_sq - bottom_radius_sq));\\n\\tlet rho = sqrt(max(0.0, height_sq - bottom_radius_sq));\\n\\n\\tlet discriminant = height_sq * (cos_view_zenith * cos_view_zenith - 1.0) + top_radius_sq;\\n\\tlet distance_to_boundary = max(0.0, (-view_height * cos_view_zenith + sqrt(max(discriminant, 0.0))));\\n\\n\\tlet min_distance = atmosphere.top_radius - view_height;\\n\\tlet max_distance = rho + h;\\n\\tlet x_mu = (distance_to_boundary - min_distance) / (max_distance - min_distance);\\n\\tlet x_r = rho / h;\\n\\n\\treturn vec2<f32>(x_mu, x_r);\\n}\\n\";","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport aerialPerspectiveWgsl from './shaders/common/aerial_perspective.wgsl';\nimport blendWgsl from './shaders/common/blend.wgsl';\nimport constantsWgsl from './shaders/common/constants.wgsl';\nimport customUniformsWgsl from './shaders/common/custom_uniforms.wgsl';\nimport coordinateSystemWgsl from './shaders/common/coordinate_system.wgsl';\nimport fullScreenVertexShaderWgsl from './shaders/common/vertex_full_screen.wgsl';\nimport hgDraineConstWgsl from './shaders/common/hg_draine_phase_const.wgsl';\nimport hgDraineLargeWgsl from './shaders/common/hg_draine_large.wgsl';\nimport hgDraineMid2Wgsl from './shaders/common/hg_draine_mid2.wgsl';\nimport hgDraineMid1Wgsl from './shaders/common/hg_draine_mid1.wgsl';\nimport hgDraineSmallWgsl from './shaders/common/hg_draine_small.wgsl';\nimport intersectionWgsl from './shaders/common/intersection.wgsl';\nimport mediumWgsl from './shaders/common/medium.wgsl';\nimport multipleScatteringWgsl from './shaders/common/multiple_scattering.wgsl';\nimport phaseWgsl from './shaders/common/phase.wgsl';\nimport sampleSegmentWgsl from './shaders/common/sample_sagment_t.wgsl';\nimport shadowBaseWgsl from './shaders/common/shadow_base.wgsl';\nimport skyViewWgsl from './shaders/common/sky_view.wgsl';\nimport sunDiskWgsl from './shaders/common/sun_disk.wgsl';\nimport uniformsWgsl from './shaders/common/uniforms.wgsl';\nimport uvWgsl from './shaders/common/uv.wgsl';\n\nimport renderTransmittanceLutWgsl from './shaders/render_transmittance_lut.wgsl';\nimport renderMultiScatteringLutWgsl from './shaders/render_multi_scattering_lut.wgsl';\nimport renderSkyViewLutWgsl from './shaders/render_sky_view_lut.wgsl';\nimport renderAerialPerspectiveWgsl from './shaders/render_aerial_perspective_lut.wgsl';\n\nimport renderSkyWithLutsWgsl from './shaders/render_sky_with_luts.wgsl';\nimport renderSkyRaymarchingWgsl from './shaders/render_sky_raymarching.wgsl';\nimport renderSkyLutAndRaymarchingWgsl from './shaders/render_sky_luts_and_raymarch.wgsl';\n\nfunction makePhaseShaderCode(constDropletDiameter?: number): string {\n    const base = phaseWgsl.replace('// include hg_draine_const', hgDraineConstWgsl);\n    if (!constDropletDiameter || constDropletDiameter >= 5.0) {\n        return base.replace('// include hg_draine_size', hgDraineLargeWgsl);\n    } else if (constDropletDiameter >= 1.5) {\n        return base.replace('// include hg_draine_size', hgDraineMid2Wgsl);\n    } else if (constDropletDiameter > 0.1) {\n        return base.replace('// include hg_draine_size', hgDraineMid1Wgsl);\n    } else {\n        return base.replace('// include hg_draine_size', hgDraineSmallWgsl);\n    }\n}\n\nexport function makeTransmittanceLutShaderCode(transmittanceLutFormat: GPUTextureFormat = 'rgba16float') {\n    return `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${renderTransmittanceLutWgsl}`.replace('rgba16float', transmittanceLutFormat);\n}\n\nexport function makeMultiScatteringLutShaderCode(multiScatteringLutFormat: GPUTextureFormat = 'rgba16float') {\n    return `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${makePhaseShaderCode()}\\n${uvWgsl}\\n${renderMultiScatteringLutWgsl}`.replace('rgba16float', multiScatteringLutFormat);\n}\n\nfunction makeShadowShaderCode(shadow?: string): string {\n    return `${shadow ?? 'fn get_shadow(p: vec3<f32>, i: u32) -> f32 { return 1.0; }'}\\n${shadowBaseWgsl}`;\n}\n\nexport function makeSkyViewLutShaderCode(skyViewLutFormat: GPUTextureFormat = 'rgba16float', shadow?: string, customUniforms?: string, constDropletDiameter?: number): string {\n    const base = `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${makePhaseShaderCode(constDropletDiameter)}\\n${uvWgsl}\\n${uniformsWgsl}\\n${customUniforms ? `${customUniforms}\\n${customUniformsWgsl}\\n` : ''}${coordinateSystemWgsl}\\n${multipleScatteringWgsl}\\n`;\n    let shader = renderSkyViewLutWgsl.replace('rgba16float', skyViewLutFormat);\n    if (customUniforms) {\n        shader = shader.replace('let config = config_buffer', 'let config = get_uniforms()');\n        shader = shader.replace('@group(0) @binding(1) var<uniform> config_buffer: Uniforms;', '');\n        for (let i = 2; i < 6; ++i) {\n            shader = shader.replace(`group(0) @binding(${i})`, `group(0) @binding(${i - 1})`);\n        }\n    }\n    return `${makeShadowShaderCode(shadow)}\\n${base}\\n${shader}`;\n}\n\nexport function makeAerialPerspectiveLutShaderCode(aerialPerspectiveLutFormat: GPUTextureFormat = 'rgba16float', shadow?: string, customUniforms?: string, constDropletDiameter?: number) {\n    const base = `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${makePhaseShaderCode(constDropletDiameter)}\\n${uvWgsl}\\n${uniformsWgsl}\\n${customUniforms ? `${customUniforms}\\n${customUniformsWgsl}\\n` : ''}${coordinateSystemWgsl}\\n${multipleScatteringWgsl}\\n${aerialPerspectiveWgsl}\\n${sampleSegmentWgsl}\\n`;\n    let shader = renderAerialPerspectiveWgsl.replace('rgba16float', aerialPerspectiveLutFormat);\n    if (customUniforms) {\n        shader = shader.replace('let config = config_buffer', 'let config = get_uniforms()');\n        shader = shader.replace('@group(0) @binding(1) var<uniform> config_buffer: Uniforms;', '');\n        for (let i = 2; i < 6; ++i) {\n            shader = shader.replace(`group(0) @binding(${i})`, `group(0) @binding(${i - 1})`);\n        }\n    }\n    return `${makeShadowShaderCode(shadow)}\\n${base}\\n${shader}`;\n}\n\nexport function makeRenderSkyWithLutsShaderCode(renderTargetFormat: GPUTextureFormat = 'rgba16float', customUniforms?: string) {\n    const base = `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${uvWgsl}\\n${uniformsWgsl}\\n${customUniforms ? `${customUniforms}\\n${customUniformsWgsl}\\n` : ''}${coordinateSystemWgsl}\\n${aerialPerspectiveWgsl}\\n${skyViewWgsl}\\n${blendWgsl}\\n${sunDiskWgsl}\\n${fullScreenVertexShaderWgsl}\\n${sampleSegmentWgsl}\\n`;\n    let shader = renderSkyWithLutsWgsl.replace('rgba16float', renderTargetFormat);\n    if (customUniforms) {\n        shader = shader.replace('let config = config_buffer', 'let config = get_uniforms()');\n        shader = shader.replace('@group(0) @binding(1) var<uniform> config_buffer: Uniforms;', '');\n        for (let i = 2; i < 9; ++i) {\n            shader = shader.replace(`group(0) @binding(${i})`, `group(0) @binding(${i - 1})`);\n        }\n    }\n    return `${base}\\n${shader}`;\n}\n\nexport function makeRenderSkyRaymarchingShaderCode(renderTargetFormat: GPUTextureFormat = 'rgba16float', shadow?: string, customUniforms?: string, constDropletDiameter?: number) {\n    const base = `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${makePhaseShaderCode(constDropletDiameter)}\\n${uvWgsl}\\n${uniformsWgsl}\\n${customUniforms ? `${customUniforms}\\n${customUniformsWgsl}\\n` : ''}${coordinateSystemWgsl}\\n${multipleScatteringWgsl}\\n${blendWgsl}\\n${sunDiskWgsl}\\n${fullScreenVertexShaderWgsl}\\n${sampleSegmentWgsl}\\n`;\n    let shader = renderSkyRaymarchingWgsl.replace('rgba16float', renderTargetFormat);\n    if (customUniforms) {\n        shader = shader.replace('let config = config_buffer', 'let config = get_uniforms()');\n        shader = shader.replace('@group(0) @binding(1) var<uniform> config_buffer: Uniforms;', '');\n        for (let i = 2; i < 9; ++i) {\n            shader = shader.replace(`group(0) @binding(${i})`, `group(0) @binding(${i - 1})`);\n        }\n    }\n    return `${makeShadowShaderCode(shadow)}\\n${base}\\n${shader}`;\n}\n\nexport function makeRenderSkyLutAndRaymarchingShaderCode(renderTargetFormat: GPUTextureFormat = 'rgba16float', shadow?: string, customUniforms?: string, constDropletDiameter?: number) {\n    const base = `${constantsWgsl}\\n${intersectionWgsl}\\n${mediumWgsl}\\n${makePhaseShaderCode(constDropletDiameter)}\\n${uvWgsl}\\n${uniformsWgsl}\\n${customUniforms ? `${customUniforms}\\n${customUniformsWgsl}\\n` : ''}${coordinateSystemWgsl}\\n${multipleScatteringWgsl}\\n${skyViewWgsl}\\n${blendWgsl}\\n${sunDiskWgsl}\\n${fullScreenVertexShaderWgsl}\\n${sampleSegmentWgsl}\\n`;\n    let shader = renderSkyLutAndRaymarchingWgsl.replace('rgba16float', renderTargetFormat);\n    if (customUniforms) {\n        shader = shader.replace('let config = config_buffer', 'let config = get_uniforms()');\n        shader = shader.replace('@group(0) @binding(1) var<uniform> config_buffer: Uniforms;', '');\n        for (let i = 2; i < 9; ++i) {\n            shader = shader.replace(`group(0) @binding(${i})`, `group(0) @binding(${i - 1})`);\n        }\n    }\n    return `${makeShadowShaderCode(shadow)}\\n${base}\\n${shader}`;\n}","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride SKY_VIEW_LUT_RES_X: f32 = 192.0;\\noverride SKY_VIEW_LUT_RES_Y: f32 = 108.0;\\n\\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\\n\\noverride USE_MOON: bool = false;\\n\\noverride WORKGROUP_SIZE_X: u32 = 16;\\noverride WORKGROUP_SIZE_Y: u32 = 16;\\n\\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\\n@group(0) @binding(2) var lut_sampler: sampler;\\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\\n@group(0) @binding(5) var sky_view_lut : texture_storage_2d<rgba16float, write>;\\n\\nstruct SingleScatteringResult {\\n\\tluminance: vec3<f32>,\\t\\t\\t\\t// Scattered light (luminance)\\n\\ttransmittance: vec3<f32>,\\t\\t\\t// transmittance in [0,1] (unitless)\\n}\\n\\nfn integrate_scattered_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, moon_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> SingleScatteringResult {\\n\\tvar result = SingleScatteringResult();\\n\\t\\n\\tlet planet_center = vec3<f32>();\\n\\tvar t_max: f32 = 0.0;\\n\\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\\n\\t\\treturn result;\\n\\t}\\n\\tt_max = min(t_max, t_max_max);\\n\\n\\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\\n\\tlet sample_count_floored = floor(sample_count);\\n\\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\\n\\tlet t_max_floored = t_max * sample_count_floored / sample_count;\\n\\tlet sample_segment_t = 0.3;\\n\\n\\tlet sun_direction = normalize(sun_dir);\\n\\tlet sun_illuminance = config.sun.illuminance;\\n\\n\\tlet cos_theta = dot(sun_dir, world_dir);\\n\\tlet mie_phase_val = mie_phase(cos_theta, atmosphere.mie_phase_param);\\n\\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\\n\\t\\n\\tvar moon_direction = moon_dir;\\n\\tvar moon_illuminance = config.moon.illuminance;\\n\\n\\tvar cos_theta_moon = 0.0;\\n\\tvar mie_phase_val_moon = 0.0;\\n\\tvar rayleigh_phase_val_moon = 0.0;\\n\\n\\tif USE_MOON {\\n\\t\\tmoon_direction = normalize(moon_direction);\\n\\t\\tmoon_illuminance = config.moon.illuminance;\\n\\n\\t\\tcos_theta_moon = dot(moon_direction, world_dir);\\n\\t\\tmie_phase_val_moon = mie_phase(cos_theta_moon, atmosphere.mie_phase_param);\\n\\t\\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\\n\\t}\\n\\n\\tresult.luminance = vec3(0.0);\\n\\tresult.transmittance = vec3(1.0);\\n\\tvar t = 0.0;\\n\\tvar dt = t_max / sample_count;\\n\\tfor (var s = 0.0; s < sample_count; s += 1.0) {\\n\\t\\tvar t0 = s * inv_sample_count_floored;\\n\\t\\tvar t1 = (s + 1.0) * inv_sample_count_floored;\\n\\t\\tt0 = (t0 * t0) * t_max_floored;\\n\\t\\tt1 = t1 * t1;\\n\\t\\tif t1 > 1.0 {\\n\\t\\t\\tt1 = t_max;\\n\\t\\t} else {\\n\\t\\t\\tt1 = t_max_floored * t1;\\n\\t\\t}\\n\\t\\tdt = t1 - t0;\\n\\t\\tt = t0 + dt * sample_segment_t;\\n\\n\\t\\tlet sample_pos = world_pos + t * world_dir;\\n\\t\\tlet sample_height = length(sample_pos);\\n\\n\\t\\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\\n\\t\\tlet sample_transmittance = exp(-medium.extinction * dt);\\n\\n\\t\\tlet zenith = sample_pos / sample_height;\\n \\n\\t\\tlet cos_sun_zenith = dot(sun_direction, zenith);\\n\\t\\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\\n\\t\\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\\n\\t\\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\\n\\t\\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\\n\\n\\t\\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\\n\\n\\t\\tif USE_MOON {\\n\\t\\t\\tlet cos_moon_zenith = dot(moon_direction, zenith);\\n\\t\\t\\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\\n\\t\\t\\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\\n\\t\\t\\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\\n\\t\\t\\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\t\\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\\n\\n\\t\\t\\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\\n\\t\\t}\\n\\n\\t\\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\\n\\t\\tresult.luminance += result.transmittance * intergrated_luminance;\\n\\t\\tresult.transmittance *= sample_transmittance;\\n\\t}\\n\\t\\n\\treturn result;\\n}\\n\\nfn compute_sun_dir(sun_dir: vec3<f32>, zenith: vec3<f32>) -> vec3<f32> {\\n\\tlet cos_sun_zenith = dot(zenith, sun_dir);\\n\\treturn normalize(vec3(sqrt(max(1.0 - cos_sun_zenith * cos_sun_zenith, 0.0)), 0.0, cos_sun_zenith));\\n}\\n\\nfn compute_world_dir(uv_in: vec2<f32>, sky_view_res: vec2<f32>, view_height: f32, atmosphere: Atmosphere) -> vec3<f32> {\\n\\tlet uv = vec2(from_sub_uvs_to_unit(uv_in.x, sky_view_res.x), from_sub_uvs_to_unit(uv_in.y, sky_view_res.y));\\n\\n\\tlet v_horizon = sqrt(max(view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius, 0.0));\\n\\tlet ground_to_horizon_angle = acos(v_horizon / view_height);\\n\\tlet zenith_horizon_angle = pi - ground_to_horizon_angle;\\n\\n\\tvar cos_view_zenith: f32;\\n\\tif uv.y < 0.5 {\\n\\t\\tlet coord = 1.0 - (2.0 * uv.y);\\n\\t\\tcos_view_zenith = cos(zenith_horizon_angle * (1.0 - (coord * coord)));\\n\\t} else {\\n\\t\\tlet coord = (uv.y * 2.0) - 1.0;\\n\\t\\tcos_view_zenith = cos(zenith_horizon_angle + ground_to_horizon_angle * (coord * coord));\\n\\t}\\n\\tlet cos_light_view = -((uv.x * uv.x) * 2.0 - 1.0);\\n\\tlet sin_view_zenith = sqrt(max(1.0 - cos_view_zenith * cos_view_zenith, 0.0));\\n\\n\\treturn vec3(\\n\\t\\tsin_view_zenith * cos_light_view,\\n\\t\\tsin_view_zenith * sqrt(max(1.0 - cos_light_view * cos_light_view, 0.0)),\\n\\t\\tcos_view_zenith\\n\\t);\\n}\\n\\n@compute\\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn render_sky_view_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n\\tlet output_size = vec2<u32>(textureDimensions(sky_view_lut));\\n\\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\\n\\t\\treturn;\\n\\t}\\n\\n\\tlet sky_view_lut_res = vec2<f32>(SKY_VIEW_LUT_RES_X, SKY_VIEW_LUT_RES_Y); // vec2<f32>(output_size); <- tex dimensions produce artefacts!\\n\\n\\tlet pix = vec2<f32>(global_id.xy) + 0.5;\\n\\tlet uv = pix / sky_view_lut_res;\\n\\n\\tlet atmosphere = atmosphere_buffer;\\n\\tlet config = config_buffer;\\n\\n\\tlet view_world_pos = (config.camera_world_position * TO_KM_SCALE) - atmosphere.planet_center;\\n\\tlet world_sun_dir = normalize(config.sun.direction);\\n\\tlet world_moon_dir = normalize(config.moon.direction);\\n\\n\\tlet view_height = length(view_world_pos);\\n\\n\\tlet zenith = view_world_pos / view_height;\\n\\tlet sun_dir = compute_sun_dir(world_sun_dir, zenith);\\n\\tlet moon_dir = compute_sun_dir(world_moon_dir, zenith);\\n\\n\\tvar world_pos = vec3<f32>(0.0, 0.0, view_height);\\n\\tlet world_dir = compute_world_dir(uv, sky_view_lut_res, view_height, atmosphere);\\n\\n\\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\\n\\t\\ttextureStore(sky_view_lut, global_id.xy, vec4<f32>(0, 0, 0, 1));\\n\\t\\treturn;\\n\\t}\\n\\n\\tlet ss = integrate_scattered_luminance(world_pos, world_dir, sun_dir, moon_dir, atmosphere, config);\\n\\n\\ttextureStore(sky_view_lut, global_id.xy, vec4<f32>(ss.luminance, 1.0 - dot(ss.transmittance, vec3(1.0 / 3.0))));\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride USE_MOON: bool = false;\\n\\noverride WORKGROUP_SIZE_X: u32 = 16;\\noverride WORKGROUP_SIZE_Y: u32 = 16;\\n\\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\\n@group(0) @binding(2) var lut_sampler: sampler;\\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\\n@group(0) @binding(5) var aerial_perspective_lut: texture_storage_3d<rgba16float, write>;\\n\\nstruct SingleScatteringResult {\\n\\tluminance: vec3<f32>,\\t\\t\\t\\t// Scattered light (luminance)\\n\\ttransmittance: vec3<f32>,\\t\\t\\t// Transmittance in [0,1] (unitless)\\n}\\n\\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms, sample_count: f32, t_max_bound: f32) -> SingleScatteringResult {\\n\\tvar result = SingleScatteringResult();\\n\\n\\tlet planet_center = vec3<f32>();\\n\\tvar t_max: f32 = 0.0;\\n\\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\\n\\t\\treturn result;\\n\\t}\\n\\tt_max = min(t_max, t_max_bound);\\n\\n\\tlet sample_segment_t = get_sample_segment_t(uv, config);\\n\\tlet dt = t_max / sample_count;\\n\\n\\tlet sun_direction = normalize(config.sun.direction);\\n\\tlet sun_illuminance = config.sun.illuminance;\\n\\n\\tlet cos_theta = dot(sun_direction, world_dir);\\n\\tlet mie_phase_val = mie_phase(cos_theta, atmosphere.mie_phase_param);\\n\\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\\n\\n\\tvar moon_direction = config.moon.direction;\\n\\tvar moon_illuminance = config.moon.illuminance;\\n\\n\\tvar cos_theta_moon = 0.0;\\n\\tvar mie_phase_val_moon = 0.0;\\n\\tvar rayleigh_phase_val_moon = 0.0;\\n\\n\\tif USE_MOON {\\n\\t\\tmoon_direction = normalize(moon_direction);\\n\\t\\tmoon_illuminance = config.moon.illuminance;\\n\\n\\t\\tcos_theta_moon = dot(moon_direction, world_dir);\\n\\t\\tmie_phase_val_moon = mie_phase(cos_theta_moon, atmosphere.mie_phase_param);\\n\\t\\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\\n\\t}\\n\\n\\tresult.luminance = vec3(0.0);\\n\\tresult.transmittance = vec3(1.0);\\n\\tvar t = 0.0;\\n\\tvar dt_exact = 0.0;\\n\\tfor (var s = 0.0; s < sample_count; s += 1.0) {\\n\\t\\tlet t_new = (s + sample_segment_t) * dt;\\n\\t\\tdt_exact = t_new - t;\\n\\t\\tt = t_new;\\n\\n\\t\\tlet sample_pos = world_pos + t * world_dir;\\n\\t\\tlet sample_height = length(sample_pos);\\n\\n\\t\\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\\n\\t\\tlet sample_transmittance = exp(-medium.extinction * dt_exact);\\n\\n\\t\\tlet zenith = sample_pos / sample_height;\\n\\n\\t\\tlet cos_sun_zenith = dot(sun_direction, zenith);\\n\\t\\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\\n\\t\\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\\n\\t\\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\\n\\t\\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\\n\\n\\t\\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\\n\\n\\t\\tif USE_MOON {\\n\\t\\t\\tlet cos_moon_zenith = dot(moon_direction, zenith);\\n\\t\\t\\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\\n\\t\\t\\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\\n\\t\\t\\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\\n\\t\\t\\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\t\\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\\n\\n\\t\\t\\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\\n\\t\\t}\\n\\n\\t\\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\\n\\t\\tresult.luminance += result.transmittance * intergrated_luminance;\\n\\t\\tresult.transmittance *= sample_transmittance;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nfn thread_z_to_slice(thread_z: u32) -> f32 {\\n\\tlet slice = ((f32(thread_z) + 0.5) / AP_SLICE_COUNT);\\n\\treturn (slice * slice) * AP_SLICE_COUNT; // squared distribution\\n}\\n\\n@compute\\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn render_aerial_perspective_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n\\tlet output_size = vec2<u32>(textureDimensions(aerial_perspective_lut).xy);\\n\\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\\n\\t\\treturn;\\n\\t}\\n\\n\\tlet atmosphere = atmosphere_buffer;\\n\\tlet config = config_buffer;\\n\\n\\tlet pix = vec2<f32>(global_id.xy) + 0.5;\\n\\tlet uv = pix / vec2<f32>(output_size.xy);\\n\\n\\tvar world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\\n\\tlet cam_pos = (config.camera_world_position * TO_KM_SCALE) - atmosphere.planet_center;\\n\\n\\tvar world_pos = cam_pos;\\n\\n\\tvar t_max = aerial_perspective_slice_to_depth(thread_z_to_slice(global_id.z));\\n\\tvar slice_start_pos = world_pos + t_max * world_dir;\\n\\n\\tvar view_height = length(slice_start_pos);\\n\\tif view_height <= (atmosphere.bottom_radius + planet_radius_offset) {\\n\\t\\tslice_start_pos = normalize(slice_start_pos) * (atmosphere.bottom_radius + planet_radius_offset + 0.001);\\n\\t\\tworld_dir = normalize(slice_start_pos - cam_pos);\\n\\t\\tt_max = length(slice_start_pos - cam_pos);\\n\\t}\\n\\n\\tview_height = length(world_pos);\\n\\tif view_height >= atmosphere.top_radius {\\n\\t\\tlet prev_world_pos = world_pos;\\n\\t\\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\\n\\t\\t\\ttextureStore(aerial_perspective_lut, global_id, vec4(0.0, 0.0, 0.0, 1.0));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tlet distance_to_atmosphere = length(prev_world_pos - world_pos);\\n\\t\\tif t_max < distance_to_atmosphere {\\n\\t\\t\\ttextureStore(aerial_perspective_lut, global_id, vec4(0.0, 0.0, 0.0, 1.0));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tt_max = max(0.0, t_max - distance_to_atmosphere);\\n\\t}\\n\\n\\tlet sample_count = max(1.0, f32(global_id.z + 1) * 2.0);\\n\\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, config, sample_count, t_max);\\n\\n\\tlet transmittance = dot(ss.transmittance, vec3(1.0 / 3.0));\\n\\ttextureStore(aerial_perspective_lut, global_id, vec4(ss.luminance, 1.0 - transmittance));\\n}\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride USE_MOON: bool = false;\\n\\noverride WORKGROUP_SIZE_X: u32 = 16;\\noverride WORKGROUP_SIZE_Y: u32 = 16;\\n\\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\\n@group(0) @binding(2) var lut_sampler: sampler;\\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\\n@group(0) @binding(4) var sky_view_lut: texture_2d<f32>;\\n@group(0) @binding(5) var aerial_perspective_lut : texture_3d<f32>;\\n@group(0) @binding(6) var depth_buffer: texture_2d<f32>;\\n@group(0) @binding(7) var backbuffer: texture_2d<f32>;\\n@group(0) @binding(8) var render_target: texture_storage_2d<rgba16float, write>;\\n\\nfn use_sky_view_lut(view_height: f32, world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> vec4<f32> {\\n\\tlet zenith = normalize(world_pos);\\n\\tlet cos_view_zenith = dot(world_dir, zenith);\\n\\n\\tlet side = normalize(cross(zenith, world_dir));\\t// assumes non parallel vectors\\n\\tlet forward = normalize(cross(side, zenith));\\t// aligns toward the sun light but perpendicular to up vector\\n\\tlet cos_light_view = normalize(vec2(dot(sun_dir, forward), dot(sun_dir, side))).x;\\n\\n\\tlet intersects_ground = ray_intersects_sphere(world_pos, world_dir, vec3(), atmosphere.bottom_radius);\\n\\n\\tlet uv = sky_view_lut_params_to_uv(atmosphere, intersects_ground, cos_view_zenith, cos_light_view, view_height);\\n\\n\\tlet sky_view = textureSampleLevel(sky_view_lut, lut_sampler, uv, 0);\\n\\n\\treturn vec4(sky_view.rgb + get_sun_luminance(world_pos, world_dir, atmosphere, config), sky_view.a);\\n}\\n\\nfn render_sky(pix: vec2<u32>) -> vec4<f32> {\\n\\tlet atmosphere = atmosphere_buffer;\\n\\tlet config = config_buffer;\\n\\n\\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\\n\\n\\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\\n\\tvar world_pos = (config.camera_world_position * TO_KM_SCALE) - atmosphere.planet_center;\\n\\tlet sun_dir = normalize(config.sun.direction);\\n\\n\\tlet view_height = length(world_pos);\\n\\t\\n\\tlet depth = textureLoad(depth_buffer, pix, 0).r;\\n\\tif !is_valid_depth(depth) {\\n\\t\\treturn use_sky_view_lut(view_height, world_pos, world_dir, sun_dir, atmosphere, config);\\n\\t}\\n\\n\\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\\n\\tlet t_depth = length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center));\\n\\n\\tvar slice = aerial_perspective_depth_to_slice(t_depth);\\n\\tvar weight = 1.0;\\n\\tif slice < 0.5 {\\n\\t\\t// We multiply by weight to fade to 0 at depth 0. That works for luminance and opacity.\\n\\t\\tweight = saturate(slice * 2.0);\\n\\t\\tslice = 0.5;\\n\\t}\\n\\tlet w = sqrt(slice / AP_SLICE_COUNT);\\t// squared distribution\\n\\n\\tlet aerial_perspective = textureSampleLevel(aerial_perspective_lut, lut_sampler, vec3<f32>(uv, w), 0);\\n\\n\\tif all(aerial_perspective.rgb == vec3())  {\\n\\t\\treturn vec4();\\n\\t}\\n\\n\\treturn weight * aerial_perspective;\\n}\\n\\nstruct RenderSkyFragment {\\n\\t@location(0) luminance: vec4<f32>,\\n\\t@location(1) transmittance: vec4<f32>,\\n}\\n\\n@fragment\\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\\n\\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\\n\\treturn RenderSkyFragment(vec4(result.rgb, 1.0), vec4(vec3(result.a), 1.0));\\n}\\n\\n@compute\\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n\\tlet output_size = vec2<u32>(textureDimensions(render_target));\\n\\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\\n\\t\\treturn;\\n\\t}\\n\\tblend(global_id.xy, render_sky(global_id.xy));\\n}\\n\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride USE_MOON: bool = false;\\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\\noverride USE_COLORED_TRANSMISSION: bool = true;\\n\\noverride WORKGROUP_SIZE_X: u32 = 16;\\noverride WORKGROUP_SIZE_Y: u32 = 16;\\n\\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\\n@group(0) @binding(2) var lut_sampler: sampler;\\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\\n@group(0) @binding(5) var depth_buffer: texture_2d<f32>;\\n@group(0) @binding(6) var backbuffer: texture_2d<f32>;\\n@group(0) @binding(7) var render_target: texture_storage_2d<rgba16float, write>;\\n\\nstruct SingleScatteringResult {\\n\\tluminance: vec3<f32>,\\t\\t\\t\\t// Scattered light (luminance)\\n\\ttransmittance: vec3<f32>,\\t\\t\\t// transmittance in [0,1] (unitless)\\n}\\n\\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, depth: f32, config: Uniforms) -> SingleScatteringResult {\\n\\tvar result = SingleScatteringResult();\\n\\n\\tlet planet_center = vec3<f32>();\\n\\tvar t_max: f32 = 0.0;\\n\\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tif is_valid_depth(depth) {\\n\\t\\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\\n\\t\\tt_max = min(t_max, length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center)));\\n\\t}\\n\\tt_max = min(t_max, t_max_max);\\n\\n\\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\\n\\tlet sample_count_floored = floor(sample_count);\\n\\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\\n\\tlet t_max_floored = t_max * sample_count_floored / sample_count;\\n\\tlet sample_segment_t = get_sample_segment_t(uv, config);\\n\\n\\tlet sun_direction = normalize(config.sun.direction);\\n\\tlet sun_illuminance = config.sun.illuminance;\\n\\n\\tlet cos_theta = dot(sun_direction, world_dir);\\n\\tlet mie_phase_val = mie_phase(cos_theta, atmosphere.mie_phase_param);\\n\\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\\n\\n\\tvar moon_direction = config.moon.direction;\\n\\tvar moon_illuminance = config.moon.illuminance;\\n\\n\\tvar cos_theta_moon = 0.0;\\n\\tvar mie_phase_val_moon = 0.0;\\n\\tvar rayleigh_phase_val_moon = 0.0;\\n\\n\\tif USE_MOON {\\n\\t\\tmoon_direction = normalize(moon_direction);\\n\\t\\tmoon_illuminance = config.moon.illuminance;\\n\\n\\t\\tcos_theta_moon = dot(moon_direction, world_dir);\\n\\t\\tmie_phase_val_moon = mie_phase(cos_theta_moon, atmosphere.mie_phase_param);\\n\\t\\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\\n\\t}\\n\\n\\tresult.luminance = vec3(0.0);\\n\\tresult.transmittance = vec3(1.0);\\n\\tvar t = 0.0;\\n\\tvar dt = 0.0;\\n\\tfor (var s = 0.0; s < sample_count; s += 1.0) {\\n\\t\\tvar t0 = s * inv_sample_count_floored;\\n\\t\\tvar t1 = (s + 1.0) * inv_sample_count_floored;\\n\\t\\tt0 = (t0 * t0) * t_max_floored;\\n\\t\\tt1 = t1 * t1;\\n\\t\\tif t1 > 1.0 {\\n\\t\\t\\tt1 = t_max;\\n\\t\\t} else {\\n\\t\\t\\tt1 = t_max_floored * t1;\\n\\t\\t}\\n\\t\\tdt = t1 - t0;\\n\\t\\tt = t0 + dt * sample_segment_t;\\n\\n\\t\\tlet sample_pos = world_pos + t * world_dir;\\n\\t\\tlet sample_height= length(sample_pos);\\n\\n\\t\\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\\n\\t\\tlet sample_transmittance = exp(-medium.extinction * dt);\\n\\n\\t\\tlet zenith = sample_pos / sample_height;\\n \\n\\t\\tlet cos_sun_zenith = dot(sun_direction, zenith);\\n\\t\\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\\n\\t\\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\\n\\t\\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\\n\\t\\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\\n\\n\\t\\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\\n\\n\\t\\tif USE_MOON {\\n\\t\\t\\tlet cos_moon_zenith = dot(moon_direction, zenith);\\n\\t\\t\\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\\n\\t\\t\\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\\n\\t\\t\\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\\n\\t\\t\\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\t\\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\\n\\n\\t\\t\\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\\n\\t\\t}\\n\\n\\t\\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\\n\\t\\tresult.luminance += result.transmittance * intergrated_luminance;\\n\\t\\tresult.transmittance *= sample_transmittance;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nstruct RenderSkyResult {\\n\\tluminance: vec4<f32>,\\n\\ttransmittance: vec4<f32>,\\n}\\n\\nfn render_sky(pix: vec2<u32>) -> RenderSkyResult {\\n\\tlet atmosphere = atmosphere_buffer;\\n\\tlet config = config_buffer;\\n\\n\\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\\n\\n\\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\\n\\tvar world_pos = (config.camera_world_position * TO_KM_SCALE) - atmosphere.planet_center;\\n\\tlet sun_dir = normalize(config.sun.direction);\\n\\n\\tlet view_height = length(world_pos);\\n\\t\\n\\tvar luminance = vec3<f32>();\\n\\t\\n\\tlet depth = textureLoad(depth_buffer, pix, 0).r;\\n\\tif !is_valid_depth(depth) {\\n\\t\\tluminance += get_sun_luminance(world_pos, world_dir, atmosphere, config);\\n\\t}\\n\\n\\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\\n\\t\\tluminance = get_sun_luminance(world_pos, world_dir, atmosphere, config);\\n\\t\\treturn RenderSkyResult(max(vec4(luminance, 1.0), vec4()), max(vec4(0.0, 0.0, 0.0, 1.0), vec4()));\\n\\t}\\n\\t\\n\\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, depth, config);\\n\\tluminance += ss.luminance;\\n\\n\\treturn RenderSkyResult(max(vec4(luminance, 1.0), vec4()), max(vec4(ss.transmittance, 1.0), vec4()));\\n}\\n\\nstruct RenderSkyFragment {\\n\\t@location(0) luminance: vec4<f32>,\\n\\t@location(1) transmittance: vec4<f32>,\\n}\\n\\n@fragment\\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\\n\\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\\n\\treturn RenderSkyFragment(result.luminance, result.transmittance);\\n}\\n\\n@compute\\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y)\\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n\\tlet output_size = vec2<u32>(textureDimensions(render_target));\\n\\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\\n\\t\\treturn;\\n\\t}\\n\\tlet result = render_sky(global_id.xy);\\n\\tif USE_COLORED_TRANSMISSION {\\n\\t\\tdual_source_blend(global_id.xy, result.luminance, result.transmittance);\\n\\t} else {\\n\\t\\tblend(global_id.xy, vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))));\\n\\t}\\n}\\n\\n\";","export default \"/*\\n * Copyright (c) 2024 Lukas Herzberger\\n * Copyright (c) 2020 Epic Games, Inc.\\n * SPDX-License-Identifier: MIT\\n */\\n\\noverride USE_MOON: bool = false;\\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\\noverride USE_COLORED_TRANSMISSION: bool = true;\\n\\noverride WORKGROUP_SIZE_X: u32 = 16;\\noverride WORKGROUP_SIZE_Y: u32 = 16;\\n\\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\\n@group(0) @binding(2) var lut_sampler: sampler;\\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\\n@group(0) @binding(5) var sky_view_lut: texture_2d<f32>;\\n@group(0) @binding(6) var depth_buffer: texture_2d<f32>;\\n@group(0) @binding(7) var backbuffer: texture_2d<f32>;\\n@group(0) @binding(8) var render_target: texture_storage_2d<rgba16float, write>;\\n\\nfn use_sky_view_lut(view_height: f32, world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> vec4<f32> {\\n\\tlet zenith = normalize(world_pos);\\n\\tlet cos_view_zenith = dot(world_dir, zenith);\\n\\n\\tlet side = normalize(cross(zenith, world_dir));\\t// assumes non parallel vectors\\n\\tlet forward = normalize(cross(side, zenith));\\t// aligns toward the sun light but perpendicular to up vector\\n\\tlet cos_light_view = normalize(vec2(dot(sun_dir, forward), dot(sun_dir, side))).x;\\n\\n\\tlet intersects_ground = ray_intersects_sphere(world_pos, world_dir, vec3(), atmosphere.bottom_radius);\\n\\n\\tlet uv = sky_view_lut_params_to_uv(atmosphere, intersects_ground, cos_view_zenith, cos_light_view, view_height);\\n\\n\\tlet sky_view = textureSampleLevel(sky_view_lut, lut_sampler, uv, 0);\\n\\n\\treturn vec4(sky_view.rgb + get_sun_luminance(world_pos, world_dir, atmosphere, config), sky_view.a);\\n}\\n\\nstruct SingleScatteringResult {\\n\\tluminance: vec3<f32>,\\t\\t\\t\\t// Scattered light (luminance)\\n\\ttransmittance: vec3<f32>,\\t\\t\\t// transmittance in [0,1] (unitless)\\n}\\n\\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, depth: f32, config: Uniforms) -> SingleScatteringResult {\\n\\tvar result = SingleScatteringResult();\\n\\n\\tlet planet_center = vec3<f32>();\\n\\tvar t_max: f32 = 0.0;\\n\\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tif is_valid_depth(depth) {\\n\\t\\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\\n\\t\\tt_max = min(t_max, length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center)));\\n\\t}\\n\\tt_max = min(t_max, t_max_max);\\n\\n\\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\\n\\tlet sample_count_floored = floor(sample_count);\\n\\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\\n\\tlet t_max_floored = t_max * sample_count_floored / sample_count;\\n\\tlet sample_segment_t = get_sample_segment_t(uv, config);\\n\\n\\tlet sun_direction = normalize(config.sun.direction);\\n\\tlet sun_illuminance = config.sun.illuminance;\\n\\n\\tlet cos_theta = dot(sun_direction, world_dir);\\n\\tlet mie_phase_val = mie_phase(cos_theta, atmosphere.mie_phase_param);\\n\\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\\n\\n\\tvar moon_direction = config.moon.direction;\\n\\tvar moon_illuminance = config.moon.illuminance;\\n\\n\\tvar cos_theta_moon = 0.0;\\n\\tvar mie_phase_val_moon = 0.0;\\n\\tvar rayleigh_phase_val_moon = 0.0;\\n\\n\\tif USE_MOON {\\n\\t\\tmoon_direction = normalize(moon_direction);\\n\\t\\tmoon_illuminance = config.moon.illuminance;\\n\\n\\t\\tcos_theta_moon = dot(moon_direction, world_dir);\\n\\t\\tmie_phase_val_moon = mie_phase(cos_theta_moon, atmosphere.mie_phase_param);\\n\\t\\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\\n\\t}\\n\\n\\tresult.luminance = vec3(0.0);\\n\\tresult.transmittance = vec3(1.0);\\n\\tvar t = 0.0;\\n\\tvar dt = 0.0;\\n\\tfor (var s = 0.0; s < sample_count; s += 1.0) {\\n\\t\\tvar t0 = s * inv_sample_count_floored;\\n\\t\\tvar t1 = (s + 1.0) * inv_sample_count_floored;\\n\\t\\tt0 = (t0 * t0) * t_max_floored;\\n\\t\\tt1 = t1 * t1;\\n\\t\\tif t1 > 1.0 {\\n\\t\\t\\tt1 = t_max;\\n\\t\\t} else {\\n\\t\\t\\tt1 = t_max_floored * t1;\\n\\t\\t}\\n\\t\\tdt = t1 - t0;\\n\\t\\tt = t0 + dt * sample_segment_t;\\n\\n\\t\\tlet sample_pos = world_pos + t * world_dir;\\n\\t\\tlet sample_height= length(sample_pos);\\n\\n\\t\\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\\n\\t\\tlet sample_transmittance = exp(-medium.extinction * dt);\\n\\n\\t\\tlet zenith = sample_pos / sample_height;\\n \\n\\t\\tlet cos_sun_zenith = dot(sun_direction, zenith);\\n\\t\\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\\n\\t\\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\\n\\t\\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\\n\\t\\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\\n\\n\\t\\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\\n\\n\\t\\tif USE_MOON {\\n\\t\\t\\tlet cos_moon_zenith = dot(moon_direction, zenith);\\n\\t\\t\\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\\n\\t\\t\\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\\n\\t\\t\\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\\n\\t\\t\\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\\n\\t\\t\\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\\n\\n\\t\\t\\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\\n\\t\\t}\\n\\n\\t\\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\\n\\t\\tresult.luminance += result.transmittance * intergrated_luminance;\\n\\t\\tresult.transmittance *= sample_transmittance;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nstruct RenderSkyResult {\\n\\tluminance: vec4<f32>,\\n\\ttransmittance: vec4<f32>,\\n}\\n\\nfn render_sky(pix: vec2<u32>) -> RenderSkyResult {\\n\\tlet atmosphere = atmosphere_buffer;\\n\\tlet config = config_buffer;\\n\\n\\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\\n\\n\\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\\n\\tvar world_pos = (config.camera_world_position * TO_KM_SCALE)- atmosphere.planet_center;\\n\\tlet sun_dir = normalize(config.sun.direction);\\n\\n\\tlet view_height = length(world_pos);\\n\\n\\tlet depth = textureLoad(depth_buffer, pix, 0).r;\\n\\tif !is_valid_depth(depth) {\\n\\t\\tlet sky_view = use_sky_view_lut(view_height, world_pos, world_dir, sun_dir, atmosphere, config);\\n\\t\\treturn RenderSkyResult(vec4<f32>(sky_view.rgb, 1.0), vec4<f32>(vec3<f32>(sky_view.a), 1.0));\\n\\t}\\n\\t\\n\\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\\n\\t\\tlet black = vec4(vec3(), 1.0);\\n\\t\\treturn RenderSkyResult(black, black);\\n\\t}\\n\\t\\n\\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, depth, config);\\n\\n\\treturn RenderSkyResult(max(vec4(ss.luminance, 1.0), vec4()), max(vec4(ss.transmittance, 1.0), vec4()));\\n}\\n\\nstruct RenderSkyFragment {\\n\\t@location(0) luminance: vec4<f32>,\\n\\t@location(1) transmittance: vec4<f32>,\\n}\\n\\n@fragment\\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\\n\\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\\n\\treturn RenderSkyFragment(result.luminance, result.transmittance);\\n}\\n\\n@compute\\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y)\\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n\\tlet output_size = vec2<u32>(textureDimensions(render_target));\\n\\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\\n\\t\\treturn;\\n\\t}\\n\\tlet result = render_sky(global_id.xy);\\n\\tif USE_COLORED_TRANSMISSION {\\n\\t\\tdual_source_blend(global_id.xy, result.luminance, result.transmittance);\\n\\t} else {\\n\\t\\tblend(global_id.xy, vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))));\\n\\t}\\n}\\n\\n\";","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { SkyAtmosphereRendererConfig, ShadowConfig, CustomUniformsSourceConfig, MieHgDPhaseConfig } from './config.js';\nimport { AERIAL_PERSPECTIVE_LUT_FORMAT, ATMOSPHERE_BUFFER_SIZE, UNIFORMS_BUFFER_SIZE, DEFAULT_AERIAL_PERSPECTIVE_LUT_SIZE, DEFAULT_MULTISCATTERING_LUT_SIZE, DEFAULT_SKY_VIEW_LUT_SIZE, MULTI_SCATTERING_LUT_FORMAT, SKY_VIEW_LUT_FORMAT, SkyAtmosphereResources, TRANSMITTANCE_LUT_FORMAT } from './resources.js';\nimport { makeAerialPerspectiveLutShaderCode, makeMultiScatteringLutShaderCode, makeSkyViewLutShaderCode, makeTransmittanceLutShaderCode } from './shaders.js';\nimport { ComputePass } from './util.js';\n\nexport const DEFAULT_TRANSMITTANCE_LUT_SAMPLE_COUNT: number = 40;\nexport const DEFAULT_MULTI_SCATTERING_LUT_SAMPLE_COUNT: number = 20;\nexport const MULTI_SCATTERING_LUT_MIN_SAMPLE_COUNT: number = 10;\n\nexport class TransmittanceLutPipeline {\n    private constructor(\n        readonly device: GPUDevice,\n        readonly pipeline: GPUComputePipeline,\n        readonly bindGroupLayout: GPUBindGroupLayout,\n        readonly transmittanceLutFormat: GPUTextureFormat,\n    ) {}\n\n    private static makeBindGroupLayout(device: GPUDevice, transmittanceLutFormat: GPUTextureFormat): GPUBindGroupLayout {\n        return device.createBindGroupLayout({\n            label: 'transmittance LUT pass',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: ATMOSPHERE_BUFFER_SIZE,\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        access: 'write-only',\n                        format: transmittanceLutFormat,\n                        viewDimension: '2d',\n                    },\n                },\n            ],\n        });\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, bindGroupLayout: GPUBindGroupLayout, transmittanceLutFormat: GPUTextureFormat, sampleCount: number): GPUComputePipelineDescriptor {\n        return {\n            label: 'transmittance LUT pass',\n            layout: device.createPipelineLayout({\n                label: 'transmittance LUT pass',\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: makeTransmittanceLutShaderCode(transmittanceLutFormat),\n                }),\n                entryPoint: 'render_transmittance_lut',\n                constants: {\n                    SAMPLE_COUNT: Math.max(sampleCount, DEFAULT_TRANSMITTANCE_LUT_SAMPLE_COUNT),\n                },\n            },\n        };\n    }\n\n    static async createAsync(device: GPUDevice, transmittanceLutFormat: GPUTextureFormat, sampleCount: number): Promise<TransmittanceLutPipeline> {\n        const bindGroupLayout = this.makeBindGroupLayout(device, transmittanceLutFormat);\n        const pipeline = await device.createComputePipelineAsync(this.makePipelineDescriptor(device, bindGroupLayout, transmittanceLutFormat, sampleCount));\n        return new TransmittanceLutPipeline(device, pipeline, bindGroupLayout, transmittanceLutFormat);\n    }\n\n    static create(device: GPUDevice, transmittanceLutFormat: GPUTextureFormat, sampleCount: number) {\n        const bindGroupLayout = this.makeBindGroupLayout(device, transmittanceLutFormat);\n        const pipeline = device.createComputePipeline(this.makePipelineDescriptor(device, bindGroupLayout, transmittanceLutFormat, sampleCount));\n        return new TransmittanceLutPipeline(device, pipeline, bindGroupLayout, transmittanceLutFormat);\n    }\n\n    public makeComputePass(resources: SkyAtmosphereResources): ComputePass {\n        if (this.device !== resources.device) {\n            throw new Error(`[TransmittanceLutPipeline::makeComputePass]: device mismatch`);\n        }\n        if (resources.atmosphereBuffer.size < ATMOSPHERE_BUFFER_SIZE) {\n            throw new Error(`[TransmittanceLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.transmittanceLut.texture.format !== this.transmittanceLutFormat) {\n            throw new Error(`[TransmittanceLutPipeline::makeComputePass]: wrong texture format for transmittance LUT. expected '${this.transmittanceLutFormat}', got ${resources.transmittanceLut.texture.format}`);\n        }\n        const bindGroup = resources.device.createBindGroup({\n            label: `transmittance LUT pass [${resources.label}]`,\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: resources.atmosphereBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: resources.transmittanceLut.view,\n                },\n            ],\n        });\n        return new ComputePass(\n            this.pipeline,\n            [bindGroup],\n            [Math.ceil(resources.transmittanceLut.texture.width / 16.0), Math.ceil(resources.transmittanceLut.texture.height / 16.0), 1],\n        );\n    }\n}\n\nexport class MultiScatteringLutPipeline {\n    private constructor(\n        readonly device: GPUDevice,\n        readonly pipeline: GPUComputePipeline,\n        readonly bindGroupLayout: GPUBindGroupLayout,\n        readonly multiScatteringLutFormat: GPUTextureFormat,\n    ) {}\n\n    private static makeBindGroupLayout(device: GPUDevice, multiScatteringLutFormat: GPUTextureFormat): GPUBindGroupLayout {\n        return device.createBindGroupLayout({\n            label: 'mulitple scattering LUT pass',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: ATMOSPHERE_BUFFER_SIZE,\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    sampler: {\n                        type: 'filtering',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        sampleType: 'float',\n                        viewDimension: '2d',\n                        multisampled: false,\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        access: 'write-only',\n                        format: multiScatteringLutFormat,\n                        viewDimension: '2d',\n                    },\n                },\n            ],\n        });\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, bindGroupLayout: GPUBindGroupLayout, multiScatteringLutFormat: GPUTextureFormat, sampleCount: number): GPUComputePipelineDescriptor {\n        return {\n            label: 'mulitple scattering LUT pass',\n            layout: device.createPipelineLayout({\n                label: 'mulitple scattering LUT pass',\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: makeMultiScatteringLutShaderCode(multiScatteringLutFormat),\n                }),\n                entryPoint: 'render_multi_scattering_lut',\n                constants: {\n                    SAMPLE_COUNT: Math.max(sampleCount, MULTI_SCATTERING_LUT_MIN_SAMPLE_COUNT),\n                },\n            },\n        };\n    }\n\n    static async createAsync(device: GPUDevice, multiScatteringLutFormat: GPUTextureFormat, sampleCount: number): Promise<MultiScatteringLutPipeline> {\n        const bindGroupLayout = this.makeBindGroupLayout(device, multiScatteringLutFormat);\n        const pipeline = await device.createComputePipelineAsync(this.makePipelineDescriptor(device, bindGroupLayout, multiScatteringLutFormat, sampleCount));\n        return new MultiScatteringLutPipeline(device, pipeline, bindGroupLayout, multiScatteringLutFormat);\n    }\n\n    static create(device: GPUDevice, multiScatteringLutFormat: GPUTextureFormat, sampleCount: number): MultiScatteringLutPipeline {\n        const bindGroupLayout = this.makeBindGroupLayout(device, multiScatteringLutFormat);\n        const pipeline = device.createComputePipeline(this.makePipelineDescriptor(device, bindGroupLayout, multiScatteringLutFormat, sampleCount));\n        return new MultiScatteringLutPipeline(device, pipeline, bindGroupLayout, multiScatteringLutFormat);\n    }\n\n    public makeComputePass(resources: SkyAtmosphereResources): ComputePass {\n        if (this.device !== resources.device) {\n            throw new Error(`[MultiScatteringLutPipeline::makeComputePass]: device mismatch`);\n        }\n        if (resources.atmosphereBuffer.size < ATMOSPHERE_BUFFER_SIZE) {\n            throw new Error(`[MultiScatteringLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.multiScatteringLut.texture.format !== this.multiScatteringLutFormat) {\n            throw new Error(`[MultiScatteringLutPipeline::makeComputePass]: wrong texture format for multiple scattering LUT. expected '${this.multiScatteringLutFormat}', got ${resources.multiScatteringLut.texture.format}`);\n        }\n        const bindGroup = resources.device.createBindGroup({\n            label: `mulitple scattering LUT pass [${resources.label}]`,\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: resources.atmosphereBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: resources.lutSampler,\n                },\n                {\n                    binding: 2,\n                    resource: resources.transmittanceLut.view,\n                },\n                {\n                    binding: 3,\n                    resource: resources.multiScatteringLut.view,\n                },\n            ],\n        });\n        return new ComputePass(\n            this.pipeline,\n            [bindGroup],\n            [resources.multiScatteringLut.texture.width, resources.multiScatteringLut.texture.height, 1],\n        );\n    }\n}\n\nexport function makeMiePhaseOverrides(miePhaseConfig?: MieHgDPhaseConfig): Record<string, GPUPipelineConstantValue> {\n    if (!miePhaseConfig) {\n        return {};\n    } else {\n        const mieOverrides: Record<string, GPUPipelineConstantValue> = {\n            MIE_USE_HG_DRAINE: Number(true),\n        };\n        if (!(miePhaseConfig.useConstantDropletDiameter ?? true)) {\n            mieOverrides['MIE_USE_HG_DRAINE_DYNAMIC'] = Number(true);\n        } else if (miePhaseConfig.constantDropletDiameter) {\n            mieOverrides['HG_DRAINE_DROPLET_DIAMETER'] = miePhaseConfig.constantDropletDiameter;\n        }\n        return mieOverrides;\n    }\n}\n\nexport class SkyViewLutPipeline {\n    private constructor(\n        readonly device: GPUDevice,\n        readonly pipeline: GPUComputePipeline,\n        readonly bindGroupLayout: GPUBindGroupLayout,\n        readonly skyViewLutFormat: GPUTextureFormat,\n        readonly skyViewLutSize: [number, number],\n        readonly multiscatteringLutSize: [number, number],\n    ) {}\n\n    private static makeBindGroupLayout(device: GPUDevice, skyViewLutFormat: GPUTextureFormat, customUniformsConfig?: CustomUniformsSourceConfig): GPUBindGroupLayout {\n        return device.createBindGroupLayout({\n            label: 'sky view LUT pass',\n            entries: ([\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: ATMOSPHERE_BUFFER_SIZE,\n                    },\n                },\n                customUniformsConfig ? undefined : {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: UNIFORMS_BUFFER_SIZE,\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    sampler: {\n                        type: 'filtering',\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        sampleType: 'float',\n                        viewDimension: '2d',\n                        multisampled: false,\n                    },\n                },\n                {\n                    binding: 4,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        sampleType: 'float',\n                        viewDimension: '2d',\n                        multisampled: false,\n                    },\n                },\n                {\n                    binding: 5,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        access: 'write-only',\n                        format: skyViewLutFormat,\n                        viewDimension: '2d',\n                    },\n                },\n            ].filter(e => e !== undefined) as GPUBindGroupLayoutEntry[])\n            .map((e, i) => {\n                e.binding = i;\n                return e;\n            }) as GPUBindGroupLayoutEntry[],\n        });\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, bindGroupLayout: GPUBindGroupLayout, skyViewLutFormat: GPUTextureFormat, skyViewLutSize: [number, number], multiscatteringLutSize: [number, number], distanceToMaxSampleCount: number, fromKilometersScaleFactor: number, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): GPUComputePipelineDescriptor {\n        return {\n            label: 'sky view LUT pass',\n            layout: device.createPipelineLayout({\n                label: 'sky view LUT pass',\n                bindGroupLayouts: [bindGroupLayout, ...(shadowConfig?.bindGroupLayouts ?? []), ...(customUniformsConfig?.bindGroupLayouts ?? [])],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    label: 'sky view LUT',\n                    code: makeSkyViewLutShaderCode(skyViewLutFormat, shadowConfig?.wgslCode, customUniformsConfig?.wgslCode, miePhaseConfig?.constantDropletDiameter),\n                }),\n                entryPoint: 'render_sky_view_lut',\n                constants: {\n                    SKY_VIEW_LUT_RES_X: skyViewLutSize[0],\n                    SKY_VIEW_LUT_RES_Y: skyViewLutSize[1],\n                    INV_DISTANCE_TO_MAX_SAMPLE_COUNT: 1.0 / distanceToMaxSampleCount,\n                    MULTI_SCATTERING_LUT_RES_X: multiscatteringLutSize[0],\n                    MULTI_SCATTERING_LUT_RES_Y: multiscatteringLutSize[1],\n                    FROM_KM_SCALE: fromKilometersScaleFactor,\n                    USE_MOON: Number(useMoon),\n                    ...makeMiePhaseOverrides(miePhaseConfig),\n                },\n            },\n        };\n    }\n\n    static async createAsync(device: GPUDevice, skyViewLutFormat: GPUTextureFormat, skyViewLutSize: [number, number], multiscatteringLutSize: [number, number], distanceToMaxSampleCount: number, fromKilometersScaleFactor: number, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): Promise<SkyViewLutPipeline> {\n        const bindGroupLayout = this.makeBindGroupLayout(device, skyViewLutFormat, customUniformsConfig);\n        const pipeline = await device.createComputePipelineAsync(this.makePipelineDescriptor(device, bindGroupLayout, skyViewLutFormat, skyViewLutSize, multiscatteringLutSize, distanceToMaxSampleCount, fromKilometersScaleFactor, useMoon, shadowConfig, customUniformsConfig, miePhaseConfig));\n        return new SkyViewLutPipeline(device, pipeline, bindGroupLayout, skyViewLutFormat, skyViewLutSize, multiscatteringLutSize);\n    }\n\n    static create(device: GPUDevice, skyViewLutFormat: GPUTextureFormat, skyViewLutSize: [number, number], multiscatteringLutSize: [number, number], distanceToMaxSampleCount: number, fromKilometersScaleFactor: number, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): SkyViewLutPipeline {\n        const bindGroupLayout = this.makeBindGroupLayout(device, skyViewLutFormat, customUniformsConfig);\n        const pipeline = device.createComputePipeline(this.makePipelineDescriptor(device, bindGroupLayout, skyViewLutFormat, skyViewLutSize, multiscatteringLutSize, distanceToMaxSampleCount, fromKilometersScaleFactor, useMoon, shadowConfig, customUniformsConfig, miePhaseConfig));\n        return new SkyViewLutPipeline(device, pipeline, bindGroupLayout, skyViewLutFormat, skyViewLutSize, multiscatteringLutSize);\n    }\n\n    public makeComputePass(resources: SkyAtmosphereResources, shadowBindGroups?: GPUBindGroup[], customUniformsBindGroups?: GPUBindGroup[]): ComputePass {\n        if (this.device !== resources.device) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: device mismatch`);\n        }\n        if (resources.atmosphereBuffer.size < ATMOSPHERE_BUFFER_SIZE) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.uniformsBuffer && resources.uniformsBuffer.size < UNIFORMS_BUFFER_SIZE) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: buffer too small for config (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.multiScatteringLut.texture.width !== this.multiscatteringLutSize[0] || resources.multiScatteringLut.texture.height !== this.multiscatteringLutSize[1]) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture size for multiple scattering LUT. expected '${this.multiscatteringLutSize}', got ${[resources.multiScatteringLut.texture.width, resources.multiScatteringLut.texture.height]}`);\n        }\n        if (resources.skyViewLut.texture.format !== this.skyViewLutFormat) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture format for sky view LUT. expected '${this.skyViewLutFormat}', got ${resources.skyViewLut.texture.format}`);\n        }\n        if (resources.skyViewLut.texture.width !== this.skyViewLutSize[0] || resources.skyViewLut.texture.height !== this.skyViewLutSize[1]) {\n            throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture size for sky view LUT. expected '${this.skyViewLutSize}', got ${[resources.skyViewLut.texture.width, resources.skyViewLut.texture.height]}`);\n        }\n        const bindGroup = resources.device.createBindGroup({\n            label: `sky view LUT pass [${resources.label}]`,\n            layout: this.bindGroupLayout,\n            entries: ([\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: resources.atmosphereBuffer,\n                    },\n                },\n                customUniformsBindGroups ? undefined : {\n                    binding: 1,\n                    resource: {\n                        buffer: resources.uniformsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: resources.lutSampler,\n                },\n                {\n                    binding: 3,\n                    resource: resources.transmittanceLut.view,\n                },\n                {\n                    binding: 4,\n                    resource: resources.multiScatteringLut.view,\n                },\n                {\n                    binding: 5,\n                    resource: resources.skyViewLut.view,\n                },\n            ].filter(e => e !== undefined) as GPUBindGroupEntry[])\n            .map((e, i) => {\n                e.binding = i;\n                return e;\n            }) as GPUBindGroupEntry[],\n        });\n        return new ComputePass(\n            this.pipeline,\n            [bindGroup, ...(shadowBindGroups ?? []), ...(customUniformsBindGroups ?? [])],\n            [Math.ceil(resources.skyViewLut.texture.width / 16.0), Math.ceil(resources.skyViewLut.texture.height / 16.0), 1],\n        );\n    }\n}\n\nexport class AerialPerspectiveLutPipeline {\n    private constructor(\n        readonly device: GPUDevice,\n        readonly pipeline: GPUComputePipeline,\n        readonly bindGroupLayout: GPUBindGroupLayout,\n        readonly aerialPerspectiveLutFormat: GPUTextureFormat,\n        readonly aerialPerspectiveSliceCount: number,\n        readonly aerialPerspectiveDistancePerSlice: number,\n        readonly multiscatteringLutSize: [number, number],\n    ) {}\n\n    private static makeBindGroupLayout(device: GPUDevice, aerialPerspectiveLutFormat: GPUTextureFormat, customUniformsConfig?: CustomUniformsSourceConfig): GPUBindGroupLayout {\n        return device.createBindGroupLayout({\n            label: 'aerial perspective LUT pass',\n            entries: ([\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: ATMOSPHERE_BUFFER_SIZE,\n                    },\n                },\n                customUniformsConfig ? undefined : {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                        hasDynamicOffset: false,\n                        minBindingSize: UNIFORMS_BUFFER_SIZE,\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    sampler: {\n                        type: 'filtering',\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        sampleType: 'float',\n                        viewDimension: '2d',\n                        multisampled: false,\n                    },\n                },\n                {\n                    binding: 4,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        sampleType: 'float',\n                        viewDimension: '2d',\n                        multisampled: false,\n                    },\n                },\n                {\n                    binding: 5,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        access: 'write-only',\n                        format: aerialPerspectiveLutFormat,\n                        viewDimension: '3d',\n                    },\n                },\n            ].filter(e => e !== undefined) as GPUBindGroupLayoutEntry[])\n            .map((e, i) => {\n                e.binding = i;\n                return e;\n            }) as GPUBindGroupLayoutEntry[],\n        });\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, bindGroupLayout: GPUBindGroupLayout, aerialPerspectiveLutFormat: GPUTextureFormat, aerialPerspectiveSliceCount: number, aerialPerspectiveDistancePerSlice: number, multiscatteringLutSize: [number, number], fromKilometersScaleFactor: number, randomizeSampleOffsets: boolean, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): GPUComputePipelineDescriptor {\n        return {\n            label: 'aerial perspective LUT pass',\n            layout: device.createPipelineLayout({\n                label: 'aerial perspective LUT pass',\n                bindGroupLayouts: [bindGroupLayout, ...(shadowConfig?.bindGroupLayouts ?? []), ...(customUniformsConfig?.bindGroupLayouts ?? [])],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    label: 'aerial perspective LUT',\n                    code: makeAerialPerspectiveLutShaderCode(aerialPerspectiveLutFormat, shadowConfig?.wgslCode, customUniformsConfig?.wgslCode, miePhaseConfig?.constantDropletDiameter),\n                }),\n                entryPoint: 'render_aerial_perspective_lut',\n                constants: {\n                    AP_SLICE_COUNT: aerialPerspectiveSliceCount,\n                    AP_DISTANCE_PER_SLICE: aerialPerspectiveDistancePerSlice,\n                    MULTI_SCATTERING_LUT_RES_X: multiscatteringLutSize[0],\n                    MULTI_SCATTERING_LUT_RES_Y: multiscatteringLutSize[1],\n                    FROM_KM_SCALE: fromKilometersScaleFactor,\n                    RANDOMIZE_SAMPLE_OFFSET: Number(randomizeSampleOffsets),\n                    USE_MOON: Number(useMoon),\n                    ...makeMiePhaseOverrides(miePhaseConfig),\n                },\n            },\n        };\n    }\n\n    static async createAsync(device: GPUDevice, aerialPerspectiveLutFormat: GPUTextureFormat, aerialPerspectiveSliceCount: number, aerialPerspectiveDistancePerSlice: number, multiscatteringLutSize: [number, number], fromKilometersScaleFactor: number, randomizeSampleOffsets: boolean, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): Promise<AerialPerspectiveLutPipeline> {\n        const bindGroupLayout = this.makeBindGroupLayout(device, aerialPerspectiveLutFormat, customUniformsConfig);\n        const pipeline = await device.createComputePipelineAsync(this.makePipelineDescriptor(device, bindGroupLayout, aerialPerspectiveLutFormat, aerialPerspectiveSliceCount, aerialPerspectiveDistancePerSlice, multiscatteringLutSize, fromKilometersScaleFactor, randomizeSampleOffsets, useMoon, shadowConfig, customUniformsConfig, miePhaseConfig));\n        return new AerialPerspectiveLutPipeline(device, pipeline, bindGroupLayout, aerialPerspectiveLutFormat, aerialPerspectiveSliceCount, aerialPerspectiveDistancePerSlice, multiscatteringLutSize);\n    }\n\n    static create(device: GPUDevice, aerialPerspectiveLutFormat: GPUTextureFormat, aerialPerspectiveSliceCount: number, aerialPerspectiveDistancePerSlice: number, multiscatteringLutSize: [number, number], fromKilometersScaleFactor: number, randomizeSampleOffsets: boolean, useMoon: boolean, shadowConfig?: ShadowConfig, customUniformsConfig?: CustomUniformsSourceConfig, miePhaseConfig?: MieHgDPhaseConfig): AerialPerspectiveLutPipeline {\n        const bindGroupLayout = this.makeBindGroupLayout(device, aerialPerspectiveLutFormat, customUniformsConfig);\n        const pipeline = device.createComputePipeline(this.makePipelineDescriptor(device, bindGroupLayout, aerialPerspectiveLutFormat, aerialPerspectiveSliceCount, aerialPerspectiveDistancePerSlice, multiscatteringLutSize, fromKilometersScaleFactor, randomizeSampleOffsets, useMoon, shadowConfig, customUniformsConfig, miePhaseConfig));\n        return new AerialPerspectiveLutPipeline(device, pipeline, bindGroupLayout, aerialPerspectiveLutFormat, aerialPerspectiveSliceCount, aerialPerspectiveDistancePerSlice, multiscatteringLutSize);\n    }\n\n    public makeComputePass(resources: SkyAtmosphereResources, shadowBindGroups?: GPUBindGroup[], customUniformsBindGroups?: GPUBindGroup[]): ComputePass {\n        if (this.device !== resources.device) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: device mismatch`);\n        }\n        if (resources.atmosphereBuffer.size < ATMOSPHERE_BUFFER_SIZE) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.uniformsBuffer && resources.uniformsBuffer.size < UNIFORMS_BUFFER_SIZE) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: buffer too small for config (${resources.atmosphereBuffer.size} < ${ATMOSPHERE_BUFFER_SIZE})`);\n        }\n        if (resources.multiScatteringLut.texture.width !== this.multiscatteringLutSize[0] || resources.multiScatteringLut.texture.height !== this.multiscatteringLutSize[1]) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture size for multiple scattering LUT. expected '${this.multiscatteringLutSize}', got ${[resources.multiScatteringLut.texture.width, resources.multiScatteringLut.texture.height]}`);\n        }\n        if (resources.aerialPerspectiveLut.texture.format !== this.aerialPerspectiveLutFormat) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture format for aerial perspective LUT. expected '${this.aerialPerspectiveLutFormat}', got ${resources.aerialPerspectiveLut.texture.format}`);\n        }\n        if (resources.aerialPerspectiveLut.texture.depthOrArrayLayers !== this.aerialPerspectiveSliceCount) {\n            throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture depth for aerial perspective LUT. expected '${this.aerialPerspectiveSliceCount}', got ${resources.aerialPerspectiveLut.texture.depthOrArrayLayers}`);\n        }\n        const bindGroup = resources.device.createBindGroup({\n            label: `aerial perspective LUT pass [${resources.label}]`,\n            layout: this.bindGroupLayout,\n            entries: ([\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: resources.atmosphereBuffer,\n                    },\n                },\n                customUniformsBindGroups ? undefined : {\n                    binding: 1,\n                    resource: {\n                        buffer: resources.uniformsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: resources.lutSampler,\n                },\n                {\n                    binding: 3,\n                    resource: resources.transmittanceLut.view,\n                },\n                {\n                    binding: 4,\n                    resource: resources.multiScatteringLut.view,\n                },\n                {\n                    binding: 5,\n                    resource: resources.aerialPerspectiveLut.view,\n                },\n            ].filter(e => e !== undefined) as GPUBindGroupEntry[])\n            .map((e, i) => {\n                e.binding = i;\n                return e;\n            }) as GPUBindGroupEntry[],\n        });\n        return new ComputePass(\n            this.pipeline,\n            [bindGroup, ...(shadowBindGroups ?? []), ...(customUniformsBindGroups ?? [])],\n            [\n                Math.ceil(resources.aerialPerspectiveLut.texture.width / 16.0),\n                Math.ceil(resources.aerialPerspectiveLut.texture.height / 16.0),\n                resources.aerialPerspectiveLut.texture.depthOrArrayLayers,\n            ],\n        );\n    }\n\n    get aerialPerspectiveInvDistancePerSlice(): number {\n        return 1.0 / this.aerialPerspectiveDistancePerSlice;\n    }\n}\n\nexport class SkyAtmospherePipelines {\n    private constructor(\n        readonly transmittanceLutPipeline: TransmittanceLutPipeline,\n        readonly multiScatteringLutPipeline: MultiScatteringLutPipeline,\n        readonly skyViewLutPipeline: SkyViewLutPipeline,\n        readonly aerialPerspectiveLutPipeline: AerialPerspectiveLutPipeline,\n    ) {}\n\n    private static getTransmittanceLutArgs(config: SkyAtmosphereRendererConfig): [GPUTextureFormat, number] {\n        return [\n            config.lookUpTables?.transmittanceLut?.format ?? TRANSMITTANCE_LUT_FORMAT,\n            config.lookUpTables?.transmittanceLut?.sampleCount ?? DEFAULT_TRANSMITTANCE_LUT_SAMPLE_COUNT,\n        ];\n    }\n\n    private static getMultiScatteringLutArgs(config: SkyAtmosphereRendererConfig): [GPUTextureFormat, number] {\n        return [\n            config.lookUpTables?.multiScatteringLut?.format ?? MULTI_SCATTERING_LUT_FORMAT,\n            config.lookUpTables?.multiScatteringLut?.sampleCount ?? DEFAULT_MULTI_SCATTERING_LUT_SAMPLE_COUNT,\n        ];\n    }\n\n    private static getSkyViewLutArgs(config: SkyAtmosphereRendererConfig): [GPUTextureFormat, [number, number], [number, number], number, number, boolean, ShadowConfig | undefined, CustomUniformsSourceConfig | undefined, MieHgDPhaseConfig | undefined] {\n        return [\n            config.lookUpTables?.skyViewLut?.format ?? SKY_VIEW_LUT_FORMAT,\n            config.lookUpTables?.skyViewLut?.size ?? DEFAULT_SKY_VIEW_LUT_SIZE,\n            config.lookUpTables?.multiScatteringLut?.size ?? [DEFAULT_MULTISCATTERING_LUT_SIZE, DEFAULT_MULTISCATTERING_LUT_SIZE],\n            config.skyRenderer?.distanceToMaxSampleCount ?? 100.0,\n            config.fromKilometersScale ?? 1.0,\n            config.lights?.useMoon ?? false,\n            (config.lookUpTables?.skyViewLut?.affectedByShadow ?? true) ? config.shadow : undefined,\n            config.customUniformsSource,\n            config.mieHgDrainePhase,\n        ];\n    }\n\n    private static getAerialPerspectiveLutArgs(config: SkyAtmosphereRendererConfig): [GPUTextureFormat, number, number, [number, number], number, boolean, boolean, ShadowConfig | undefined, CustomUniformsSourceConfig | undefined, MieHgDPhaseConfig | undefined] {\n        return [\n            config.lookUpTables?.aerialPerspectiveLut?.format ?? AERIAL_PERSPECTIVE_LUT_FORMAT,\n            (config.lookUpTables?.aerialPerspectiveLut?.size ?? DEFAULT_AERIAL_PERSPECTIVE_LUT_SIZE)[2],\n            config.lookUpTables?.aerialPerspectiveLut?.distancePerSlice ?? 4.0,\n            config.lookUpTables?.multiScatteringLut?.size ?? [DEFAULT_MULTISCATTERING_LUT_SIZE, DEFAULT_MULTISCATTERING_LUT_SIZE],\n            config.fromKilometersScale ?? 1.0,\n            config.lookUpTables?.aerialPerspectiveLut?.randomizeRayOffsets ?? false,\n            config.lights?.useMoon ?? false,\n            (config.lookUpTables?.aerialPerspectiveLut?.affectedByShadow ?? true) ? config.shadow : undefined,\n            config.customUniformsSource,\n            config.mieHgDrainePhase,\n        ];\n    }\n\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereRendererConfig): Promise<SkyAtmospherePipelines> {\n        const transmittanceLutArgs = this.getTransmittanceLutArgs(config);\n        const multiScatteringLutArgs = this.getMultiScatteringLutArgs(config);\n        const skyViewLutArgs = this.getSkyViewLutArgs(config);\n        const aerialPerspectiveLutArgs = this.getAerialPerspectiveLutArgs(config);\n\n        const transmittanceLutPipeline = TransmittanceLutPipeline.createAsync(device,\n            transmittanceLutArgs[0],\n            transmittanceLutArgs[1],\n        );\n        const multiScatteringLutPipeline = MultiScatteringLutPipeline.createAsync(\n            device,\n            multiScatteringLutArgs[0],\n            multiScatteringLutArgs[1],\n        );\n        const skyViewLutPipeline = SkyViewLutPipeline.createAsync(\n            device,\n            skyViewLutArgs[0],\n            skyViewLutArgs[1],\n            skyViewLutArgs[2],\n            skyViewLutArgs[3],\n            skyViewLutArgs[4],\n            skyViewLutArgs[5],\n            skyViewLutArgs[6],\n            skyViewLutArgs[7],\n            skyViewLutArgs[8],\n        );\n        const aerialPerspectiveLutPipeline = AerialPerspectiveLutPipeline.createAsync(\n            device,\n            aerialPerspectiveLutArgs[0],\n            aerialPerspectiveLutArgs[1],\n            aerialPerspectiveLutArgs[2],\n            aerialPerspectiveLutArgs[3],\n            aerialPerspectiveLutArgs[4],\n            aerialPerspectiveLutArgs[5],\n            aerialPerspectiveLutArgs[6],\n            aerialPerspectiveLutArgs[7],\n            aerialPerspectiveLutArgs[8],\n            aerialPerspectiveLutArgs[9],\n        );\n        return new SkyAtmospherePipelines(\n            await transmittanceLutPipeline,\n            await multiScatteringLutPipeline,\n            await skyViewLutPipeline,\n            await aerialPerspectiveLutPipeline,\n        );\n    }\n\n    static create(device: GPUDevice, config: SkyAtmosphereRendererConfig): SkyAtmospherePipelines {\n        const transmittanceLutArgs = this.getTransmittanceLutArgs(config);\n        const multiScatteringLutArgs = this.getMultiScatteringLutArgs(config);\n        const skyViewLutArgs = this.getSkyViewLutArgs(config);\n        const aerialPerspectiveLutArgs = this.getAerialPerspectiveLutArgs(config);\n\n        const transmittanceLutPipeline = TransmittanceLutPipeline.create(device,\n            transmittanceLutArgs[0],\n            transmittanceLutArgs[1],\n        );\n        const multiScatteringLutPipeline = MultiScatteringLutPipeline.create(\n            device,\n            multiScatteringLutArgs[0],\n            multiScatteringLutArgs[1],\n        );\n        const skyViewLutPipeline = SkyViewLutPipeline.create(\n            device,\n            skyViewLutArgs[0],\n            skyViewLutArgs[1],\n            skyViewLutArgs[2],\n            skyViewLutArgs[3],\n            skyViewLutArgs[4],\n            skyViewLutArgs[5],\n            skyViewLutArgs[6],\n            skyViewLutArgs[7],\n            skyViewLutArgs[8],\n        );\n        const aerialPerspectiveLutPipeline = AerialPerspectiveLutPipeline.create(\n            device,\n            aerialPerspectiveLutArgs[0],\n            aerialPerspectiveLutArgs[1],\n            aerialPerspectiveLutArgs[2],\n            aerialPerspectiveLutArgs[3],\n            aerialPerspectiveLutArgs[4],\n            aerialPerspectiveLutArgs[5],\n            aerialPerspectiveLutArgs[6],\n            aerialPerspectiveLutArgs[7],\n            aerialPerspectiveLutArgs[8],\n            aerialPerspectiveLutArgs[9],\n        );\n        return new SkyAtmospherePipelines(\n            transmittanceLutPipeline,\n            multiScatteringLutPipeline,\n            skyViewLutPipeline,\n            aerialPerspectiveLutPipeline,\n        );\n    }\n}\n","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { Atmosphere } from './atmosphere.js';\n\nimport { SkyAtmosphereRendererConfig } from './config.js';\n\nimport { Uniforms } from './uniforms.js';\nimport { SkyAtmosphereResources } from './resources.js';\n\nimport { SkyAtmospherePipelines as SkyAtmosphereLutPipelines } from './pipelines.js';\nimport { ComputePass } from './util.js';\n\nexport interface SkyAtmosphereRenderer {\n    /**\n     * Updates the renderer's internal uniform buffer containing the {@link Atmosphere} parameters as well as its host-side copy of {@link Atmosphere} parameters.\n     * @param atmosphere The new {@link Atmosphere} to override the current parameters.\n     *\n     * @see {@link SkyAtmosphereResources.updateAtmosphere}: Updates the host-side {@link Atmosphere} parameters as well as the corresponding uniform buffer.\n     */\n    updateAtmosphere(atmosphere: Atmosphere): void;\n\n    /**\n     * Updates the renderer's internal uniform buffer containing the {@link Uniforms} as well as its host-side copy of {@link Uniforms}.\n     * @param uniforms The new {@link Uniforms} to override the current parameters.\n     *\n     * If custom uniform buffers are used, this does nothing (see {@link CustomUniformsSourceConfig}).\n     *\n     * @see {@link SkyAtmosphereResources.updateUniforms}: Update the {@link Uniforms} uniform buffers.\n     */\n    updateUniforms(uniforms: Uniforms): void;\n\n    /**\n     * Renders the transmittance lookup table.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the transmittance lookup table is not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link updateAtmosphere}: To write {@link Atmosphere} parameters to the internal uniform buffer, call this function.\n     */\n    renderTransmittanceLut(passEncoder: GPUComputePassEncoder): void;\n\n    /**\n     * Renders the multiple scattering lookup table.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the multiple scattering lookup table is not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link updateAtmosphere}: To write {@link Atmosphere} parameters to the internal uniform buffer, call this function.\n     */\n    renderMultiScatteringLut(passEncoder: GPUComputePassEncoder): void;\n\n    /**\n     * Renders the transmittance and multiple scattering lookup tables.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Use the {@link atmosphere} parameter to implicitly update the {@link Atmosphere} parameters or call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the transmittance and multiple scattering lookup tables are not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup tables. The encoder is not `end()`ed by this function.\n     * @param atmosphere If this is defined, {@link updateAtmosphere} is called before rendering the lookup tables.\n     *\n     * @see {@link updateAtmosphere}: Updates the {@link Atmosphere} parameters.\n     * @see {@link renderTransmittanceLut}: Renders the transmittance lookup table.\n     * @see {@link renderMultiScatteringLut}: Renders the multiple scattering lookup table.\n     */\n    renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere): void;\n\n    /**\n     * Renders the sky view table.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: To write {@link Uniforms} to the internal uniform buffer, call this function.\n     */\n    renderSkyViewLut(passEncoder: GPUComputePassEncoder): void;\n\n    /**\n     * Renders the aerial perspective lookup table.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * If (a) user-defined shadow map(s) is used (see {@link SkyAtmosphereRendererConfig.shadow}), make sure to encode any updates of the shadow map(s) before encoding this pass.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: To write {@link Uniforms} to the internal uniform buffer, call this function.\n     */\n    renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder): void;\n\n    /**\n     * Renders the sky view and aerial perspective lookup tables.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * If (a) user-defined shadow map(s) is used (see {@link SkyAtmosphereRendererConfig.shadow}), make sure to encode any updates of the shadow map(s) before encoding this pass.\n     *\n     * @param passEncoder Used to encode rendering of the lookup tables. The encoder is not `end()`ed by this function.\n     * @param uniforms If this is defined, {@link updateUniforms} is called before rendering the lookup tables.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: Updates the internal {@link Uniforms} uniform buffer.\n     * @see {@link renderSkyViewLut}: Renders the sky view lookup table.\n     * @see {@link renderAerialPerspectiveLut}: Renders the aerial perspective lookup table.\n     */\n    renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms): void;\n\n    /**\n     * Renders the lookup tables required for rendering the sky / atmosphere.\n     *\n     * To initialize or update the transmittance and multiple scattering lookup tables, pass new {@link Atmosphere} paramters to this function or use the `forceConstantLutRendering` parameter.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode passes with. The encoder is not `end()`ed by this function.\n     * @param uniforms {@link Uniforms} to use for this frame. If this is given, the internal uniform buffer will be updated using {@link updateUniforms}.\n     * @param atmosphere {@link Atmosphere} parameters to use for this frame. If this is given, the internal uniform buffer storing the {@link Atmosphere} parameters will be updated and the transmittance and multiple scattering lookup tables will be rendered.\n     * @param skipDynamicLutRendering If this is true, the sky view and aerial perspective lookup tables will not be rendered.\n     * @param forceConstantLutRendering If this is true, the transmittance and multiple scattering lookup tables will be rendered regardless of whether the `atmosphere` parameter is `undefined` or not.\n     * @param forceSkyViewLutRendering If this is true, the sky view lookup table will be rendered, even if {@link skipDynamicLutRendering} is true. Defaults to false.\n     *\n     * @see {@link renderConstantLuts}: Renders the lookup tables that are constant for a given {@link Atmosphere}.\n     * @see {@link updateUniforms}: Updates the internal {@link Uniforms} uniform buffer.\n     * @see {@link renderDynamicLuts}: Renders the view-dependent lookup tables.\n     * @see {@link renderSkyViewLut}: Renders the sky view lookup table.\n     */\n    renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, skipDynamicLutRendering?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void;\n}\n\nexport class SkyAtmosphereLutRenderer implements SkyAtmosphereRenderer {\n    protected constructor(\n        readonly resources: SkyAtmosphereResources,\n        readonly pipelines: SkyAtmosphereLutPipelines,\n        public skipDynamicLutRendering: boolean,\n        readonly usesCustomUniforms: boolean,\n        protected transmittanceLutPass: ComputePass,\n        protected multiScatteringLutPass: ComputePass,\n        protected skyViewLutPass: ComputePass,\n        protected aerialPerspectiveLutPass: ComputePass,\n    ) {}\n\n    /**\n     * Creates a {@link SkyAtmosphereLutRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereRendererConfig, existingPipelines?: SkyAtmosphereLutPipelines, existingResources?: SkyAtmosphereResources): SkyAtmosphereLutRenderer {\n        let skyAtmospherePipelines;\n        if ((existingPipelines?.transmittanceLutPipeline.device || device) !== device) {\n            skyAtmospherePipelines = SkyAtmosphereLutPipelines.create(device, config);\n        } else {\n            skyAtmospherePipelines = existingPipelines || SkyAtmosphereLutPipelines.create(device, config);\n        }\n\n        const defaultToPerPixelRayMarch = config.skyRenderer?.defaultToPerPixelRayMarch ?? false;\n        const usesCustomUniforms = config.customUniformsSource !== undefined;\n\n        const resources = existingResources || new SkyAtmosphereResources(device, config);\n\n        const transmittanceLutPass = skyAtmospherePipelines.transmittanceLutPipeline.makeComputePass(resources);\n        const multiScatteringLutPass = skyAtmospherePipelines.multiScatteringLutPipeline.makeComputePass(resources);\n        const skyViewLutPass = skyAtmospherePipelines.skyViewLutPipeline.makeComputePass(resources, (config.lookUpTables?.skyViewLut?.affectedByShadow ?? true) ? config.shadow?.bindGroups : undefined, config.customUniformsSource?.bindGroups);\n        const aerialPerspectiveLutPass = skyAtmospherePipelines.aerialPerspectiveLutPipeline.makeComputePass(resources, (config.lookUpTables?.aerialPerspectiveLut?.affectedByShadow ?? true) ? config.shadow?.bindGroups : undefined, config.customUniformsSource?.bindGroups);\n\n        const lutRenderer = new SkyAtmosphereLutRenderer(\n            resources,\n            skyAtmospherePipelines,\n            defaultToPerPixelRayMarch,\n            usesCustomUniforms,\n            transmittanceLutPass,\n            multiScatteringLutPass,\n            skyViewLutPass,\n            aerialPerspectiveLutPass,\n        );\n\n        if (config.initializeConstantLuts ?? true) {\n            const commandEncoder = device.createCommandEncoder();\n            const computePassEncoder = commandEncoder.beginComputePass();\n            lutRenderer.renderConstantLuts(computePassEncoder);\n            computePassEncoder.end();\n            device.queue.submit([commandEncoder.finish()]);\n        }\n\n        return lutRenderer;\n    }\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereLutRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereRendererConfig, existingPipelines?: SkyAtmosphereLutPipelines, existingResources?: SkyAtmosphereResources): Promise<SkyAtmosphereLutRenderer> {\n        let skyAtmospherePipelines;\n        if ((existingPipelines?.transmittanceLutPipeline.device || device) !== device) {\n            skyAtmospherePipelines = await SkyAtmosphereLutPipelines.createAsync(device, config);\n        } else {\n            skyAtmospherePipelines = existingPipelines || await SkyAtmosphereLutPipelines.createAsync(device, config);\n        }\n        return this.create(device, config, skyAtmospherePipelines, existingResources);\n    }\n\n    /**\n     * Updates the renderer's internal uniform buffer containing the {@link Atmosphere} parameters as well as its host-side copy of {@link Atmosphere} parameters.\n     * @param atmosphere The new {@link Atmosphere} to override the current parameters.\n     *\n     * @see {@link SkyAtmosphereResources.updateAtmosphere}: Updates the host-side {@link Atmosphere} parameters as well as the corresponding uniform buffer.\n     */\n    public updateAtmosphere(atmosphere: Atmosphere) {\n        this.resources.updateAtmosphere(atmosphere);\n    }\n\n    /**\n     * Updates the renderer's internal uniform buffer containing the {@link Uniforms} as well as its host-side copy of {@link Uniforms}.\n     * @param uniforms The new {@link Uniforms} to override the current parameters.\n     *\n     * If custom uniform buffers are used, this does nothing (see {@link CustomUniformsSourceConfig}).\n     *\n     * @see {@link SkyAtmosphereResources.updateUniforms}: Update the {@link Uniforms} uniform buffers.\n     */\n    public updateUniforms(uniforms: Uniforms) {\n        if (!this.usesCustomUniforms) {\n            this.resources.updateUniforms(uniforms);\n        }\n    }\n\n    /**\n     * Renders the transmittance lookup table.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the transmittance lookup table is not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link updateAtmosphere}: To write {@link Atmosphere} parameters to the internal uniform buffer, call this function.\n     */\n    public renderTransmittanceLut(passEncoder: GPUComputePassEncoder) {\n        this.transmittanceLutPass.encode(passEncoder);\n    }\n\n    /**\n     * Renders the multiple scattering lookup table.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the multiple scattering lookup table is not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link updateAtmosphere}: To write {@link Atmosphere} parameters to the internal uniform buffer, call this function.\n     */\n    public renderMultiScatteringLut(passEncoder: GPUComputePassEncoder) {\n        this.multiScatteringLutPass.encode(passEncoder);\n    }\n\n    /**\n     * Renders the transmittance and multiple scattering lookup tables.\n     *\n     * To produce meaningful results, this requires the internal uniform buffer containing the {@link Atmosphere} parameters to hold valid data.\n     * Use the {@link atmosphere} parameter to implicitly update the {@link Atmosphere} parameters or call {@link updateAtmosphere} to ensure this is the case.\n     *\n     * Since the transmittance and multiple scattering lookup tables are not view or light souce dependent, this only needs to be called if the {@link Atmosphere} parameters change.\n     *\n     * @param passEncoder Used to encode rendering of the lookup tables. The encoder is not `end()`ed by this function.\n     * @param atmosphere If this is defined, {@link updateAtmosphere} is called before rendering the lookup tables.\n     *\n     * @see {@link updateAtmosphere}: Updates the {@link Atmosphere} parameters.\n     * @see {@link renderTransmittanceLut}: Renders the transmittance lookup table.\n     * @see {@link renderMultiScatteringLut}: Renders the multiple scattering lookup table.\n     */\n    public renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere) {\n        if (atmosphere) {\n            this.updateAtmosphere(atmosphere);\n        }\n        this.renderTransmittanceLut(passEncoder);\n        this.renderMultiScatteringLut(passEncoder);\n    }\n\n    /**\n     * Renders the sky view table.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: To write {@link Uniforms} to the internal uniform buffer, call this function.\n     */\n    public renderSkyViewLut(passEncoder: GPUComputePassEncoder) {\n        this.skyViewLutPass.encode(passEncoder);\n    }\n\n    /**\n     * Renders the aerial perspective lookup table.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * If (a) user-defined shadow map(s) is used (see {@link SkyAtmosphereRendererConfig.shadow}), make sure to encode any updates of the shadow map(s) before encoding this pass.\n     *\n     * @param passEncoder Used to encode rendering of the lookup table. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: To write {@link Uniforms} to the internal uniform buffer, call this function.\n     */\n    public renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder) {\n        this.aerialPerspectiveLutPass.encode(passEncoder);\n    }\n\n    /**\n     * Renders the sky view and aerial perspective lookup tables.\n     *\n     * To produce meaningful results, this requires the transmittance and multiple scattering lookup tables, as well as the uniform buffers containing the {@link Atmosphere} and {@link Uniforms} parameters to hold valid data.\n     * Call {@link renderConstantLuts} and {@link updateUniforms} to ensure this is the case.\n     *\n     * If (a) user-defined shadow map(s) is used (see {@link SkyAtmosphereRendererConfig.shadow}), make sure to encode any updates of the shadow map(s) before encoding this pass.\n     *\n     * @param passEncoder Used to encode rendering of the lookup tables. The encoder is not `end()`ed by this function.\n     * @param uniforms If this is defined, {@link updateUniforms} is called before rendering the lookup tables.\n     *\n     * @see {@link renderConstantLuts}: To initialize the transmittance and multiple scattering lookup tables, as well as the internal uniform buffer storing the {@link Atmosphere} parameters, call this function.\n     * @see {@link updateUniforms}: Updates the internal {@link Uniforms} uniform buffer.\n     * @see {@link renderSkyViewLut}: Renders the sky view lookup table.\n     * @see {@link renderAerialPerspectiveLut}: Renders the aerial perspective lookup table.\n     */\n    public renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms) {\n        if (uniforms) {\n            this.updateUniforms(uniforms);\n        }\n        this.renderSkyViewLut(passEncoder);\n        this.renderAerialPerspectiveLut(passEncoder);\n    }\n\n    /**\n     * Renders the lookup tables required for rendering the sky / atmosphere.\n     *\n     * To initialize or update the transmittance and multiple scattering lookup tables, pass new {@link Atmosphere} paramters to this function or use the `forceConstantLutRendering` parameter.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode passes with. The encoder is not `end()`ed by this function.\n     * @param uniforms {@link Uniforms} to use for this frame. If this is given, the internal uniform buffer will be updated using {@link updateUniforms}.\n     * @param atmosphere {@link Atmosphere} parameters to use for this frame. If this is given, the internal uniform buffer storing the {@link Atmosphere} parameters will be updated and the transmittance and multiple scattering lookup tables will be rendered.\n     * @param skipDynamicLutRendering If this is true, the sky view and aerial perspective lookup tables will not be rendered. Defaults to {@link skipDynamicLutRendering}.\n     * @param forceConstantLutRendering If this is true, the transmittance and multiple scattering lookup tables will be rendered regardless of whether the `atmosphere` parameter is `undefined` or not.\n     * @param forceSkyViewLutRendering If this is true, the sky view lookup table will be rendered, even if {@link skipDynamicLutRendering} is true. Defaults to false.\n     *\n     * @see {@link renderConstantLuts}: Renders the lookup tables that are constant for a given {@link Atmosphere}.\n     * @see {@link updateUniforms}: Updates the internal {@link Uniforms} uniform buffer.\n     * @see {@link renderDynamicLuts}: Renders the view-dependent lookup tables.\n     * @see {@link renderSkyViewLut}: Renders the sky view lookup table.\n     */\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, skipDynamicLutRendering?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean) {\n        if (atmosphere || (forceConstantLutRendering ?? false)) {\n            this.renderConstantLuts(passEncoder, atmosphere);\n        }\n        if (skipDynamicLutRendering ?? false) {\n            if (uniforms) {\n                this.updateUniforms(uniforms);\n            }\n            if (forceSkyViewLutRendering ?? false) {\n                this.renderSkyViewLut(passEncoder);\n            }\n        } else {\n            this.renderDynamicLuts(passEncoder, uniforms);\n        }\n    }\n}\n","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { SkyAtmosphereComputeRendererConfig, SkyAtmosphereRasterRendererConfig, SkyAtmosphereRendererConfig } from './config.js';\nimport { SkyAtmosphereLutRenderer } from './lut-renderer.js';\nimport { makeMiePhaseOverrides } from './pipelines.js';\nimport { ATMOSPHERE_BUFFER_SIZE, SkyAtmosphereResources, UNIFORMS_BUFFER_SIZE } from './resources.js';\n\nexport function makeSkyRendereringBaseLayoutEntries(config: SkyAtmosphereRendererConfig, resources: SkyAtmosphereResources, visibility: GPUShaderStageFlags): GPUBindGroupLayoutEntry[] {\n    return [\n        {\n            binding: 0,\n            visibility,\n            buffer: {\n                type: 'uniform',\n                hasDynamicOffset: false,\n                minBindingSize: ATMOSPHERE_BUFFER_SIZE,\n            },\n        },\n        config.customUniformsSource ? undefined : {\n            binding: 1,\n            visibility,\n            buffer: {\n                type: 'uniform',\n                hasDynamicOffset: false,\n                minBindingSize: UNIFORMS_BUFFER_SIZE,\n            },\n        },\n        {\n            binding: 2,\n            visibility,\n            sampler: {\n                type: 'filtering',\n            },\n        },\n        {\n            binding: 3,\n            visibility,\n            texture: {\n                sampleType: 'float',\n                viewDimension: resources.transmittanceLut.texture.dimension,\n                multisampled: false,\n            },\n        },\n    ].filter(e => e !== undefined) as GPUBindGroupLayoutEntry[];\n}\n\nexport function makeWithLutsBindGroupLayout(device: GPUDevice, config: SkyAtmosphereRendererConfig, externalEntries: GPUBindGroupLayoutEntry[], resources: SkyAtmosphereResources, visibility: GPUShaderStageFlags): GPUBindGroupLayout {\n    const renderSkyBindGroupLayoutBaseEntries = makeSkyRendereringBaseLayoutEntries(config, resources, visibility);\n    return device.createBindGroupLayout({\n        label: `Render sky with luts bind group layout [${resources.label}]`,\n        entries: [\n            ...renderSkyBindGroupLayoutBaseEntries,\n            {\n                binding: 4,\n                visibility,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: resources.skyViewLut.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            {\n                binding: 5,\n                visibility,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: resources.aerialPerspectiveLut.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            ...externalEntries,\n        ].map((v, i) => {\n            v.binding = i;\n            return v;\n        }) as GPUBindGroupLayoutEntry[],\n    });\n}\n\nexport function makeRayMarchBindGroupLayout(device: GPUDevice, config: SkyAtmosphereRendererConfig, externalEntries: GPUBindGroupLayoutEntry[], resources: SkyAtmosphereResources, rayMarchDistantSky: boolean, visibility: GPUShaderStageFlags): GPUBindGroupLayout {\n    const renderSkyBindGroupLayoutBaseEntries = makeSkyRendereringBaseLayoutEntries(config, resources, visibility);\n    return device.createBindGroupLayout({\n        label: `Render sky raymarching bind group layout [${resources.label}]`,\n        entries: ([\n            ...renderSkyBindGroupLayoutBaseEntries,\n            {\n                binding: 4,\n                visibility,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: resources.multiScatteringLut.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            rayMarchDistantSky ? undefined : {\n                binding: 5,\n                visibility,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: resources.skyViewLut.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            ...externalEntries,\n        ].filter(e => e !== undefined) as GPUBindGroupLayoutEntry[])\n        .map((v, i) => {\n            v.binding = i;\n            return v;\n        }) as GPUBindGroupLayoutEntry[],\n    });\n}\n\nexport function makeSkyRenderingBindGroupLayouts(device: GPUDevice, config: SkyAtmosphereRendererConfig, externalEntries: GPUBindGroupLayoutEntry[], resources: SkyAtmosphereResources, rayMarchDistantSky: boolean, visibility: GPUShaderStageFlags): [GPUBindGroupLayout, GPUBindGroupLayout] {\n    return [\n        makeWithLutsBindGroupLayout(device, config, externalEntries, resources, visibility),\n        makeRayMarchBindGroupLayout(device, config, externalEntries, resources, rayMarchDistantSky, visibility),\n    ];\n}\n\nexport function makeSkyRenderingBaseEntries(resources: SkyAtmosphereResources, customUniforms: boolean): GPUBindGroupEntry[] {\n    return [\n        {\n            binding: 0,\n            resource: {\n                buffer: resources.atmosphereBuffer,\n            },\n        },\n        customUniforms ? undefined : {\n            binding: 1,\n            resource: {\n                buffer: resources.uniformsBuffer,\n            },\n        },\n        {\n            binding: 2,\n            resource: resources.lutSampler,\n        },\n        {\n            binding: 3,\n            resource: resources.transmittanceLut.view,\n        },\n    ].filter(e => e !== undefined) as GPUBindGroupEntry[];\n}\n\nexport function makeWithLutsBindGroup(resources: SkyAtmosphereResources, layout: GPUBindGroupLayout, customUniforms: boolean, externalEntries: GPUBindGroupEntry[]): GPUBindGroup {\n    return resources.device.createBindGroup({\n        label: `Render sky with LUTs bind group [${resources.label}]`,\n        layout: layout,\n        entries: [\n            ...makeSkyRenderingBaseEntries(resources, customUniforms),\n            {\n                binding: 4,\n                resource: resources.skyViewLut.view,\n            },\n            {\n                binding: 5,\n                resource: resources.aerialPerspectiveLut.view,\n            },\n            ...externalEntries,\n        ].map((v, i) => {\n            v.binding = i;\n            return v;\n        }) as GPUBindGroupEntry[],\n    });\n}\n\nexport function makeRayMarchBindGroup(resources: SkyAtmosphereResources, layout: GPUBindGroupLayout, customUniforms: boolean, externalEntries: GPUBindGroupEntry[], rayMarchDistantSky: boolean): GPUBindGroup {\n    return resources.device.createBindGroup({\n        label: `Render sky raymarching bind group [${resources.label}]`,\n        layout: layout,\n        entries: ([\n            ...makeSkyRenderingBaseEntries(resources, customUniforms),\n            {\n                binding: 4,\n                resource: resources.multiScatteringLut.view,\n            },\n            rayMarchDistantSky ? undefined : {\n                binding: 5,\n                resource: resources.skyViewLut.view,\n            },\n            ...externalEntries,\n        ].filter(e => e !== undefined) as GPUBindGroupEntry[])\n        .map((v, i) => {\n            v.binding = i;\n            return v;\n        }) as GPUBindGroupEntry[],\n    });\n}\n\nexport function makeSkyRenderingBindGroups(resources: SkyAtmosphereResources, withLutsLayout: GPUBindGroupLayout, rayMarchLayout: GPUBindGroupLayout, customUniforms: boolean, externalEntries: GPUBindGroupEntry[], rayMarchDistantSky: boolean): [GPUBindGroup, GPUBindGroup] {\n    return [\n        makeWithLutsBindGroup(resources, withLutsLayout, customUniforms, externalEntries),\n        makeRayMarchBindGroup(resources, rayMarchLayout, customUniforms, externalEntries, rayMarchDistantSky),\n    ];\n}\n\nexport function makeWithLutsConstants(config: SkyAtmosphereComputeRendererConfig | SkyAtmosphereRasterRendererConfig, lutRenderer: SkyAtmosphereLutRenderer): Record<string, GPUPipelineConstantValue> {\n    return {\n        AP_SLICE_COUNT: lutRenderer.resources.aerialPerspectiveLut.texture.depthOrArrayLayers,\n        AP_DISTANCE_PER_SLICE: lutRenderer.pipelines.aerialPerspectiveLutPipeline.aerialPerspectiveDistancePerSlice,\n        AP_INV_DISTANCE_PER_SLICE: lutRenderer.pipelines.aerialPerspectiveLutPipeline.aerialPerspectiveInvDistancePerSlice,\n        SKY_VIEW_LUT_RES_X: lutRenderer.resources.skyViewLut.texture.width,\n        SKY_VIEW_LUT_RES_Y: lutRenderer.resources.skyViewLut.texture.height,\n        IS_REVERSE_Z: Number(config.skyRenderer.depthBuffer.reverseZ ?? false),\n        FROM_KM_SCALE: config.fromKilometersScale ?? 1.0,\n        RENDER_SUN_DISK: Number(config.lights?.renderSunDisk ?? true),\n        RENDER_MOON_DISK: Number(config.lights?.renderMoonDisk ?? (config.lights?.useMoon ?? false)),\n        LIMB_DARKENING_ON_SUN: Number(config.lights?.applyLimbDarkeningOnSun ?? true),\n        LIMB_DARKENING_ON_MOON: Number(config.lights?.applyLimbDarkeningOnMoon ?? false),\n        USE_MOON: Number(config.lights?.useMoon ?? false),\n    };\n}\n\nexport function makeRayMarchConstantsBase(config: SkyAtmosphereComputeRendererConfig | SkyAtmosphereRasterRendererConfig, lutRenderer: SkyAtmosphereLutRenderer, rayMarchDistantSky: boolean): Record<string, GPUPipelineConstantValue> {\n    const constants: Record<string, GPUPipelineConstantValue> = {\n        INV_DISTANCE_TO_MAX_SAMPLE_COUNT: 1.0 / (config.skyRenderer.distanceToMaxSampleCount ?? 100.0),\n        RANDOMIZE_SAMPLE_OFFSET: Number(config.skyRenderer.rayMarch?.randomizeRayOffsets ?? true),\n        MULTI_SCATTERING_LUT_RES_X: lutRenderer.resources.multiScatteringLut.texture.width,\n        MULTI_SCATTERING_LUT_RES_Y: lutRenderer.resources.multiScatteringLut.texture.height,\n        IS_REVERSE_Z: Number(config.skyRenderer.depthBuffer.reverseZ ?? false),\n        FROM_KM_SCALE: config.fromKilometersScale ?? 1.0,\n        RENDER_SUN_DISK: Number(config.lights?.renderSunDisk ?? true),\n        RENDER_MOON_DISK: Number(config.lights?.renderMoonDisk ?? (config.lights?.useMoon ?? false)),\n        LIMB_DARKENING_ON_SUN: Number(config.lights?.applyLimbDarkeningOnSun ?? true),\n        LIMB_DARKENING_ON_MOON: Number(config.lights?.applyLimbDarkeningOnMoon ?? false),\n        USE_MOON: Number(config.lights?.useMoon ?? false),\n        ...makeMiePhaseOverrides(config.mieHgDrainePhase),\n    };\n    if (!rayMarchDistantSky) {\n        constants['SKY_VIEW_LUT_RES_X'] = lutRenderer.resources.skyViewLut.texture.width;\n        constants['SKY_VIEW_LUT_RES_Y'] = lutRenderer.resources.skyViewLut.texture.height;\n    }\n    return constants;\n}","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { Atmosphere } from './atmosphere.js';\nimport { SkyAtmosphereComputeRendererConfig } from './config.js';\nimport { SkyAtmosphereRenderer, SkyAtmosphereLutRenderer } from './lut-renderer.js';\nimport { SkyAtmospherePipelines } from './pipelines.js';\nimport { SkyAtmosphereResources } from './resources.js';\nimport { makeRenderSkyLutAndRaymarchingShaderCode, makeRenderSkyRaymarchingShaderCode, makeRenderSkyWithLutsShaderCode } from './shaders.js';\nimport { makeRayMarchBindGroup, makeRayMarchBindGroupLayout, makeRayMarchConstantsBase, makeWithLutsBindGroup, makeWithLutsBindGroupLayout, makeWithLutsConstants } from './sky-renderer-utils.js';\nimport { Uniforms } from './uniforms.js';\nimport { ComputePass } from './util.js';\n\nexport interface SkyAtmosphereComputeRendererResizeConfig {\n    /**\n     * The back buffer texture to use as back ground when rendering the sky / atmosphere using a GPUComputePipeline.\n     *\n     * If this is a texture, a texture view will be created.\n     *\n     * Should have the same size as the other textures.\n     */\n    backBuffer: GPUTextureView | GPUTexture,\n\n    /**\n     * The depth buffer to limit the ray marching distance when rendering the sky / atmosphere.\n     *\n     * If this is a textue, a texture view will be created.\n     *\n     * If this is a texture view, it must be allowed to be bound as a `texture<f32>`.\n     * I.e., if the texture has a depth-stencil format, the texture view must be a `\"depth-only\"` view.\n     *\n     * Should have the same size as the other textures.\n     */\n    depthBuffer: GPUTextureView | GPUTexture,\n\n    /**\n     * The render target to render into when using a GPUComputePipeline to render the sky / atmosphere.\n     *\n     * If this is a texture, a texture view will be created.\n     *\n     * Should have the same size as the other textures.\n     */\n    renderTarget: GPUTextureView | GPUTexture,\n\n    /**\n     * The new size of the textures.\n     *\n     * If this is undefined, the new size is determined from the given resources, i.e., at least one of {@link backBuffer}, {@link depthBuffer}, and {@link renderTarget} must be a `GPUTexture`.\n     */\n    size?: [number, number],\n}\n\nabstract class SkyComputeRenderer implements SkyAtmosphereRenderer {\n    private pass: ComputePass;\n    protected doesRayMarchDistantSky: boolean;\n\n    constructor(\n        protected lutRenderer: SkyAtmosphereLutRenderer,\n        protected bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPUComputePipeline,\n        config: SkyAtmosphereComputeRendererConfig,\n        isRayMarchPass: boolean,\n    ) {\n        this.doesRayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n\n        const bindGroup = this.makeBindGroup({\n            depthBuffer: config.skyRenderer.depthBuffer.view ?? config.skyRenderer.depthBuffer.texture,\n            backBuffer: config.skyRenderer.backBuffer.view ?? config.skyRenderer.backBuffer.texture,\n            renderTarget: config.skyRenderer.renderTarget.view ?? config.skyRenderer.renderTarget.texture,\n        });\n\n        const dispatchDimensions: [number, number, number] = [\n            Math.ceil(config.skyRenderer.renderTarget.texture.width / 16.0),\n            Math.ceil(config.skyRenderer.renderTarget.texture.height / 16.0),\n            1,\n        ];\n\n        this.pass = new ComputePass(\n            pipeline,\n            [\n                bindGroup,\n                ...(isRayMarchPass ? config.shadow?.bindGroups ?? [] : []),\n                ...(config.customUniformsSource?.bindGroups ?? []),\n            ],\n            dispatchDimensions,\n        );\n    }\n\n    protected static makeExternalBindGroupLayoutEntries(config: SkyAtmosphereComputeRendererConfig): GPUBindGroupLayoutEntry[] {\n        return [\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                texture: {\n                    sampleType: 'unfilterable-float',\n                    viewDimension: config.skyRenderer.depthBuffer.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                texture: {\n                    sampleType: 'unfilterable-float',\n                    viewDimension: config.skyRenderer.backBuffer.texture.dimension,\n                    multisampled: false,\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: {\n                    access: 'write-only',\n                    format: config.skyRenderer.renderTarget.texture.format,\n                    viewDimension: config.skyRenderer.renderTarget.texture.dimension,\n                },\n            },\n        ];\n\n    }\n\n    protected makeExternalBindGroupEntries(config: SkyAtmosphereComputeRendererResizeConfig): GPUBindGroupEntry[] {\n        return [\n            {\n                binding: 5,\n                resource: config.depthBuffer instanceof GPUTextureView ? config.depthBuffer : config.depthBuffer.createView(config.depthBuffer.format.includes('depth') ? {\n                    aspect: 'depth-only',\n                } : {}),\n            },\n            {\n                binding: 6,\n                resource: config.backBuffer instanceof GPUTextureView ? config.backBuffer : config.backBuffer.createView(),\n            },\n            {\n                binding: 7,\n                resource: config.renderTarget instanceof GPUTextureView ? config.renderTarget : config.renderTarget.createView(),\n            },\n        ];\n    }\n\n    protected abstract makeBindGroup(config: SkyAtmosphereComputeRendererResizeConfig): GPUBindGroup;\n\n    /**\n     * Replaces potentially screen-size dependent external resources (back buffer, depth buffer, and render target) in the internal bind groups.\n     *\n     * @param config Configuration of external resources.\n     */\n    public onResize(config: SkyAtmosphereComputeRendererResizeConfig) {\n        let size = config.size ?? [-1, -1];\n        if (size[0] < 0) {\n            if (config.backBuffer instanceof GPUTexture) {\n                size = [config.backBuffer.width, config.backBuffer.height];\n            }\n            if (config.depthBuffer instanceof GPUTexture) {\n                size = [config.depthBuffer.width, config.depthBuffer.height];\n            }\n            if (config.renderTarget instanceof GPUTexture) {\n                size = [config.renderTarget.width, config.renderTarget.height];\n            }\n        }\n        if (size[0] < 0 || size[1] < 0) {\n            throw new Error(`[SkyAtmosphereComputeRenderer::onResize]: could not determine new size from config`);\n        }\n        this.pass.replaceBindGroup(0, this.makeBindGroup(config));\n        this.pass.replaceDispatchDimensions([\n            Math.ceil(size[0] / 16.0),\n            Math.ceil(size[1] / 16.0),\n            1,\n        ]);\n    }\n\n    /**\n     * Renders the sky / atmosphere.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode the pass with. Can be the same encoder used to initialize lookup tables required. The encoder is not `end()`ed by this function.\n     */\n    public renderSky(passEncoder: GPUComputePassEncoder) {\n        this.pass.encode(passEncoder);\n    }\n\n    /**\n     * Renders the sky / atmosphere, as well as all look up tables required.\n     *\n     * To initialize or update the transmittance and multiple scattering lookup tables, pass new {@link Atmosphere} paramters to this function or use the `forceConstantLutRendering` parameter.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode passes with. The encoder is not `end()`ed by this function.\n     * @param uniforms {@link Uniforms} to use for this frame. If this is given, the internal uniform buffer will be updated using {@link updateUniforms}.\n     * @param atmosphere {@link Atmosphere} parameters to use for this frame. If this is given, the internal uniform buffer storing the {@link Atmosphere} parameters will be updated and the transmittance and multiple scattering lookup tables will be rendered.\n     * @param forceConstantLutRendering If this is true, the transmittance and multiple scattering lookup tables will be rendered regardless of whether the `atmosphere` parameter is `undefined` or not.\n     *\n     * @see {@link renderLuts}: Renders the lookup tables required for rendering the sky / atmosphere.\n     * @see {@link renderSky}: Renders the sky / atmosphere.\n     */\n    public abstract renderLutsAndSky(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, forceConstantLutRendering?: boolean): void;\n\n    public updateAtmosphere(atmosphere: Atmosphere): void {\n        this.lutRenderer.updateAtmosphere(atmosphere);\n    }\n\n    public updateUniforms(uniforms: Uniforms): void {\n        this.lutRenderer.updateUniforms(uniforms);\n    }\n\n    public renderTransmittanceLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderTransmittanceLut(passEncoder);\n    }\n\n    public renderMultiScatteringLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderMultiScatteringLut(passEncoder);\n    }\n\n    public renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere): void {\n        this.lutRenderer.renderConstantLuts(passEncoder, atmosphere);\n    }\n\n    public renderSkyViewLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderSkyViewLut(passEncoder);\n    }\n\n    public renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderAerialPerspectiveLut(passEncoder);\n    }\n\n    public renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms): void {\n        this.lutRenderer.renderDynamicLuts(passEncoder, uniforms);\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, useFullResolutionRayMarch?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, useFullResolutionRayMarch, forceConstantLutRendering, forceSkyViewLutRendering);\n    }\n\n    get resources(): SkyAtmosphereResources {\n        return this.lutRenderer.resources;\n    }\n}\n\n/**\n * A sky / atmosphere renderer that renders the sky based on lookup tables.\n * It uses `GPUComputePipeline`s to render the sky / atmosphere.\n */\nexport class SkyWithLutsComputeRenderer extends SkyComputeRenderer {\n    private constructor(\n        lutRenderer: SkyAtmosphereLutRenderer,\n        bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPUComputePipeline,\n        config: SkyAtmosphereComputeRendererConfig,\n    ) {\n        super(lutRenderer, bindGroupLayout, pipeline, config, false);\n    }\n\n    private static makeBindGroupLayout(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, resources: SkyAtmosphereResources): GPUBindGroupLayout {\n        return makeWithLutsBindGroupLayout(device, config, this.makeExternalBindGroupLayoutEntries(config), resources, GPUShaderStage.COMPUTE);\n    }\n\n    private static makeWithLutsPiplelineDescriptor(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, lutRenderer: SkyAtmosphereLutRenderer, renderSkyWithLutsBindGroupLayout: GPUBindGroupLayout): GPUComputePipelineDescriptor {\n        return {\n            label: `Render sky with LUTs pipeline [${lutRenderer.resources.label}]`,\n            layout: device.createPipelineLayout({\n                label: `Render sky with LUTs pipeline layout [${lutRenderer.resources.label}]`,\n                bindGroupLayouts: [\n                    renderSkyWithLutsBindGroupLayout,\n                    ...(config.customUniformsSource?.bindGroupLayouts ?? []),\n                ],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: makeRenderSkyWithLutsShaderCode(config.skyRenderer.renderTarget.texture.format, config.customUniformsSource?.wgslCode),\n                }),\n                entryPoint: 'render_sky_atmosphere',\n                constants: makeWithLutsConstants(config, lutRenderer),\n            },\n        };\n    }\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereComputeRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyWithLutsComputeRenderer> {\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources);\n        const pipeline = await device.createComputePipelineAsync(this.makeWithLutsPiplelineDescriptor(device, config, lutRenderer, bindGroupLayout));\n        return new SkyWithLutsComputeRenderer(\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereComputeRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyWithLutsComputeRenderer {\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources);\n        const pipeline = device.createComputePipeline(this.makeWithLutsPiplelineDescriptor(device, config, lutRenderer, bindGroupLayout));\n        return new SkyWithLutsComputeRenderer(\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    protected makeBindGroup(config: SkyAtmosphereComputeRendererResizeConfig): GPUBindGroup {\n        return makeWithLutsBindGroup(this.lutRenderer.resources, this.bindGroupLayout, this.lutRenderer.usesCustomUniforms, this.makeExternalBindGroupEntries(config));\n    }\n\n    public renderLutsAndSky(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, forceConstantLutRendering?: boolean) {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, false, forceConstantLutRendering, false);\n        this.renderSky(passEncoder);\n    }\n}\n\n/**\n * A sky / atmosphere renderer that renders the sky using full-resolution ray marching.\n * It uses `GPUComputePipeline`s to render the sky / atmosphere.\n */\nexport class SkyRayMarchComputeRenderer extends SkyComputeRenderer {\n    private constructor(\n        lutRenderer: SkyAtmosphereLutRenderer,\n        bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPUComputePipeline,\n        config: SkyAtmosphereComputeRendererConfig,\n    ) {\n        super(lutRenderer, bindGroupLayout, pipeline, config, true);\n    }\n\n    private static makeBindGroupLayout(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, resources: SkyAtmosphereResources, rayMarchDistantSky: boolean): GPUBindGroupLayout {\n        return makeRayMarchBindGroupLayout(device, config, this.makeExternalBindGroupLayoutEntries(config), resources, rayMarchDistantSky, GPUShaderStage.COMPUTE);\n    }\n\n    private static makeRayMarchPipelineDescriptor(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, lutRenderer: SkyAtmosphereLutRenderer, renderSkyRaymarchingBindGroupLayout: GPUBindGroupLayout, rayMarchDistantSky: boolean): GPUComputePipelineDescriptor {\n        const constants: Record<string, GPUPipelineConstantValue> = {\n            ...makeRayMarchConstantsBase(config, lutRenderer, rayMarchDistantSky),\n            USE_COLORED_TRANSMISSION: Number(config.skyRenderer.rayMarch?.useColoredTransmittance ?? true),\n        };\n\n        const module = device.createShaderModule({\n            code: (rayMarchDistantSky ? makeRenderSkyRaymarchingShaderCode : makeRenderSkyLutAndRaymarchingShaderCode)(config.skyRenderer.renderTarget.texture.format, config.shadow?.wgslCode, config.customUniformsSource?.wgslCode, config.mieHgDrainePhase?.constantDropletDiameter),\n        });\n\n        return {\n            label: `Render sky raymarching pipeline [${lutRenderer.resources.label}]`,\n            layout: device.createPipelineLayout({\n                label: 'Render sky raymarching pipeline layout',\n                bindGroupLayouts: [\n                    renderSkyRaymarchingBindGroupLayout,\n                    ...(config.shadow?.bindGroupLayouts ?? []),\n                    ...(config.customUniformsSource?.bindGroupLayouts ?? []),\n                ],\n            }),\n            compute: {\n                module,\n                entryPoint: 'render_sky_atmosphere',\n                constants,\n            },\n        };\n    }\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereComputeRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyRayMarchComputeRenderer> {\n        const rayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources, rayMarchDistantSky);\n        const pipelines = await device.createComputePipelineAsync(this.makeRayMarchPipelineDescriptor(device, config, lutRenderer, bindGroupLayout, rayMarchDistantSky));\n        return new SkyRayMarchComputeRenderer(\n            lutRenderer,\n            bindGroupLayout,\n            pipelines,\n            config,\n        );\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereComputeRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyRayMarchComputeRenderer {\n        const rayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources, rayMarchDistantSky);\n        const pipelines = device.createComputePipeline(this.makeRayMarchPipelineDescriptor(device, config, lutRenderer, bindGroupLayout, rayMarchDistantSky));\n        return new SkyRayMarchComputeRenderer(\n            lutRenderer,\n            bindGroupLayout,\n            pipelines,\n            config,\n        );\n    }\n\n    protected makeBindGroup(config: SkyAtmosphereComputeRendererResizeConfig): GPUBindGroup {\n        return makeRayMarchBindGroup(this.lutRenderer.resources, this.bindGroupLayout, this.lutRenderer.usesCustomUniforms, this.makeExternalBindGroupEntries(config), this.rayMarchDistantSky);\n    }\n\n    public renderLutsAndSky(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, forceConstantLutRendering?: boolean) {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, true, forceConstantLutRendering, !this.rayMarchDistantSky);\n        this.renderSky(passEncoder);\n    }\n\n    get rayMarchDistantSky() {\n        return this.doesRayMarchDistantSky;\n    }\n}\n\n/**\n * A {@link SkyAtmosphereLutRenderer} that uses `GPUComputePipeline`s to render the sky / atmosphere.\n */\nexport class SkyAtmosphereComputeRenderer implements SkyAtmosphereRenderer {\n    private constructor(\n        private lutRenderer: SkyAtmosphereLutRenderer,\n        private withLutsRenderer: SkyWithLutsComputeRenderer,\n        private rayMarchRenderer: SkyRayMarchComputeRenderer,\n        public defaultToFullResolutionRayMarch: boolean,\n    ) {}\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereComputeRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer? : SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyAtmosphereComputeRenderer> {\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const [withLutsRenderer, rayMarchRenderer] = await Promise.all([SkyWithLutsComputeRenderer.createAsync(device, config, lutRenderer), SkyRayMarchComputeRenderer.createAsync(device, config, lutRenderer)]);\n        return new SkyAtmosphereComputeRenderer(lutRenderer, withLutsRenderer, rayMarchRenderer, config.skyRenderer.defaultToPerPixelRayMarch ?? false);\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereComputeRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereComputeRendererConfig, existingLutRenderer? : SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyAtmosphereComputeRenderer {\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        return new SkyAtmosphereComputeRenderer(lutRenderer, SkyWithLutsComputeRenderer.create(device, config, lutRenderer), SkyRayMarchComputeRenderer.create(device, config, lutRenderer), config.skyRenderer.defaultToPerPixelRayMarch ?? false);\n    }\n\n    /**\n     * Replaces potentially screen-size dependent external resources (back buffer, depth buffer, and render target) in the internal bind groups.\n     *\n     * @param config Configuration of external resources.\n     */\n    public onResize(config: SkyAtmosphereComputeRendererResizeConfig) {\n        this.withLutsRenderer.onResize(config);\n        this.rayMarchRenderer.onResize(config);\n    }\n\n    /**\n     * Renders the sky / atmosphere using precomputed lookup tables.\n     *\n     * Requires the sky view and aerial perspective lookup tables to be initialized.\n     * To initialize these lookup tables, call {@link renderDynamicLuts}.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode the pass with. Can be the same encoder used to initialize the sky view and aerial perspective lookup tables. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderDynamicLuts}: To initialize the lookup tables required, call this function.\n     */\n    public renderSkyWithLuts(passEncoder: GPUComputePassEncoder) {\n        this.withLutsRenderer.renderSky(passEncoder);\n    }\n\n    /**\n     * Renders the sky / atmosphere using full-resolution ray marching.\n     *\n     * Requires the transmittance and multiple scattering lookup tables to be initialized.\n     * Either initialize these lookup tables in the constructor using {@link SkyAtmosphereRendererConfig.initializeConstantLuts}, or call {@link renderConstantLuts}.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode the pass with. Can be the same encoder used to initialize the transmittance and multiple scattering lookup tables. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the lookup tables required, call this function.\n     */\n    public renderSkyRaymarching(passEncoder: GPUComputePassEncoder) {\n        this.rayMarchRenderer.renderSky(passEncoder);\n    }\n\n    /**\n     * Renders the sky / atmosphere using either lookup tables or full-resolution ray marching, as well as all look up tables required by the respective approach.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode the sky / atmosphere rendering pass with. The encoder is not `end()`ed by this function.\n     * @param useFullResolutionRayMarch If this is true, full-resolution ray marching will be used to render the sky / atmosphere. Defaults to {@link defaultToFullResolutionRayMarch}.\n     *\n     * @see {@link renderSkyWithLuts}: Renders the sky with lookup tables.\n     * @see {@link renderSkyRaymarching}: Renders the sky with full-resolution ray marching.\n     */\n    public renderSky(passEncoder: GPUComputePassEncoder, useFullResolutionRayMarch?: boolean) {\n        if (useFullResolutionRayMarch ?? this.defaultToFullResolutionRayMarch) {\n            this.renderSkyRaymarching(passEncoder);\n        } else {\n            this.renderSkyWithLuts(passEncoder);\n        }\n    }\n\n    /**\n     * Renders the sky / atmosphere using either lookup tables or full-resolution ray marching, as well as all look up tables required by the respective approach.\n     *\n     * To initialize or update the transmittance and multiple scattering lookup tables, pass new {@link Atmosphere} paramters to this function or use the `forceConstantLutRendering` parameter.\n     *\n     * @param passEncoder A `GPUComputePassEncoder` to encode passes with. The encoder is not `end()`ed by this function.\n     * @param uniforms {@link Uniforms} to use for this frame. If this is given, the internal uniform buffer will be updated using {@link updateUniforms}.\n     * @param atmosphere {@link Atmosphere} parameters to use for this frame. If this is given, the internal uniform buffer storing the {@link Atmosphere} parameters will be updated and the transmittance and multiple scattering lookup tables will be rendered.\n     * @param useFullResolutionRayMarch If this is true, full-resolution ray marching will be used to render the sky / atmosphere. In that case, the sky view and aerial perspective lookup tables will not be rendered. Defaults to {@link defaultToFullResolutionRayMarch}.\n     * @param forceConstantLutRendering If this is true, the transmittance and multiple scattering lookup tables will be rendered regardless of whether the `atmosphere` parameter is `undefined` or not.\n     *\n     * @see {@link renderLuts}: Renders the lookup tables required for rendering the sky / atmosphere.\n     * @see {@link renderSky}: Renders the sky / atmosphere using either low-resolution lookup tables or full-resolution ray marching.\n     */\n    public renderLutsAndSky(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, useFullResolutionRayMarch?: boolean, forceConstantLutRendering?: boolean) {\n        const useRayMarch = useFullResolutionRayMarch ?? this.defaultToFullResolutionRayMarch;\n        this.renderLuts(passEncoder, uniforms, atmosphere, useRayMarch, forceConstantLutRendering, !this.rayMarchRenderer.rayMarchDistantSky);\n        this.renderSky(passEncoder, useRayMarch);\n    }\n\n    public updateAtmosphere(atmosphere: Atmosphere): void {\n        this.lutRenderer.updateAtmosphere(atmosphere);\n    }\n\n    public updateUniforms(uniforms: Uniforms): void {\n        this.lutRenderer.updateUniforms(uniforms);\n    }\n\n    public renderTransmittanceLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderTransmittanceLut(passEncoder);\n    }\n\n    public renderMultiScatteringLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderMultiScatteringLut(passEncoder);\n    }\n\n    public renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere): void {\n        this.lutRenderer.renderConstantLuts(passEncoder, atmosphere);\n    }\n\n    public renderSkyViewLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderSkyViewLut(passEncoder);\n    }\n\n    public renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderAerialPerspectiveLut(passEncoder);\n    }\n\n    public renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms): void {\n        this.lutRenderer.renderDynamicLuts(passEncoder, uniforms);\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, useFullResolutionRayMarch?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, useFullResolutionRayMarch, forceConstantLutRendering, forceSkyViewLutRendering);\n    }\n\n    get resources(): SkyAtmosphereResources {\n        return this.lutRenderer.resources;\n    }\n}\n","/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nimport { Atmosphere } from './atmosphere.js';\nimport { SkyAtmosphereRasterRendererConfig } from './config.js';\nimport { SkyAtmosphereRenderer, SkyAtmosphereLutRenderer } from './lut-renderer.js';\nimport { SkyAtmospherePipelines } from './pipelines.js';\nimport { SkyAtmosphereResources } from './resources.js';\nimport { makeRenderSkyLutAndRaymarchingShaderCode, makeRenderSkyRaymarchingShaderCode, makeRenderSkyWithLutsShaderCode } from './shaders.js';\nimport { makeRayMarchBindGroup, makeRayMarchBindGroupLayout, makeRayMarchConstantsBase, makeWithLutsBindGroup, makeWithLutsBindGroupLayout, makeWithLutsConstants } from './sky-renderer-utils.js';\nimport { Uniforms } from './uniforms.js';\nimport { RenderPass } from './util.js';\n\nabstract class SkyRasterRenderer implements SkyAtmosphereRenderer {\n    private pass: RenderPass;\n    private bundle?: GPURenderBundle;\n    protected doesRayMarchDistantSky: boolean;\n\n    constructor(\n        readonly targetFormats: GPUTextureFormat[],\n        readonly lutRenderer: SkyAtmosphereLutRenderer,\n        protected bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPURenderPipeline,\n        config: SkyAtmosphereRasterRendererConfig,\n        isRayMarchPass: boolean,\n    ) {\n        this.doesRayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n\n        const bindGroup = this.makeBindGroup(config.skyRenderer.depthBuffer.view ?? config.skyRenderer.depthBuffer.texture);\n\n        this.pass = new RenderPass(\n            pipeline,\n            [\n                bindGroup,\n                ...(isRayMarchPass ? config.shadow?.bindGroups ?? [] : []),\n                ...(config.customUniformsSource?.bindGroups ?? []),\n            ],\n        );\n\n        if (config.skyRenderer.recordInternalRenderBundles ?? true) {\n            this.bundle = this.recordBundle();\n        }\n    }\n\n    protected static makeBlendStates() {\n        return {\n            single: {\n                color: {\n                    operation: 'add',\n                    srcFactor: 'one',\n                    dstFactor: 'one-minus-src-alpha',\n                },\n                alpha: {\n                    operation: 'add',\n                    srcFactor: 'zero',\n                    dstFactor: 'one',\n                },\n            } as GPUBlendState,\n            dual: {\n                color: {\n                    operation: 'add',\n                    srcFactor: 'one',\n                    dstFactor: 'src1',\n                },\n                alpha: {\n                    operation: 'add',\n                    srcFactor: 'zero',\n                    dstFactor: 'one',\n                },\n            } as GPUBlendState,\n        };\n    }\n\n    protected static makeExternalBindGroupLayoutEntries(config: SkyAtmosphereRasterRendererConfig): GPUBindGroupLayoutEntry[] {\n        return [\n            {\n                binding: 6,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'unfilterable-float',\n                    viewDimension: config.skyRenderer.depthBuffer.texture.dimension,\n                    multisampled: false,\n                },\n            },\n        ];\n    }\n\n    protected makeExternalBindGroupEntries(depthBuffer: GPUTextureView | GPUTexture): GPUBindGroupEntry[] {\n        return [\n            {\n                binding: 6,\n                resource: depthBuffer instanceof GPUTextureView ? depthBuffer : depthBuffer.createView(depthBuffer.format.includes('depth') ? {\n                    aspect: 'depth-only',\n                } : {}),\n            },\n        ];\n    }\n\n    protected abstract makeBindGroup(depthBuffer: GPUTextureView | GPUTexture): GPUBindGroup;\n\n    /**\n     * Replaces potentially screen-size dependent external resources (depth buffer) in the internal bind groups.\n     *\n     * @param depthBuffer The depth buffer to limit the ray marching distance when rendering the sky / atmosphere.\n     *                    If this is a textue, a texture view will be created.\n     *                    If this is a texture view, it must be allowed to be bound as a `texture<f32>`.\n     *                    I.e., if the texture has a depth-stencil format, the texture view must be a `\"depth-only\"` view.\n     */\n    public onResize(depthBuffer: GPUTextureView | GPUTexture) {\n        this.pass.replaceBindGroup(0, this.makeBindGroup(depthBuffer));\n        if (this.bundle) {\n            this.bundle = this.recordBundle();\n        }\n    }\n\n    /**\n     * Renders the sky / atmosphere.\n     *\n     * @param passEncoder A `GPURenderPassEncoder` or `GPURenderBundleEncoder` to encode the pass with. The encoder is not `end()`ed by this function.\n     */\n    public renderSky(passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder) {\n        if (passEncoder instanceof GPURenderPassEncoder && this.bundle) {\n            passEncoder.executeBundles([this.bundle]);\n        } else {\n            this.pass.encode(passEncoder);\n        }\n    }\n\n    private recordBundle(): GPURenderBundle {\n        const encoder = this.lutRenderer.resources.device.createRenderBundleEncoder({\n            label: 'Render sky bundle',\n            colorFormats: this.targetFormats,\n        });\n        this.renderSky(encoder);\n        return encoder.finish();\n    }\n\n    public updateAtmosphere(atmosphere: Atmosphere): void {\n        this.lutRenderer.updateAtmosphere(atmosphere);\n    }\n\n    public updateUniforms(uniforms: Uniforms): void {\n        this.lutRenderer.updateUniforms(uniforms);\n    }\n\n    public renderTransmittanceLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderTransmittanceLut(passEncoder);\n    }\n\n    public renderMultiScatteringLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderMultiScatteringLut(passEncoder);\n    }\n\n    public renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere): void {\n        this.lutRenderer.renderConstantLuts(passEncoder, atmosphere);\n    }\n\n    public renderSkyViewLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderSkyViewLut(passEncoder);\n    }\n\n    public renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderAerialPerspectiveLut(passEncoder);\n    }\n\n    public renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms): void {\n        this.lutRenderer.renderDynamicLuts(passEncoder, uniforms);\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, skipDynamicLutRendering?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, skipDynamicLutRendering, forceConstantLutRendering, forceSkyViewLutRendering);\n    }\n\n    get resources(): SkyAtmosphereResources {\n        return this.lutRenderer.resources;\n    }\n}\n\n/**\n * A sky / atmosphere renderer that renders the sky based on lookup tables.\n * It uses `GPURenderPipeline`s to render the sky / atmosphere.\n */\nexport class SkyWithLutsRasterRenderer extends SkyRasterRenderer {\n    private constructor(\n        readonly targetFormats: GPUTextureFormat[],\n        readonly lutRenderer: SkyAtmosphereLutRenderer,\n        protected bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPURenderPipeline,\n        config: SkyAtmosphereRasterRendererConfig,\n    ) {\n        super(targetFormats, lutRenderer, bindGroupLayout, pipeline, config, false);\n    }\n\n    private static makeBindGroupLayout(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, resources: SkyAtmosphereResources): GPUBindGroupLayout {\n        return makeWithLutsBindGroupLayout(device, config, this.makeExternalBindGroupLayoutEntries(config), resources, GPUShaderStage.FRAGMENT);\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, lutRenderer: SkyAtmosphereLutRenderer, bindGroupLayout: GPUBindGroupLayout, blendState: GPUBlendState, dualBlendState: GPUBlendState, useDualSourceBlending: boolean): [GPURenderPipelineDescriptor, GPUTextureFormat[]] {\n        const writeTransmissionOnlyOnPerPixelRayMarch = config.skyRenderer.writeTransmissionOnlyOnPerPixelRayMarch ?? true;\n        const useTwoTargets = config.skyRenderer.transmissionFormat && !useDualSourceBlending && !writeTransmissionOnlyOnPerPixelRayMarch;\n        const targets: GPUColorTargetState[] = [\n            {\n                format: config.skyRenderer.renderTargetFormat,\n                writeMask: GPUColorWrite.ALL,\n            },\n        ];\n        if (useTwoTargets) {\n            targets.push({ format: config.skyRenderer.transmissionFormat!, });\n        } else {\n            targets[0].blend = useDualSourceBlending && !writeTransmissionOnlyOnPerPixelRayMarch ? dualBlendState : blendState;\n        }\n\n        let code = makeRenderSkyWithLutsShaderCode('rgba16float', config.customUniformsSource?.wgslCode);\n        if (useDualSourceBlending && !writeTransmissionOnlyOnPerPixelRayMarch) {\n            code = `enable dual_source_blending;\\n${code}`;\n            code = code.replace('@location(0)', '@location(0) @blend_src(0)');\n            code = code.replace('@location(1)', '@location(0) @blend_src(1)');\n        } else if (targets.length !== 2) {\n            code = code.replace('@location(1) transmittance: vec4<f32>,', '');\n            code = code.replace(\n                'RenderSkyFragment(vec4(result.rgb, 1.0), vec4(vec3(result.a), 1.0))',\n                'RenderSkyFragment(result)',\n            );\n        }\n\n        const module = device.createShaderModule({\n            label: 'Render sky with LUTs',\n            code,\n        });\n\n        return [\n            {\n                label: `Render sky with LUTs pipeline [${lutRenderer.resources.label}]`,\n                layout: device.createPipelineLayout({\n                    label: 'Render sky with LUTs pipeline layout',\n                    bindGroupLayouts: [\n                        bindGroupLayout,\n                        ...(config.customUniformsSource?.bindGroupLayouts ?? []),\n                    ],\n                }),\n                vertex: {\n                    module,\n                },\n                fragment: {\n                    module,\n                    constants: makeWithLutsConstants(config, lutRenderer),\n                    targets,\n                },\n            },\n            targets.map(t => t.format),\n        ];\n    }\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereComputeRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRasterRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyWithLutsRasterRenderer> {\n        const useDualSourceBlending = device.features.has('dual-source-blending') && (config.skyRenderer.rayMarch?.useColoredTransmittance ?? false);\n        if (!useDualSourceBlending && config.skyRenderer.rayMarch?.useColoredTransmittance) {\n            console.warn('[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled');\n        }\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources);\n        const blendStates = this.makeBlendStates();\n        const [descriptor, targetFormats] = this.makePipelineDescriptor(device, config, lutRenderer, bindGroupLayout, blendStates.single, blendStates.dual, useDualSourceBlending);\n        const pipeline = await device.createRenderPipelineAsync(descriptor);\n        return new SkyWithLutsRasterRenderer(\n            targetFormats,\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereComputeRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRasterRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyWithLutsRasterRenderer {\n        const useDualSourceBlending = device.features.has('dual-source-blending') && (config.skyRenderer.rayMarch?.useColoredTransmittance ?? false);\n        if (!useDualSourceBlending && config.skyRenderer.rayMarch?.useColoredTransmittance) {\n            console.warn('[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled');\n        }\n\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources);\n        const blendStates = this.makeBlendStates();\n        const [descriptor, targetFormats] = this.makePipelineDescriptor(device, config, lutRenderer, bindGroupLayout, blendStates.single, blendStates.dual, useDualSourceBlending);\n        const pipeline = device.createRenderPipeline(descriptor);\n        return new SkyWithLutsRasterRenderer(\n            targetFormats,\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    protected makeBindGroup(depthBuffer: GPUTextureView | GPUTexture): GPUBindGroup {\n        return makeWithLutsBindGroup(this.lutRenderer.resources, this.bindGroupLayout, this.lutRenderer.usesCustomUniforms, this.makeExternalBindGroupEntries(depthBuffer));\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, skipDynamicLutRendering?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, skipDynamicLutRendering ?? false, forceConstantLutRendering, forceSkyViewLutRendering);\n    }\n}\n\n/**\n * A sky / atmosphere renderer that renders the sky using full-resolution ray marching.\n * It uses `GPURenderPipeline`s to render the sky / atmosphere.\n */\nexport class SkyRayMarchRasterRenderer extends SkyRasterRenderer {\n    private constructor(\n        readonly targetFormats: GPUTextureFormat[],\n        readonly lutRenderer: SkyAtmosphereLutRenderer,\n        protected bindGroupLayout: GPUBindGroupLayout,\n        pipeline: GPURenderPipeline,\n        config: SkyAtmosphereRasterRendererConfig,\n    ) {\n        super(targetFormats, lutRenderer, bindGroupLayout, pipeline, config, true);\n    }\n\n    private static makeBindGroupLayout(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, resources: SkyAtmosphereResources, rayMarchDistantSky: boolean): GPUBindGroupLayout {\n        return makeRayMarchBindGroupLayout(device, config, this.makeExternalBindGroupLayoutEntries(config), resources, rayMarchDistantSky, GPUShaderStage.FRAGMENT);\n    }\n\n    private static makePipelineDescriptor(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, lutRenderer: SkyAtmosphereLutRenderer, bindGroupLayout: GPUBindGroupLayout, rayMarchDistantSky: boolean, blendState: GPUBlendState, dualBlendState: GPUBlendState, useDualSourceBlending: boolean): [GPURenderPipelineDescriptor, GPUTextureFormat[]] {\n        const useTwoTargets = config.skyRenderer.transmissionFormat && !useDualSourceBlending;\n            const targets: GPUColorTargetState[] = [\n                {\n                    format: config.skyRenderer.renderTargetFormat,\n                    writeMask: GPUColorWrite.ALL,\n                },\n            ];\n            if (useTwoTargets) {\n                targets.push({ format: config.skyRenderer.transmissionFormat!, });\n            } else {\n                targets[0].blend = useDualSourceBlending ? dualBlendState : blendState;\n            }\n\n            let code = (rayMarchDistantSky ? makeRenderSkyRaymarchingShaderCode : makeRenderSkyLutAndRaymarchingShaderCode)('rgba16float', config.shadow?.wgslCode, config.customUniformsSource?.wgslCode, config.mieHgDrainePhase?.constantDropletDiameter);\n            if (useDualSourceBlending) {\n                code = code.replace('@location(0)', '@location(0) @blend_src(0)');\n                code = code.replace('@location(1)', '@location(0) @blend_src(1)');\n            } else if (targets.length !== 2) {\n                code = code.replace('@location(1) transmittance: vec4<f32>,', '');\n                code = code.replace(\n                    'RenderSkyFragment(result.luminance, result.transmittance)',\n                    'RenderSkyFragment(vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))))',\n                );\n            }\n            const module = device.createShaderModule({\n                label: 'Render sky raymarching',\n                code: `${useDualSourceBlending ? 'enable dual_source_blending;\\n' : ''}${code}`,\n            });\n\n            return [\n                {\n                    label: `Render sky raymarching pipeline [${lutRenderer.resources.label}]`,\n                    layout: device.createPipelineLayout({\n                        label: `Render sky raymarching pipeline layout [${lutRenderer.resources.label}]`,\n                        bindGroupLayouts: [\n                            bindGroupLayout,\n                            ...(config.shadow?.bindGroupLayouts || []),\n                            ...(config.customUniformsSource?.bindGroupLayouts ?? []),\n                        ],\n                    }),\n                    vertex: {\n                        module,\n                    },\n                    fragment: {\n                        module,\n                        constants: makeRayMarchConstantsBase(config, lutRenderer, rayMarchDistantSky),\n                        targets,\n                    },\n                },\n                targets.map(t => t.format),\n            ];\n    }\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereComputeRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRasterRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyRayMarchRasterRenderer> {\n        const useDualSourceBlending = device.features.has('dual-source-blending') && (config.skyRenderer.rayMarch?.useColoredTransmittance ?? false);\n        if (!useDualSourceBlending && config.skyRenderer.rayMarch?.useColoredTransmittance) {\n            console.warn('[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled');\n        }\n        const rayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources, rayMarchDistantSky);\n        const blendStates = this.makeBlendStates();\n        const [descriptor, targetFormats] = this.makePipelineDescriptor(device, config, lutRenderer, bindGroupLayout, rayMarchDistantSky, blendStates.single, blendStates.dual, useDualSourceBlending);\n        const pipeline = await device.createRenderPipelineAsync(descriptor);\n        return new SkyRayMarchRasterRenderer(\n            targetFormats,\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereComputeRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRasterRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyRayMarchRasterRenderer {\n        const useDualSourceBlending = device.features.has('dual-source-blending') && (config.skyRenderer.rayMarch?.useColoredTransmittance ?? false);\n        if (!useDualSourceBlending && config.skyRenderer.rayMarch?.useColoredTransmittance) {\n            console.warn('[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled');\n        }\n        const rayMarchDistantSky = config.skyRenderer.rayMarch?.rayMarchDistantSky ?? true;\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        const bindGroupLayout = this.makeBindGroupLayout(device, config, lutRenderer.resources, rayMarchDistantSky);\n        const blendStates = this.makeBlendStates();\n        const [descriptor, targetFormats] = this.makePipelineDescriptor(device, config, lutRenderer, bindGroupLayout, rayMarchDistantSky, blendStates.single, blendStates.dual, useDualSourceBlending);\n        const pipeline = device.createRenderPipeline(descriptor);\n        return new SkyRayMarchRasterRenderer(\n            targetFormats,\n            lutRenderer,\n            bindGroupLayout,\n            pipeline,\n            config,\n        );\n    }\n\n    protected makeBindGroup(depthBuffer: GPUTextureView | GPUTexture): GPUBindGroup {\n        return makeRayMarchBindGroup(this.lutRenderer.resources, this.bindGroupLayout, this.lutRenderer.usesCustomUniforms, this.makeExternalBindGroupEntries(depthBuffer), this.rayMarchDistantSky);\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, skipDynamicLutRendering?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean): void {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, skipDynamicLutRendering ?? true, forceConstantLutRendering, !this.rayMarchDistantSky || forceSkyViewLutRendering);\n    }\n\n    get rayMarchDistantSky() {\n        return this.doesRayMarchDistantSky;\n    }\n}\n\n/**\n * A sky / atmosphere renderer that uses `GPURenderPipeline`s to render the sky / atmosphere.\n */\nexport class SkyAtmosphereRasterRenderer implements SkyAtmosphereRenderer {\n    private constructor(\n        readonly lutRenderer: SkyAtmosphereLutRenderer,\n        readonly withLutsRenderer: SkyWithLutsRasterRenderer,\n        readonly rayMarchRenderer: SkyRayMarchRasterRenderer,\n        public defaultToFullResolutionRayMarch: boolean,\n    ) {}\n\n    /**\n     * Asynchronously creates a {@link SkyAtmosphereRasterRenderer}.\n     *\n     * All pipelines used by this renderer are created asynchronously.\n     *\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static async createAsync(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): Promise<SkyAtmosphereRasterRenderer> {\n        const lutRenderer = existingLutRenderer ?? await SkyAtmosphereLutRenderer.createAsync(device, config, existingPipelines, existingResources);\n        const [withLutsRenderer, rayMarchRenderer] = await Promise.all([SkyWithLutsRasterRenderer.createAsync(device, config, lutRenderer), SkyRayMarchRasterRenderer.createAsync(device, config, lutRenderer)]);\n        return new SkyAtmosphereRasterRenderer(lutRenderer, withLutsRenderer, rayMarchRenderer, config.skyRenderer.defaultToPerPixelRayMarch ?? false);\n    }\n\n    /**\n     * Creates a {@link SkyAtmosphereRasterRenderer}.\n     * @param device The `GPUDevice` used to create internal resources (textures, pipelines, etc.).\n     * @param config A {@link SkyAtmosphereRendererConfig} used to configure internal resources and behavior.\n     * @param existingLutRenderer If this is defined, no new internal {@link SkyAtmosphereLutRenderer} will be created. Instead, the existing one is used.\n     * @param existingPipelines If this is defined, no new pipelines for rendering the internal lookup tables will be created. Instead, the existing pipelines given will be reused. The existing pipelines must be compatible with the {@link SkyAtmosphereRendererConfig}. Especially, {@link SkyAtmosphereRendererConfig.lookUpTables} and {@link SkyAtmosphereRendererConfig.shadow} should be the same.\n     * @param existingResources If this is defined, no new resources (buffers, textures, samplers) will be created. Instead, the existing resources given will be used.\n     */\n    static create(device: GPUDevice, config: SkyAtmosphereRasterRendererConfig, existingLutRenderer?: SkyAtmosphereLutRenderer, existingPipelines?: SkyAtmospherePipelines, existingResources?: SkyAtmosphereResources): SkyAtmosphereRasterRenderer {\n        const lutRenderer = existingLutRenderer ?? SkyAtmosphereLutRenderer.create(device, config, existingPipelines, existingResources);\n        return new SkyAtmosphereRasterRenderer(lutRenderer, SkyWithLutsRasterRenderer.create(device, config, lutRenderer), SkyRayMarchRasterRenderer.create(device, config, lutRenderer), config.skyRenderer.defaultToPerPixelRayMarch ?? false);\n    }\n\n    /**\n     * Replaces potentially screen-size dependent external resources (depth buffer) in the internal bind groups.\n     *\n     * @param depthBuffer The depth buffer to limit the ray marching distance when rendering the sky / atmosphere.\n     *                    If this is a textue, a texture view will be created.\n     *                    If this is a texture view, it must be allowed to be bound as a `texture<f32>`.\n     *                    I.e., if the texture has a depth-stencil format, the texture view must be a `\"depth-only\"` view.\n     */\n    public onResize(depthBuffer: GPUTextureView | GPUTexture) {\n        this.withLutsRenderer.onResize(depthBuffer);\n        this.rayMarchRenderer.onResize(depthBuffer);\n    }\n\n    /**\n     * Renders the sky / atmosphere using precomputed lookup tables.\n     *\n     * Requires the sky view and aerial perspective lookup tables to be initialized.\n     * To initialize these lookup tables, call {@link renderDynamicLuts}.\n     *\n     * @param passEncoder A `GPURenderPassEncoder` or `GPURenderBundleEncoder` to encode the pass with. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderDynamicLuts}: To initialize the lookup tables required, call this function.\n     */\n    public renderSkyWithLuts(passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder) {\n        this.withLutsRenderer.renderSky(passEncoder);\n    }\n\n    /**\n     * Renders the sky / atmosphere using full-resolution ray marching.\n     *\n     * Requires the transmittance and multiple scattering lookup tables to be initialized.\n     * Either initialize these lookup tables in the constructor using {@link SkyAtmosphereRendererConfig.initializeConstantLuts}, or call {@link renderConstantLuts}.\n     *\n     * @param passEncoder A `GPURenderPassEncoder` or `GPURenderBundleEncoder` to encode the pass with. The encoder is not `end()`ed by this function.\n     *\n     * @see {@link renderConstantLuts}: To initialize the lookup tables required, call this function.\n     */\n    public renderSkyRaymarching(passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder) {\n        this.rayMarchRenderer.renderSky(passEncoder);\n    }\n\n    /**\n     * Renders the sky / atmosphere using either lookup tables or full-resolution ray marching, as well as all look up tables required by the respective approach.\n     *\n     * @param passEncoder A `GPURenderPassEncoder` or `GPURenderBundleEncoder` to encode the sky / atmosphere rendering pass with. The encoder is not `end()`ed by this function.\n     * @param useFullResolutionRayMarch If this is true, full-resolution ray marching will be used to render the sky / atmosphere. Defaults to {@link defaultToFullResolutionRayMarch}.\n     *\n     * @see {@link renderSkyWithLuts}: Renders the sky with lookup tables.\n     * @see {@link renderSkyRaymarching}: Renders the sky with full-resolution ray marching.\n     */\n    public renderSky(passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder, useFullResolutionRayMarch?: boolean) {\n        if (useFullResolutionRayMarch ?? this.defaultToFullResolutionRayMarch) {\n            this.renderSkyRaymarching(passEncoder);\n        } else {\n            this.renderSkyWithLuts(passEncoder);\n        }\n    }\n\n    public updateAtmosphere(atmosphere: Atmosphere): void {\n        this.lutRenderer.updateAtmosphere(atmosphere);\n    }\n\n    public updateUniforms(uniforms: Uniforms): void {\n        this.lutRenderer.updateUniforms(uniforms);\n    }\n\n    public renderTransmittanceLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderTransmittanceLut(passEncoder);\n    }\n\n    public renderMultiScatteringLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderMultiScatteringLut(passEncoder);\n    }\n\n    public renderConstantLuts(passEncoder: GPUComputePassEncoder, atmosphere?: Atmosphere): void {\n        this.lutRenderer.renderConstantLuts(passEncoder, atmosphere);\n    }\n\n    public renderSkyViewLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderSkyViewLut(passEncoder);\n    }\n\n    public renderAerialPerspectiveLut(passEncoder: GPUComputePassEncoder): void {\n        this.lutRenderer.renderAerialPerspectiveLut(passEncoder);\n    }\n\n    public renderDynamicLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms): void {\n        this.lutRenderer.renderDynamicLuts(passEncoder, uniforms);\n    }\n\n    public renderLuts(passEncoder: GPUComputePassEncoder, uniforms?: Uniforms, atmosphere?: Atmosphere, useFullResolutionRayMarch?: boolean, forceConstantLutRendering?: boolean, forceSkyViewLutRendering?: boolean) {\n        this.lutRenderer.renderLuts(passEncoder, uniforms, atmosphere, useFullResolutionRayMarch, forceConstantLutRendering, !this.rayMarchRenderer.rayMarchDistantSky || forceSkyViewLutRendering);\n    }\n\n    get resources(): SkyAtmosphereResources {\n        return this.lutRenderer.resources;\n    }\n}"],"names":["makeEarthAtmosphere","center","yUp","useHenyeyGreenstein","bottomRadius","height","rayleigh","densityExpScale","scattering","mie","extinction","phaseParam","absorption","layer0","constantTerm","linearTerm","layer1","groundAlbedo","multipleScatteringFactor","LookUpTable","texture","view","constructor","this","createView","label","ComputePass","pipeline","bindGroups","dispatchDimensions","encode","computePassEncoder","resetBindGroups","setPipeline","i","length","setBindGroup","dispatchWorkgroups","replaceBindGroup","index","bindGroup","replaceDispatchDimensions","RenderPass","passEncoder","draw","DEFAULT_TRANSMITTANCE_LUT_SIZE","DEFAULT_MULTISCATTERING_LUT_SIZE","DEFAULT_SKY_VIEW_LUT_SIZE","DEFAULT_AERIAL_PERSPECTIVE_LUT_SIZE","TRANSMITTANCE_LUT_FORMAT","MULTI_SCATTERING_LUT_FORMAT","SKY_VIEW_LUT_FORMAT","AERIAL_PERSPECTIVE_LUT_FORMAT","ATMOSPHERE_BUFFER_SIZE","UNIFORMS_BUFFER_SIZE","SkyAtmosphereResources","device","atmosphereBuffer","uniformsBuffer","lutSampler","transmittanceLut","multiScatteringLut","skyViewLut","aerialPerspectiveLut","atmosphere","config","createBuffer","size","usage","GPUBufferUsage","UNIFORM","COPY_DST","updateAtmosphere","customUniformsSource","undefined","createSampler","addressModeU","addressModeV","addressModeW","minFilter","magFilter","mipmapFilter","lodMinClamp","lodMaxClamp","maxAnisotropy","makeLutSampler","createTexture","lookUpTables","format","GPUTextureUsage","TEXTURE_BINDING","STORAGE_BINDING","dimension","queue","writeBuffer","atmosphereToFloatArray","updateUniforms","uniforms","uniformsToFloatArray","Float32Array","Math","max","camera","inverseProjection","inverseView","position","frameId","screenResolution","rayMarchMinSPP","rayMarchMaxSPP","sun","illuminance","diskAngularDiameter","PI","direction","diskLuminanceScale","moon","map","d","aerialPerspectiveWgsl","blendWgsl","constantsWgsl","customUniformsWgsl","coordinateSystemWgsl","fullScreenVertexShaderWgsl","hgDraineConstWgsl","hgDraineLargeWgsl","hgDraineMid2Wgsl","hgDraineMid1Wgsl","hgDraineSmallWgsl","intersectionWgsl","mediumWgsl","multipleScatteringWgsl","phaseWgsl","sampleSegmentWgsl","shadowBaseWgsl","skyViewWgsl","sunDiskWgsl","uniformsWgsl","uvWgsl","makePhaseShaderCode","constDropletDiameter","base","replace","makeTransmittanceLutShaderCode","transmittanceLutFormat","makeMultiScatteringLutShaderCode","multiScatteringLutFormat","makeShadowShaderCode","shadow","makeSkyViewLutShaderCode","skyViewLutFormat","customUniforms","shader","makeAerialPerspectiveLutShaderCode","aerialPerspectiveLutFormat","makeRenderSkyWithLutsShaderCode","renderTargetFormat","makeRenderSkyRaymarchingShaderCode","makeRenderSkyLutAndRaymarchingShaderCode","TransmittanceLutPipeline","bindGroupLayout","makeBindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","hasDynamicOffset","minBindingSize","storageTexture","access","viewDimension","makePipelineDescriptor","sampleCount","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","constants","SAMPLE_COUNT","createAsync","createComputePipelineAsync","create","createComputePipeline","makeComputePass","resources","Error","createBindGroup","resource","ceil","width","MultiScatteringLutPipeline","sampler","sampleType","multisampled","makeMiePhaseOverrides","miePhaseConfig","mieOverrides","MIE_USE_HG_DRAINE","Number","useConstantDropletDiameter","constantDropletDiameter","SkyViewLutPipeline","skyViewLutSize","multiscatteringLutSize","customUniformsConfig","filter","e","distanceToMaxSampleCount","fromKilometersScaleFactor","useMoon","shadowConfig","wgslCode","SKY_VIEW_LUT_RES_X","SKY_VIEW_LUT_RES_Y","INV_DISTANCE_TO_MAX_SAMPLE_COUNT","MULTI_SCATTERING_LUT_RES_X","MULTI_SCATTERING_LUT_RES_Y","FROM_KM_SCALE","USE_MOON","shadowBindGroups","customUniformsBindGroups","AerialPerspectiveLutPipeline","aerialPerspectiveSliceCount","aerialPerspectiveDistancePerSlice","randomizeSampleOffsets","AP_SLICE_COUNT","AP_DISTANCE_PER_SLICE","RANDOMIZE_SAMPLE_OFFSET","depthOrArrayLayers","aerialPerspectiveInvDistancePerSlice","SkyAtmospherePipelines","transmittanceLutPipeline","multiScatteringLutPipeline","skyViewLutPipeline","aerialPerspectiveLutPipeline","getTransmittanceLutArgs","getMultiScatteringLutArgs","getSkyViewLutArgs","skyRenderer","fromKilometersScale","lights","affectedByShadow","mieHgDrainePhase","getAerialPerspectiveLutArgs","distancePerSlice","randomizeRayOffsets","transmittanceLutArgs","multiScatteringLutArgs","skyViewLutArgs","aerialPerspectiveLutArgs","SkyAtmosphereLutRenderer","pipelines","skipDynamicLutRendering","usesCustomUniforms","transmittanceLutPass","multiScatteringLutPass","skyViewLutPass","aerialPerspectiveLutPass","existingPipelines","existingResources","skyAtmospherePipelines","SkyAtmosphereLutPipelines","defaultToPerPixelRayMarch","lutRenderer","initializeConstantLuts","commandEncoder","createCommandEncoder","beginComputePass","renderConstantLuts","end","submit","finish","renderTransmittanceLut","renderMultiScatteringLut","renderSkyViewLut","renderAerialPerspectiveLut","renderDynamicLuts","renderLuts","forceConstantLutRendering","forceSkyViewLutRendering","makeSkyRendereringBaseLayoutEntries","makeWithLutsBindGroupLayout","externalEntries","renderSkyBindGroupLayoutBaseEntries","v","makeRayMarchBindGroupLayout","rayMarchDistantSky","makeSkyRenderingBaseEntries","makeWithLutsBindGroup","makeRayMarchBindGroup","makeWithLutsConstants","AP_INV_DISTANCE_PER_SLICE","IS_REVERSE_Z","depthBuffer","reverseZ","RENDER_SUN_DISK","renderSunDisk","RENDER_MOON_DISK","renderMoonDisk","LIMB_DARKENING_ON_SUN","applyLimbDarkeningOnSun","LIMB_DARKENING_ON_MOON","applyLimbDarkeningOnMoon","makeRayMarchConstantsBase","rayMarch","SkyComputeRenderer","pass","doesRayMarchDistantSky","isRayMarchPass","makeBindGroup","backBuffer","renderTarget","makeExternalBindGroupLayoutEntries","makeExternalBindGroupEntries","GPUTextureView","includes","aspect","onResize","GPUTexture","renderSky","useFullResolutionRayMarch","SkyWithLutsComputeRenderer","super","makeWithLutsPiplelineDescriptor","renderSkyWithLutsBindGroupLayout","existingLutRenderer","renderLutsAndSky","SkyRayMarchComputeRenderer","makeRayMarchPipelineDescriptor","renderSkyRaymarchingBindGroupLayout","USE_COLORED_TRANSMISSION","useColoredTransmittance","SkyAtmosphereComputeRenderer","withLutsRenderer","rayMarchRenderer","defaultToFullResolutionRayMarch","Promise","all","renderSkyWithLuts","renderSkyRaymarching","useRayMarch","SkyRasterRenderer","targetFormats","bundle","recordInternalRenderBundles","recordBundle","makeBlendStates","single","color","operation","srcFactor","dstFactor","alpha","dual","FRAGMENT","GPURenderPassEncoder","executeBundles","encoder","createRenderBundleEncoder","colorFormats","SkyWithLutsRasterRenderer","blendState","dualBlendState","useDualSourceBlending","writeTransmissionOnlyOnPerPixelRayMarch","useTwoTargets","transmissionFormat","targets","writeMask","GPUColorWrite","ALL","push","blend","vertex","fragment","t","features","has","console","warn","blendStates","descriptor","createRenderPipelineAsync","createRenderPipeline","SkyRayMarchRasterRenderer","SkyAtmosphereRasterRenderer"],"mappings":"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"}