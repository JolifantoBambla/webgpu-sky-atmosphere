function e(e=1,t,n=!0){const i=1.2*e,r=6360*e;return{center:t??[0,n?-r:0,n?0:-r],bottomRadius:r,height:100*e,rayleigh:{densityExpScale:-1/(8*e),scattering:[.005802,.013558,.0331].map((t=>t/e))},mie:{densityExpScale:-1/i,scattering:[.003996,.003996,.003996].map((t=>t/e)),extinction:[.00444,.00444,.00444].map((t=>t/e)),phaseG:.8*e},absorption:{layer0:{height:25*e,constantTerm:-2/3,linearTerm:1/(15*e)},layer1:{constantTerm:8/3,linearTerm:-1/(15*e)},extinction:[65e-5,.001881,85e-6].map((t=>t/e))},groundAlbedo:[.4,.4,.4],multipleScatteringFactor:1}}class t{texture;view;constructor(e){this.texture=e,this.view=e.createView()}}class n{pipeline;bindGroups;dispatchDimensions;constructor(e,t,n){this.pipeline=e,this.bindGroups=t,this.dispatchDimensions=n}encode(e,t=!1){e.setPipeline(this.pipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);if(e.dispatchWorkgroups(...this.dispatchDimensions),t)for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,null)}replaceBindGroup(e,t){this.bindGroups[e]=t}replaceDispatchDimensions(e){this.dispatchDimensions[0]=e[0],this.dispatchDimensions[1]=e[1],this.dispatchDimensions[2]=e[2]}}class i{pipeline;bindGroups;constructor(e,t){this.pipeline=e,this.bindGroups=t}encode(e,t=!1){e.setPipeline(this.pipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);if(e.draw(3),t)for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,null)}replaceBindGroup(e,t){this.bindGroups[e]=t}}const r=[256,64],s=32,a=[192,108],o=[32,32,32],_="rgba16float",l=_,u=_,c=_,m=128,p=224;class d{label;device;atmosphereBuffer;uniformsBuffer;lutSampler;transmittanceLut;multiScatteringLut;skyViewLut;aerialPerspectiveLut;#e;constructor(n,i,d){this.label=i.label??"atmosphere",this.device=n,this.#e=i.atmosphere??e(i.distanceScaleFactor??1),this.atmosphereBuffer=n.createBuffer({label:`atmosphere buffer [${this.label}]`,size:m,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.updateAtmosphere(this.#e),i.customUniformsSource?this.uniformsBuffer=void 0:this.uniformsBuffer=n.createBuffer({label:`config buffer [${this.label}]`,size:p,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.lutSampler=d||function(e){return e.createSampler({label:"LUT sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",minFilter:"linear",magFilter:"linear",mipmapFilter:"linear",lodMinClamp:0,lodMaxClamp:32,maxAnisotropy:1})}(n),this.transmittanceLut=new t(n.createTexture({label:`transmittance LUT [${this.label}]`,size:i.lookUpTables?.transmittanceLut?.size??r,format:i.lookUpTables?.transmittanceLut?.format??_,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})),this.multiScatteringLut=new t(n.createTexture({label:`multi scattering LUT [${this.label}]`,size:i.lookUpTables?.multiScatteringLut?.size??[s,s],format:i.lookUpTables?.multiScatteringLut?.format??l,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})),this.skyViewLut=new t(n.createTexture({label:`sky view LUT [${this.label}]`,size:i.lookUpTables?.skyViewLut?.size??a,format:i.lookUpTables?.skyViewLut?.format??u,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})),this.aerialPerspectiveLut=new t(n.createTexture({label:`aerial perspective LUT [${this.label}]`,size:i.lookUpTables?.aerialPerspectiveLut?.size??o,format:i.lookUpTables?.aerialPerspectiveLut?.format??c,dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}))}get atmosphere(){return this.#e}updateAtmosphere(e){this.#e=e,this.device.queue.writeBuffer(this.atmosphereBuffer,0,h(this.#e))}updateUniforms(e){this.uniformsBuffer&&this.device.queue.writeBuffer(this.uniformsBuffer,0,f(e))}}function h(e){return new Float32Array([e.rayleigh.scattering[0],e.rayleigh.scattering[1],e.rayleigh.scattering[2],e.rayleigh.densityExpScale,e.mie.scattering[0],e.mie.scattering[1],e.mie.scattering[2],e.mie.densityExpScale,e.mie.extinction[0],e.mie.extinction[1],e.mie.extinction[2],e.mie.phaseG,Math.max(e.mie.extinction[0]-e.mie.scattering[0],0),Math.max(e.mie.extinction[1]-e.mie.scattering[1],0),Math.max(e.mie.extinction[2]-e.mie.scattering[2],0),e.absorption.layer0.height,e.absorption.layer0.constantTerm,e.absorption.layer0.linearTerm,e.absorption.layer1.constantTerm,e.absorption.layer1.linearTerm,e.absorption.extinction[0],e.absorption.extinction[1],e.absorption.extinction[2],e.bottomRadius,e.groundAlbedo[0],e.groundAlbedo[1],e.groundAlbedo[2],e.bottomRadius+Math.max(e.height,0),...e.center,e.multipleScatteringFactor])}function f(e){return new Float32Array([...e.camera.inverseProjection,...e.camera.inverseView,...e.camera.position,e.frameId??0,...e.screenResolution,e.rayMarchMinSPP??14,e.rayMarchMaxSPP??30,...e.sun.illuminance??[1,1,1],e.sun.diskAngularDiameter??Math.PI/180*.545,...e.sun.direction,e.sun.diskLuminanceScale??1,...e.moon?.illuminance??[1,1,1],e.moon?.diskAngularDiameter??.568*Math.PI/180,...e.moon?.direction??e.sun.direction.map((e=>-1*e)),e.moon?.diskLuminanceScale??1])}var g="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride AP_SLICE_COUNT: f32 = 32.0;\noverride AP_DISTANCE_PER_SLICE: f32 = 4.0;\n\noverride AP_INV_DISTANCE_PER_SLICE: f32 = 1.0 / AP_DISTANCE_PER_SLICE;\n\nfn aerial_perspective_depth_to_slice(depth: f32) -> f32 {\n\treturn depth * AP_INV_DISTANCE_PER_SLICE;\n}\nfn aerial_perspective_slice_to_depth(slice: f32) -> f32 {\n\treturn slice * AP_DISTANCE_PER_SLICE;\n}\n",v="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nfn blend(pix: vec2<u32>, src: vec4<f32>) {\n\tlet dst = textureLoad(backbuffer, pix, 0);\n\t// blend op:        src*1 + dst * (1.0 - srcA)\n\t// alpha blend op:  src  * 0 + dst * 1\n\tlet rgb = src.rgb + dst.rgb * (1.0 - saturate(src.a));\n\tlet a = dst.a;\n\ttextureStore(render_target, pix, vec4<f32>(rgb, a));\n}\n\nfn dual_source_blend(pix: vec2<u32>, src0: vec4<f32>, src1: vec4<f32>) {\n\tlet dst = textureLoad(backbuffer, pix, 0);\n\t// blend op:        src0 * 1 + dst * src1\n\t// alpha blend op:  src  * 0 + dst * 1\n\tlet rgb = src0.rgb + dst.rgb * src1.rgb;\n\tlet a = dst.a;\n\ttextureStore(render_target, pix, vec4<f32>(rgb, a));\n}\n",b="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nconst pi: f32 = radians(180.0);\nconst tau: f32 = pi * 2.0;\nconst golden_ratio: f32 = (1.0 + sqrt(5.0)) / 2.0;\n\nconst u32_max: f32 = 4294967296.0;\n\nconst sphere_solid_angle: f32 = 4.0 * pi;\n\nconst t_max_max: f32 = 9000000.0;\nconst planet_radius_offset: f32 = 0.01;\n\n",y="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\nfn get_uniforms() -> Uniforms {\n\tUniforms uniforms;\n\tuniforms.inverse_projection = get_inverse_projection();\n\tuniforms.inverse_view = get_inverse_view();\n\tuniforms.camera_world_position = get_camera_world_position();\n\tuniforms.frame_id = get_frame_id();\n\tuniforms.screen_resolution = get_screen_resolution();\n\tuniforms.ray_march_min_spp = get_ray_march_min_spp();\n\tuniforms.ray_march_max_spp = get_ray_march_max_spp();\n\tuniforms.sun.illuminance = get_sun_illuminance();\n\tuniforms.sun.direction = get_sun_direction();\n\tuniforms.sun.disk_diameter =  get_sun_disk_diameter();\n\tuniforms.sun.disk_luminance_scale = get_sun_disk_luminance_scale();\n\tuniforms.moon.illuminance = get_moon_illuminance();\n\tuniforms.moon.direction = get_moon_direction();\n\tuniforms.moon.disk_diameter =  get_moon_disk_diameter();\n\tuniforms.moon.disk_luminance_scale = get_moon_disk_luminance_scale();\n\treturn uniforms;\n}\n",w="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\noverride IS_REVERSE_Z: bool = true;\n\nfn depth_max() -> f32 {\n\tif IS_REVERSE_Z {\n\t\treturn 0.0000001;\n\t} else {\n\t\treturn 1.0;\n\t}\n}\n\nfn is_valid_depth(depth: f32) -> bool {\n\tif IS_REVERSE_Z {\n\t\treturn depth > 0.0 && depth <= 1.0;\n\t} else {\n\t\treturn depth < 1.0 && depth >= 0.0;\n\t}\n}\n\nfn uv_to_world_dir(uv: vec2<f32>, inv_proj: mat4x4<f32>, inv_view: mat4x4<f32>) -> vec3<f32> {\n\tlet hom_view_space = inv_proj * vec4(vec3(uv * vec2(2.0, -2.0) - vec2(1.0, -1.0), depth_max()), 1.0);\n\treturn normalize((inv_view * vec4(hom_view_space.xyz / hom_view_space.w, 0.0)).xyz);\n}\n\nfn uv_and_depth_to_world_pos(uv: vec2<f32>, inv_proj: mat4x4<f32>, inv_view: mat4x4<f32>, depth: f32) -> vec3<f32> {\n\tlet hom_view_space = inv_proj * vec4(vec3(uv * vec2(2.0, -2.0) - vec2(1.0, -1.0), depth), 1.0);\n\treturn (inv_view * vec4(hom_view_space.xyz / hom_view_space.w, 1.0)).xyz;\n}\n",x="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\n@vertex\nfn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {\n\treturn vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);\n}\n",S="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\n// If there are no positive real solutions, returns -1.0\nfn solve_quadratic_for_positive_reals(a: f32, b: f32, c: f32) -> f32 {\n\tlet delta = b * b - 4.0 * a * c;\n\tif delta < 0.0 || a == 0.0 {\n\t\treturn -1.0;\n\t}\n\tlet solution0 = (-b - sqrt(delta)) / (2.0 * a);\n\tlet solution1 = (-b + sqrt(delta)) / (2.0 * a);\n\tif solution0 < 0.0 && solution1 < 0.0 {\n\t\treturn -1.0;\n\t}\n\tif solution0 < 0.0 {\n\t\treturn max(0.0, solution1);\n\t}\n\telse if solution1 < 0.0 {\n\t\treturn max(0.0, solution0);\n\t}\n\treturn max(0.0, min(solution0, solution1));\n}\n\nfn quadratic_has_positive_real_solutions(a: f32, b: f32, c: f32) -> bool {\n\tlet delta = b * b - 4.0 * a * c;\n\treturn (delta >= 0.0 && a != 0.0) && (((-b - sqrt(delta)) / (2.0 * a)) >= 0.0 || ((-b + sqrt(delta)) / (2.0 * a)) >= 0.0);\n}\n\nfn find_closest_ray_sphere_intersection(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {\n\tlet dist = o - c;\n\treturn solve_quadratic_for_positive_reals(dot(d, d), 2.0 * dot(d, dist), dot(dist, dist) - (r * r));\n}\n\nfn ray_intersects_sphere(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> bool {\n\tlet dist = o - c;\n\treturn quadratic_has_positive_real_solutions(dot(d, d), 2.0 * dot(d, dist), dot(dist, dist) - (r * r));\n}\n\nfn compute_planet_shadow(o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, r: f32) -> f32 {\n\treturn f32(!ray_intersects_sphere(o, d, c, r));\n}\n\nfn find_atmosphere_t_max(t_max: ptr<function, f32>, o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, bottom_radius: f32, top_radius: f32) -> bool {\n\tlet t_bottom = find_closest_ray_sphere_intersection(o, d, c, bottom_radius);\n\tlet t_top = find_closest_ray_sphere_intersection(o, d, c, top_radius);\n\tif t_bottom < 0.0 {\n\t\tif t_top < 0.0 {\n\t\t\t*t_max = 0.0;\n\t\t\treturn false;\n\t\t} else {\n\t\t\t*t_max = t_top;\n\t\t}\n\t} else {\n\t\tif t_top > 0.0 {\n\t\t\t*t_max = min(t_top, t_bottom);\n\t\t} else {\n\t\t\t*t_max = t_bottom;\n\t\t}\n\t}\n\treturn true;\n}\n\nfn find_atmosphere_t_max_t_bottom(t_max: ptr<function, f32>, t_bottom: ptr<function, f32>, o: vec3<f32>, d: vec3<f32>, c: vec3<f32>, bottom_radius: f32, top_radius: f32) -> bool {\n\t*t_bottom = find_closest_ray_sphere_intersection(o, d, c, bottom_radius);\n\tlet t_top = find_closest_ray_sphere_intersection(o, d, c, top_radius);\n\tif *t_bottom < 0.0 {\n\t\tif t_top < 0.0 {\n\t\t\t*t_max = 0.0;\n\t\t\treturn false;\n\t\t} else {\n\t\t\t*t_max = t_top;\n\t\t}\n\t} else {\n\t\tif t_top > 0.0 {\n\t\t\t*t_max = min(t_top, *t_bottom);\n\t\t} else {\n\t\t\t*t_max = *t_bottom;\n\t\t}\n\t}\n\treturn true;\n}\n\nfn move_to_atmosphere_top(world_pos: ptr<function, vec3<f32>>, world_dir: vec3<f32>, top_radius: f32) -> bool {\n\tlet view_height = length(*world_pos);\n\tif view_height > top_radius {\n\t\tlet t_top = find_closest_ray_sphere_intersection(*world_pos, world_dir, vec3(), top_radius * 0.9999);\n\t\tif t_top >= 0.0 {\n\t\t\t*world_pos = *world_pos + world_dir * t_top;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n",L="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\nstruct Atmosphere {\n\t// Rayleigh scattering coefficients\n\trayleigh_scattering: vec3<f32>,\n\t// Rayleigh scattering exponential distribution scale in the atmosphere\n\trayleigh_density_exp_scale: f32,\n\n\t// Mie scattering coefficients\n\tmie_scattering: vec3<f32>,\n\t// Mie scattering exponential distribution scale in the atmosphere\n\tmie_density_exp_scale: f32,\n\t// Mie extinction coefficients\n\tmie_extinction: vec3<f32>,\n\t// Mie phase function excentricity\n\tmie_phase_g: f32,\n\t// Mie absorption coefficients\n\tmie_absorption: vec3<f32>,\n\t\n\t// Another medium type in the atmosphere\n\tabsorption_density_0_layer_height: f32,\n\tabsorption_density_0_constant_term: f32,\n\tabsorption_density_0_linear_term: f32,\n\tabsorption_density_1_constant_term: f32,\n\tabsorption_density_1_linear_term: f32,\n\t// This other medium only absorb light, e.g. useful to represent ozone in the earth atmosphere\n\tabsorption_extinction: vec3<f32>,\n\n\t// Radius of the planet (center to ground)\n\tbottom_radius: f32,\n\n\t// The albedo of the ground.\n\tground_albedo: vec3<f32>,\n\n\t// Maximum considered atmosphere height (center to atmosphere top)\n\ttop_radius: f32,\n\n\t// planet center in world space (z up)\n\t// used to transform the camera's position to the atmosphere's object space\n\tplanet_center: vec3<f32>,\n\t\n\tmulti_scattering_factor: f32,\n}\n\nfn make_earth_atmosphere() -> Atmosphere {\n\tlet earth_rayleigh_scale_height = 8.0;\n\tlet earth_mie_scale_height = 1.2;\n\n\tvar atmosphere: Atmosphere;\n\n\tatmosphere.bottom_radius = 6360.0;\n\tatmosphere.top_radius = 6460.0;\n\n\tatmosphere.rayleigh_density_exp_scale = -1.0 / earth_rayleigh_scale_height;\n\tatmosphere.rayleigh_scattering = vec3(0.005802, 0.013558, 0.033100);    // 1/km\n\n\tatmosphere.mie_density_exp_scale = -1.0 / earth_mie_scale_height;\n\tatmosphere.mie_scattering = vec3(0.003996, 0.003996, 0.003996);\t\t\t// 1/km\n\tatmosphere.mie_extinction = vec3(0.004440, 0.004440, 0.004440);\t\t\t// 1/km\n\tatmosphere.mie_absorption = max(atmosphere.mie_extinction - atmosphere.mie_scattering, vec3());\n\tatmosphere.mie_phase_g = 0.8;\n\t\n\tatmosphere.absorption_extinction = vec3(0.000650, 0.001881, 0.000085);\t// 1/km\n\tatmosphere.absorption_density_0_layer_height = 25.0;\n\tatmosphere.absorption_density_0_constant_term = -2.0 / 3.0;\n\tatmosphere.absorption_density_0_linear_term = 1.0 / 15.0;\n\tatmosphere.absorption_density_1_constant_term = 8.0 / 3.0;\n\tatmosphere.absorption_density_1_linear_term = -1.0 / 15.0;\n\n\tatmosphere.ground_albedo = vec3(0.0, 0.0, 0.0);\n\n\tatmosphere.multi_scattering_factor = 1.0;\n\t\n\treturn atmosphere;\n}\n\nstruct MediumSample {\n\tscattering: vec3<f32>,\n\textinction: vec3<f32>,\n\n\tmie_scattering: vec3<f32>,\n\trayleigh_scattering: vec3<f32>,\n}\n\n/*\n * origin is the planet's center\n */\nfn sample_medium_extinction(height: f32, atmosphere: Atmosphere) -> vec3<f32> {\n\tlet mie_density: f32 = exp(atmosphere.mie_density_exp_scale * height);\n\tlet rayleigh_density: f32 = exp(atmosphere.rayleigh_density_exp_scale * height);\n\tvar absorption_density: f32;\n\tif height < atmosphere.absorption_density_0_layer_height {\n\t\tabsorption_density = saturate(atmosphere.absorption_density_0_linear_term * height + atmosphere.absorption_density_0_constant_term);\n\t} else {\n\t\tabsorption_density = saturate(atmosphere.absorption_density_1_linear_term * height + atmosphere.absorption_density_1_constant_term);\n\t}\n\n\tlet mie_extinction = mie_density * atmosphere.mie_extinction;\n\tlet rayleigh_extinction = rayleigh_density * atmosphere.rayleigh_scattering;\n\tlet absorption_extinction = absorption_density * atmosphere.absorption_extinction;\n\n\treturn mie_extinction + rayleigh_extinction + absorption_extinction;\n}\n\nfn sample_medium(height: f32, atmosphere: Atmosphere) -> MediumSample {\n\tlet mie_density: f32 = exp(atmosphere.mie_density_exp_scale * height);\n\tlet rayleigh_density: f32 = exp(atmosphere.rayleigh_density_exp_scale * height);\n\tvar absorption_density: f32;\n\tif height < atmosphere.absorption_density_0_layer_height {\n\t\tabsorption_density = saturate(atmosphere.absorption_density_0_linear_term * height + atmosphere.absorption_density_0_constant_term);\n\t} else {\n\t\tabsorption_density = saturate(atmosphere.absorption_density_1_linear_term * height + atmosphere.absorption_density_1_constant_term);\n\t}\n\n\tvar s: MediumSample;\n\ts.mie_scattering = mie_density * atmosphere.mie_scattering;\n\ts.rayleigh_scattering = rayleigh_density * atmosphere.rayleigh_scattering;\n\ts.scattering = s.mie_scattering + s.rayleigh_scattering;\n\n\tlet mie_extinction = mie_density * atmosphere.mie_extinction;\n\tlet rayleigh_extinction = s.rayleigh_scattering;\n\tlet absorption_extinction = absorption_density * atmosphere.absorption_extinction;\n\ts.extinction = mie_extinction + rayleigh_extinction + absorption_extinction;\n\n\treturn s;\n}\n",k="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride MULTI_SCATTERING_LUT_RES_X: f32 = 32.0;\noverride MULTI_SCATTERING_LUT_RES_Y: f32 = MULTI_SCATTERING_LUT_RES_X;\n\nfn get_multiple_scattering(atmosphere: Atmosphere, scattering: vec3<f32>, extinction: vec3<f32>, worl_pos: vec3<f32>, cos_view_zenith: f32) -> vec3<f32> {\n\tvar uv = saturate(vec2(cos_view_zenith * 0.5 + 0.5, (length(worl_pos) - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius)));\n\tuv = vec2(from_unit_to_sub_uvs(uv.x, MULTI_SCATTERING_LUT_RES_X), from_unit_to_sub_uvs(uv.y, MULTI_SCATTERING_LUT_RES_Y));\n\treturn textureSampleLevel(multi_scattering_lut, lut_sampler, uv, 0).rgb;\n}\n",P="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n \nconst isotropic_phase: f32 = 1.0 / sphere_solid_angle;\n\nfn cornette_shanks_phase(g: f32, cos_theta: f32) -> f32 {\n\tlet k: f32 = 3.0 / (8.0 * pi) * (1.0 - g * g) / (2.0 + g * g);\n\treturn k * (1.0 + cos_theta * cos_theta) / pow(1.0 + g * g - 2.0 * g * -cos_theta, 1.5);\n}\n\nfn rayleigh_phase(cos_theta: f32) -> f32 {\n\tlet factor: f32 = 3.0f / (16.0f * pi);\n\treturn factor * (1.0f + cos_theta * cos_theta);\n}\n",T="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\noverride RANDOMIZE_SAMPLE_OFFSET: bool = true;\n\nfn pcg_hash(seed: u32) -> u32 {\n\tlet state = seed * 747796405u + 2891336453u;\n\tlet word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nfn pcg_hashf(seed: u32) -> f32 {\n\treturn f32(pcg_hash(seed)) / 4294967296.0;\n}\n\nfn pcg_hash3(x: u32, y: u32, z: u32) -> f32 {\n\treturn pcg_hashf((x * 1664525 + y) + z);\n}\n\nfn get_sample_segment_t(uv: vec2<f32>, config: Uniforms) -> f32 {\n\tif RANDOMIZE_SAMPLE_OFFSET {\n\t\tlet seed = vec3<u32>(\n\t\t\tu32(uv.x * config.screen_resolution.x),\n\t\t\tu32(uv.y * config.screen_resolution.y),\n\t\t\tpcg_hash(u32(config.frame_id)),\n\t\t);\n\t\treturn pcg_hash3(seed.x, seed.y, seed.z);\n\t} else {\n\t\treturn 0.3;\n\t}\n}\n",U="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n \noverride SKY_VIEW_LUT_RES_X: f32 = 192.0;\noverride SKY_VIEW_LUT_RES_Y: f32 = 108.0;\n\nfn sky_view_lut_params_to_uv(atmosphere: Atmosphere, intersects_ground: bool, cos_view_zenith: f32, cos_light_view: f32, view_height: f32) -> vec2<f32> {\n\tlet v_horizon = sqrt(max(view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius, 0.0));\n\tlet ground_to_horizon = acos(v_horizon / view_height);\n\tlet zenith_horizon_angle = pi - ground_to_horizon;\n\n\tvar uv = vec2<f32>();\n\tif !intersects_ground {\n\t\tlet coord = 1.0 - sqrt(max(1.0 - acos(cos_view_zenith) / zenith_horizon_angle, 0.0));\n\t\tuv.y = coord * 0.5;\n\t} else {\n\t\tlet coord = (acos(cos_view_zenith) - zenith_horizon_angle) / ground_to_horizon;\n\t\tuv.y = sqrt(max(coord, 0.0)) * 0.5 + 0.5;\n\t}\n\tuv.x = sqrt(-cos_light_view * 0.5 + 0.5);\n\n\treturn vec2(from_unit_to_sub_uvs(uv.x, SKY_VIEW_LUT_RES_X), from_unit_to_sub_uvs(uv.y, SKY_VIEW_LUT_RES_Y));\n}\n",R="/*\n * Copyright (c) 2024 Lukas Herzberger\n * SPDX-License-Identifier: MIT\n */\n\noverride RENDER_SUN_DISK: bool = true;\noverride RENDER_MOON_DISK: bool = true;\noverride LIMB_DARKENING_ON_SUN: bool = true;\noverride LIMB_DARKENING_ON_MOON: bool = false;\n\nfn limb_darkeining_factor(center_to_edge: f32) -> vec3<f32> {\n\tlet u = vec3<f32>(1.0);\n\tlet a = vec3<f32>(0.397 , 0.503 , 0.652);\n\tlet inv_center_to_edge = 1.0 - center_to_edge;\n\tlet mu = sqrt(max(1.0 - inv_center_to_edge * inv_center_to_edge, 0.0));\n\treturn 1.0 - u * (1.0 - pow(vec3<f32>(mu), a));\n}\n\nfn sun_disk_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, light: AtmosphereLight, apply_limb_darkening: bool) -> vec3<f32> {\n\tlet cos_view_sun = dot(world_dir, light.direction);\n\tlet cos_disk_radius = cos(0.5 * light.disk_diameter);\n\t\n\tif cos_view_sun <= cos_disk_radius || ray_intersects_sphere(world_pos, world_dir, vec3<f32>(), atmosphere.bottom_radius) {\n\t\treturn vec3<f32>();\n\t}\n\n\tlet disk_solid_angle = tau * cos_disk_radius;\n\tlet l_outer_space = (light.illuminance / disk_solid_angle) * light.disk_luminance_scale;\n\n\tlet height = length(world_pos);\n\tlet zenith = world_pos / height;\n\tlet cos_view_zenith = dot(world_dir, zenith);\n\tlet uv = transmittance_lut_params_to_uv(atmosphere, height, cos_view_zenith);\n\tlet transmittance_sun = textureSampleLevel(transmittance_lut, lut_sampler, uv, 0).rgb;\n\n\tif apply_limb_darkening {\n\t\tlet center_to_edge = 1.0 - ((2.0 * acos(cos_view_sun)) / light.disk_diameter);\n\t\treturn transmittance_sun * l_outer_space * limb_darkeining_factor(center_to_edge);\n\t} else {\n\t\treturn transmittance_sun * l_outer_space;\n\t}\n}\n\nfn get_sun_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, uniforms: Uniforms) -> vec3<f32> {\n\tvar sun_luminance = vec3<f32>();\n\tif RENDER_SUN_DISK {\n\t\tsun_luminance += sun_disk_luminance(world_pos, world_dir, atmosphere, uniforms.sun, LIMB_DARKENING_ON_SUN);\n\t}\n\tif RENDER_MOON_DISK && USE_MOON {\n\t\tsun_luminance += sun_disk_luminance(world_pos, world_dir, atmosphere, uniforms.moon, LIMB_DARKENING_ON_MOON);\n\t}\n\treturn sun_luminance;\n}\n",z="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\nstruct AtmosphereLight {\n\t// Sun light's illuminance\n\tilluminance: vec3<f32>,\n\t\n\t// Sun disk's angular diameter in radians\n\tdisk_diameter: f32,\n\t\n\t// Sun light's direction (direction pointing to the sun)\n\tdirection: vec3<f32>,\n\n\t// Sun disk's luminance\n\tdisk_luminance_scale: f32,\n}\n\nstruct Uniforms {\n\t// Inverse projection matrix for the current camera view\n\tinverse_projection: mat4x4<f32>,\n\n\t// Inverse view matrix for the current camera view\n\tinverse_view: mat4x4<f32>,\n\n\t// World position of the current camera view\n\tcamera_world_position: vec3<f32>,\n\n\t// Resolution of the multiscattering LUT (width = height)\n\tframe_id: f32,\n\n\t// Resolution of the output texture\n\tscreen_resolution: vec2<f32>,\n\n\t// Minimum number of ray marching samples per pixel\n\tray_march_min_spp: f32,\n\n\t// Maximum number of ray marching samples per pixel\n\tray_march_max_spp: f32,\n\n\t// Sun parameters\n\tsun: AtmosphereLight,\n\n\t// Moon / second sun parameters \n\tmoon: AtmosphereLight,\n}\n\n",E="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\nfn from_sub_uvs_to_unit(u: f32, resolution: f32) -> f32 {\n\treturn (u - 0.5 / resolution) * (resolution / (resolution - 1.0));\n}\n\nfn from_unit_to_sub_uvs(u: f32, resolution: f32) -> f32 {\n\treturn (u + 0.5 / resolution) * (resolution / (resolution + 1.0));\n}\n\nfn transmittance_lut_params_to_uv(atmosphere: Atmosphere, view_height: f32, cos_view_zenith: f32) -> vec2<f32> {\n\tlet height_sq = view_height * view_height;\n\tlet bottom_radius_sq = atmosphere.bottom_radius * atmosphere.bottom_radius;\n\tlet top_radius_sq = atmosphere.top_radius * atmosphere.top_radius;\n\tlet h = sqrt(max(0.0, top_radius_sq - bottom_radius_sq));\n\tlet rho = sqrt(max(0.0, height_sq - bottom_radius_sq));\n\n\tlet discriminant = height_sq * (cos_view_zenith * cos_view_zenith - 1.0) + top_radius_sq;\n\tlet distance_to_boundary = max(0.0, (-view_height * cos_view_zenith + sqrt(max(discriminant, 0.0))));\n\n\tlet min_distance = atmosphere.top_radius - view_height;\n\tlet max_distance = rho + h;\n\tlet x_mu = (distance_to_boundary - min_distance) / (max_distance - min_distance);\n\tlet x_r = rho / h;\n\n\treturn vec2<f32>(x_mu, x_r);\n}\n";function M(e="rgba16float"){return`${b}\n${S}\n${L}\n/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride SAMPLE_COUNT: u32 = 40;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var transmittance_lut : texture_storage_2d<rgba16float, write>;\n\nfn find_closest_ray_circle_intersection(o: vec2<f32>, d: vec2<f32>, r: f32) -> f32 {\n\treturn solve_quadratic_for_positive_reals(dot(d, d), 2.0 * dot(d, o), dot(o, o) - (r * r));\n}\n\nfn find_atmosphere_t_max_2d(t_max: ptr<function, f32>, o: vec2<f32>, d: vec2<f32>, bottom_radius: f32, top_radius: f32) -> bool {\n\tlet t_bottom = find_closest_ray_circle_intersection(o, d, bottom_radius);\n\tlet t_top = find_closest_ray_circle_intersection(o, d, top_radius);\n\tif t_bottom < 0.0 {\n\t\tif t_top < 0.0 {\n\t\t\t*t_max = 0.0;\n\t\t\treturn false;\n\t\t} else {\n\t\t\t*t_max = t_top;\n\t\t}\n\t} else {\n\t\tif t_top > 0.0 {\n\t\t\t*t_max = min(t_top, t_bottom);\n\t\t} else {\n\t\t\t*t_max = 0.0;\n\t\t}\n\t}\n\treturn true;\n}\n\nfn uv_to_transmittance_lut_params(uv: vec2<f32>, atmosphere: Atmosphere) -> vec2<f32> {\n\tlet x_mu: f32 = uv.x;\n\tlet x_r: f32 = uv.y;\n\n\tlet bottom_radius_sq = atmosphere.bottom_radius * atmosphere.bottom_radius;\n\tlet h_sq = atmosphere.top_radius * atmosphere.top_radius - bottom_radius_sq;\n\tlet h: f32 = sqrt(h_sq);\n\tlet rho: f32 = h * x_r;\n\tlet rho_sq = rho * rho;\n\tlet view_height = sqrt(rho_sq + bottom_radius_sq);\n\n\tlet d_min: f32 = atmosphere.top_radius - view_height;\n\tlet d_max: f32 = rho + h;\n\tlet d: f32 = d_min + x_mu * (d_max - d_min);\n\n\tvar cos_view_zenith = 1.0;\n\tif d != 0.0 {\n\t\tcos_view_zenith = clamp((h_sq - rho_sq - d * d) / (2.0 * view_height * d), -1.0, 1.0);\n\t}\n\n\treturn vec2<f32>(view_height, cos_view_zenith);\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn render_transmittance_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(transmittance_lut));\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\n\tlet pix = vec2<f32>(global_id.xy) + 0.5;\n\tlet uv = pix / vec2<f32>(output_size);\n\n\tlet atmosphere = atmosphere_buffer;\n\n\t// Compute camera position from LUT coords\n\tlet lut_params = uv_to_transmittance_lut_params(uv, atmosphere);\n\tlet view_height = lut_params.x;\n\tlet cos_view_zenith = lut_params.y;\n\tlet world_pos = vec2(0.0, view_height);\n\tlet world_dir = vec2(sqrt(1.0 - cos_view_zenith * cos_view_zenith), cos_view_zenith);\n\n\tvar transmittance = vec3<f32>();\n\n\t// Compute next intersection with atmosphere or ground\n\tvar t_max: f32 = 0.0;\n\tif find_atmosphere_t_max_2d(&t_max, world_pos, world_dir, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\tt_max = min(t_max, t_max_max);\n\n\t\t// Sample count\n\t\tlet sample_count = f32(SAMPLE_COUNT);\t// Can go a low as 10 sample but energy lost starts to be visible.\n\t\tlet sample_segment_t: f32 = 0.3f;\n\t\tlet dt = t_max / sample_count;\n\n\t\t// Ray march the atmosphere to integrate optical depth\n\t\tvar t = 0.0f;\n\t\tvar dt_exact = 0.0f;\n\t\tfor (var s: f32 = 0.0f; s < sample_count; s += 1.0f) {\n\t\t\tlet t_new = (s + sample_segment_t) * dt;\n\t\t\tdt_exact = t_new - t;\n\t\t\tt = t_new;\n\n\t\t\tlet sample_height = length(world_pos + t * world_dir) - atmosphere.bottom_radius;\n\t\t\ttransmittance += sample_medium_extinction(sample_height, atmosphere) * dt_exact;\n\t\t}\n\n\t\ttransmittance = exp(-transmittance);\n\t}\n\n\ttextureStore(transmittance_lut, global_id.xy, vec4<f32>(transmittance, 1.0));\n}\n`.replace("rgba16float",e)}function I(e="rgba16float"){return`${b}\n${S}\n${L}\n${P}\n${E}\n/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n \noverride SAMPLE_COUNT: u32 = 20;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var lut_sampler: sampler;\n@group(0) @binding(2) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(3) var multi_scattering_lut: texture_storage_2d<rgba16float, write>;\n\nconst direction_sample_count: f32 = 64.0;\nconst workgroup_size_z: u32 = 64;\n\nvar<workgroup> shared_multi_scattering: array<vec3<f32>, workgroup_size_z>;\nvar<workgroup> shared_luminance: array<vec3<f32>, workgroup_size_z>;\n\nfn get_transmittance_to_sun(sun_dir: vec3<f32>, zenith: vec3<f32>, atmosphere: Atmosphere, sample_height: f32) -> vec3<f32> {\n\tlet cos_sun_zenith = dot(sun_dir, zenith);\n\tlet uv = transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith);\n\treturn textureSampleLevel(transmittance_lut, lut_sampler, uv, 0).rgb;\n}\n\nstruct IntegrationResults {\n\tluminance: vec3<f32>,\n\tmulti_scattering: vec3<f32>,\n}\n\nfn integrate_scattered_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, atmosphere: Atmosphere) -> IntegrationResults {\n\tvar result = IntegrationResults();\n\n\tlet planet_center = vec3<f32>();\n\tvar t_max: f32 = 0.0;\n\tvar t_bottom: f32 = 0.0;\n\tif !find_atmosphere_t_max_t_bottom(&t_max, &t_bottom, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\treturn result;\n\t}\n\tt_max = min(t_max, t_max_max);\n\n\tlet sample_count = f32(SAMPLE_COUNT);\n\tlet sample_segment_t = 0.3;\n\tlet dt = t_max / sample_count;\n\n\tvar throughput = vec3<f32>(1.0);\n\tvar t = 0.0;\n\tvar dt_exact = 0.0;\n\tfor (var s = 0.0; s < sample_count; s += 1.0) {\n\t\tlet t_new = (s + sample_segment_t) * dt;\n\t\tdt_exact = t_new - t;\n\t\tt = t_new;\n\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height = length(sample_pos);\n\n\t\tlet zenith = sample_pos / sample_height;\n\t\tlet transmittance_to_sun = get_transmittance_to_sun(sun_dir, zenith, atmosphere, sample_height);\n\n\t\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\n\t\tlet sample_transmittance = exp(-medium.extinction * dt_exact);\n\n\t\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_dir, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\tlet scattered_luminance = planet_shadow * transmittance_to_sun * (medium.scattering * isotropic_phase);\n\n\t\tresult.multi_scattering += throughput * (medium.scattering - medium.scattering * sample_transmittance) / medium.extinction;\n\t\tresult.luminance += throughput * (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\n\n\t\tthroughput *= sample_transmittance;\n\t}\n\n\t// Account for light bounced off the planet\n\tif t_max == t_bottom && t_bottom > 0.0 {\n\t\tlet t = t_bottom;\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height = length(sample_pos);\n\n\t\tlet zenith = sample_pos / sample_height;\n\t\tlet transmittance_to_sun = get_transmittance_to_sun(sun_dir, zenith, atmosphere, sample_height);\n\n\t\tlet n_dot_l = saturate(dot(zenith, sun_dir));\n\t\tresult.luminance += transmittance_to_sun * throughput * n_dot_l * atmosphere.ground_albedo / pi;\n\t}\n\n\treturn result;\n}\n\nfn compute_sample_direction(direction_index: u32) -> vec3<f32> {\n\tlet sample = f32(direction_index);\n\tlet theta = tau * sample / golden_ratio;\n\tlet phi = acos(1.0 - 2.0 * (sample + 0.5) / direction_sample_count);\n\tlet cos_phi = cos(phi);\n\tlet sin_phi = sin(phi);\n\tlet cos_theta = cos(theta);\n\tlet sin_theta = sin(theta);\n\treturn vec3(\n\t\tcos_theta * sin_phi,\n\t\tsin_theta * sin_phi,\n\t\tcos_phi\n\t);\n}\n\n@compute\n@workgroup_size(1, 1, workgroup_size_z)\nfn render_multi_scattering_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = textureDimensions(multi_scattering_lut);\n\tlet direction_index = global_id.z;\n\n\tlet pix = vec2<f32>(global_id.xy) + 0.5;\n\tvar uv = pix / vec2<f32>(output_size);\n\tuv = vec2<f32>(from_sub_uvs_to_unit(uv.x, f32(output_size.x)), from_sub_uvs_to_unit(uv.y, f32(output_size.y)));\n\n\tlet atmosphere = atmosphere_buffer;\n\n\tlet cos_sun_zenith = uv.x * 2.0 - 1.0;\n\tlet sun_dir = vec3<f32>(0.0, sqrt(saturate(1.0 - cos_sun_zenith * cos_sun_zenith)), cos_sun_zenith);\n\tlet view_height = atmosphere.bottom_radius + saturate(uv.y + planet_radius_offset) * (atmosphere.top_radius - atmosphere.bottom_radius - planet_radius_offset);\n\n\tlet world_pos = vec3<f32>(0.0, 0.0, view_height);\n\tlet world_dir = compute_sample_direction(direction_index);\n\n\tlet scattering_result = integrate_scattered_luminance(world_pos, world_dir, normalize(sun_dir), atmosphere);\n\n\tshared_multi_scattering[direction_index] = scattering_result.multi_scattering / direction_sample_count;\n\tshared_luminance[direction_index] = scattering_result.luminance / direction_sample_count;\n\n\tworkgroupBarrier();\n\n\t// reduce samples - the last remaining thread publishes the result\n\tfor (var i = 32u; i > 0; i = i >> 1) {\n\t\tif direction_index < i {\n\t\t\tshared_multi_scattering[direction_index] += shared_multi_scattering[direction_index + i];\n\t\t\tshared_luminance[direction_index] += shared_luminance[direction_index + i];\n\t\t}\n\t\tworkgroupBarrier();\n\t}\n\tif direction_index > 0 {\n\t\treturn;\n\t}\n\n\tlet luminance = shared_luminance[0] * (1.0 / (1.0 - shared_multi_scattering[0]));\n\n\ttextureStore(multi_scattering_lut, global_id.xy, vec4<f32>(atmosphere.multi_scattering_factor * luminance, 1.0));\n}\n\n`.replace("rgba16float",e)}function G(e){return`${e??"fn get_shadow(p: vec3<f32>, i: u32) -> f32 { return 1.0; }"}`}function C(e="rgba16float",t,n){const i=`${b}\n${S}\n${L}\n${P}\n${E}\n${z}\n${n?`${n}\n${y}\n`:""}${w}\n${k}\n`;let r="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride SKY_VIEW_LUT_RES_X: f32 = 192.0;\noverride SKY_VIEW_LUT_RES_Y: f32 = 108.0;\n\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\n\noverride USE_MOON: bool = false;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\n@group(0) @binding(2) var lut_sampler: sampler;\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\n@group(0) @binding(5) var sky_view_lut : texture_storage_2d<rgba16float, write>;\n\nfn get_sample_shadow(atmosphere: Atmosphere, sample_position: vec3<f32>, light_index: u32) -> f32 {\n\treturn get_shadow(sample_position + atmosphere.planet_center, light_index);\n}\n\nstruct SingleScatteringResult {\n\tluminance: vec3<f32>,\t\t\t\t// Scattered light (luminance)\n\ttransmittance: vec3<f32>,\t\t\t// transmittance in [0,1] (unitless)\n}\n\nfn integrate_scattered_luminance(world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, moon_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> SingleScatteringResult {\n\tvar result = SingleScatteringResult();\n\t\n\tlet planet_center = vec3<f32>();\n\tvar t_max: f32 = 0.0;\n\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\treturn result;\n\t}\n\tt_max = min(t_max, t_max_max);\n\n\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\n\tlet sample_count_floored = floor(sample_count);\n\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\n\tlet t_max_floored = t_max * sample_count_floored / sample_count;\n\tlet sample_segment_t = 0.3;\n\n\tlet sun_direction = normalize(sun_dir);\n\tlet sun_illuminance = config.sun.illuminance;\n\n\tlet cos_theta = dot(sun_dir, world_dir);\n\tlet mie_phase_val = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta);\n\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\n\t\n\tvar moon_direction = moon_dir;\n\tvar moon_illuminance = config.moon.illuminance;\n\n\tvar cos_theta_moon = 0.0;\n\tvar mie_phase_val_moon = 0.0;\n\tvar rayleigh_phase_val_moon = 0.0;\n\n\tif USE_MOON {\n\t\tmoon_direction = normalize(moon_direction);\n\t\tmoon_illuminance = config.moon.illuminance;\n\n\t\tcos_theta_moon = dot(moon_direction, world_dir);\n\t\tmie_phase_val_moon = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta_moon);\n\t\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\n\t}\n\n\tresult.luminance = vec3(0.0);\n\tresult.transmittance = vec3(1.0);\n\tvar t = 0.0;\n\tvar dt = t_max / sample_count;\n\tfor (var s = 0.0; s < sample_count; s += 1.0) {\n\t\tvar t0 = s * inv_sample_count_floored;\n\t\tvar t1 = (s + 1.0) * inv_sample_count_floored;\n\t\tt0 = (t0 * t0) * t_max_floored;\n\t\tt1 = t1 * t1;\n\t\tif t1 > 1.0 {\n\t\t\tt1 = t_max;\n\t\t} else {\n\t\t\tt1 = t_max_floored * t1;\n\t\t}\n\t\tdt = t1 - t0;\n\t\tt = t0 + dt * sample_segment_t;\n\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height = length(sample_pos);\n\n\t\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\n\t\tlet sample_transmittance = exp(-medium.extinction * dt);\n\n\t\tlet zenith = sample_pos / sample_height;\n \n\t\tlet cos_sun_zenith = dot(sun_direction, zenith);\n\t\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\n\t\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\n\t\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\n\t\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\n\n\t\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\n\n\t\tif USE_MOON {\n\t\t\tlet cos_moon_zenith = dot(moon_direction, zenith);\n\t\t\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\n\t\t\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\n\t\t\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\n\t\t\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\t\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\n\n\t\t\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\n\t\t}\n\n\t\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\n\t\tresult.luminance += result.transmittance * intergrated_luminance;\n\t\tresult.transmittance *= sample_transmittance;\n\t}\n\t\n\treturn result;\n}\n\nfn compute_sun_dir(sun_dir: vec3<f32>, zenith: vec3<f32>) -> vec3<f32> {\n\tlet cos_sun_zenith = dot(zenith, sun_dir);\n\treturn normalize(vec3(sqrt(max(1.0 - cos_sun_zenith * cos_sun_zenith, 0.0)), 0.0, cos_sun_zenith));\n}\n\nfn compute_world_dir(uv_in: vec2<f32>, sky_view_res: vec2<f32>, view_height: f32, atmosphere: Atmosphere) -> vec3<f32> {\n\tlet uv = vec2(from_sub_uvs_to_unit(uv_in.x, sky_view_res.x), from_sub_uvs_to_unit(uv_in.y, sky_view_res.y));\n\n\tlet v_horizon = sqrt(max(view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius, 0.0));\n\tlet ground_to_horizon_angle = acos(v_horizon / view_height);\n\tlet zenith_horizon_angle = pi - ground_to_horizon_angle;\n\n\tvar cos_view_zenith: f32;\n\tif uv.y < 0.5 {\n\t\tlet coord = 1.0 - (2.0 * uv.y);\n\t\tcos_view_zenith = cos(zenith_horizon_angle * (1.0 - (coord * coord)));\n\t} else {\n\t\tlet coord = (uv.y * 2.0) - 1.0;\n\t\tcos_view_zenith = cos(zenith_horizon_angle + ground_to_horizon_angle * (coord * coord));\n\t}\n\tlet cos_light_view = -((uv.x * uv.x) * 2.0 - 1.0);\n\tlet sin_view_zenith = sqrt(max(1.0 - cos_view_zenith * cos_view_zenith, 0.0));\n\n\treturn vec3(\n\t\tsin_view_zenith * cos_light_view,\n\t\tsin_view_zenith * sqrt(max(1.0 - cos_light_view * cos_light_view, 0.0)),\n\t\tcos_view_zenith\n\t);\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn render_sky_view_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(sky_view_lut));\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\n\tlet sky_view_lut_res = vec2<f32>(SKY_VIEW_LUT_RES_X, SKY_VIEW_LUT_RES_Y); // vec2<f32>(output_size); <- tex dimensions produce artefacts!\n\n\tlet pix = vec2<f32>(global_id.xy) + 0.5;\n\tlet uv = pix / sky_view_lut_res;\n\n\tlet atmosphere = atmosphere_buffer;\n\tlet config = config_buffer;\n\n\tlet view_world_pos = config.camera_world_position - atmosphere.planet_center;\n\tlet world_sun_dir = normalize(config.sun.direction);\n\tlet world_moon_dir = normalize(config.moon.direction);\n\n\tlet view_height = length(view_world_pos);\n\n\tlet zenith = view_world_pos / view_height;\n\tlet sun_dir = compute_sun_dir(world_sun_dir, zenith);\n\tlet moon_dir = compute_sun_dir(world_moon_dir, zenith);\n\n\tvar world_pos = vec3<f32>(0.0, 0.0, view_height);\n\tlet world_dir = compute_world_dir(uv, sky_view_lut_res, view_height, atmosphere);\n\n\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\n\t\ttextureStore(sky_view_lut, global_id.xy, vec4<f32>(0, 0, 0, 1));\n\t\treturn;\n\t}\n\n\tlet ss = integrate_scattered_luminance(world_pos, world_dir, sun_dir, moon_dir, atmosphere, config);\n\n\ttextureStore(sky_view_lut, global_id.xy, vec4<f32>(ss.luminance, 1.0 - dot(ss.transmittance, vec3(1.0 / 3.0))));\n}\n".replace("rgba16float",e);if(n){r=r.replace("let config = config_buffer","let config = get_uniforms()"),r=r.replace("@group(0) @binding(1) var<uniform> config_buffer: Uniforms;","");for(let e=2;e<6;++e)r=r.replace(`group(0) @binding(${e})`,`group(0) @binding(${e-1})`)}return`${G(t)}\n${i}\n${r}`}function O(e="rgba16float",t,n){const i=`${b}\n${S}\n${L}\n${P}\n${E}\n${z}\n${n?`${n}\n${y}\n`:""}${w}\n${k}\n${g}\n${T}\n`;let r="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride USE_MOON: bool = false;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\n@group(0) @binding(2) var lut_sampler: sampler;\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\n@group(0) @binding(5) var aerial_perspective_lut: texture_storage_3d<rgba16float, write>;\n\nfn get_sample_shadow(atmosphere: Atmosphere, sample_position: vec3<f32>, light_index: u32) -> f32 {\n\treturn get_shadow(sample_position + atmosphere.planet_center, light_index);\n}\n\nstruct SingleScatteringResult {\n\tluminance: vec3<f32>,\t\t\t\t// Scattered light (luminance)\n\ttransmittance: vec3<f32>,\t\t\t// Transmittance in [0,1] (unitless)\n}\n\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms, sample_count: f32, t_max_bound: f32) -> SingleScatteringResult {\n\tvar result = SingleScatteringResult();\n\n\tlet planet_center = vec3<f32>();\n\tvar t_max: f32 = 0.0;\n\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\treturn result;\n\t}\n\tt_max = min(t_max, t_max_bound);\n\n\tlet sample_segment_t = get_sample_segment_t(uv, config);\n\tlet dt = t_max / sample_count;\n\n\tlet sun_direction = normalize(config.sun.direction);\n\tlet sun_illuminance = config.sun.illuminance;\n\n\tlet cos_theta = dot(sun_direction, world_dir);\n\tlet mie_phase_val = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta);\n\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\n\n\tvar moon_direction = config.moon.direction;\n\tvar moon_illuminance = config.moon.illuminance;\n\n\tvar cos_theta_moon = 0.0;\n\tvar mie_phase_val_moon = 0.0;\n\tvar rayleigh_phase_val_moon = 0.0;\n\n\tif USE_MOON {\n\t\tmoon_direction = normalize(moon_direction);\n\t\tmoon_illuminance = config.moon.illuminance;\n\n\t\tcos_theta_moon = dot(moon_direction, world_dir);\n\t\tmie_phase_val_moon = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta_moon);\n\t\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\n\t}\n\n\tresult.luminance = vec3(0.0);\n\tresult.transmittance = vec3(1.0);\n\tvar t = 0.0;\n\tvar dt_exact = 0.0;\n\tfor (var s = 0.0; s < sample_count; s += 1.0) {\n\t\tlet t_new = (s + sample_segment_t) * dt;\n\t\tdt_exact = t_new - t;\n\t\tt = t_new;\n\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height = length(sample_pos);\n\n\t\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\n\t\tlet sample_transmittance = exp(-medium.extinction * dt_exact);\n\n\t\tlet zenith = sample_pos / sample_height;\n\n\t\tlet cos_sun_zenith = dot(sun_direction, zenith);\n\t\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\n\t\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\n\t\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\n\t\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\n\n\t\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\n\n\t\tif USE_MOON {\n\t\t\tlet cos_moon_zenith = dot(moon_direction, zenith);\n\t\t\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\n\t\t\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\n\t\t\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\n\t\t\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\t\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\n\n\t\t\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\n\t\t}\n\n\t\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\n\t\tresult.luminance += result.transmittance * intergrated_luminance;\n\t\tresult.transmittance *= sample_transmittance;\n\t}\n\n\treturn result;\n}\n\nfn thread_z_to_slice(thread_z: u32) -> f32 {\n\tlet slice = ((f32(thread_z) + 0.5) / AP_SLICE_COUNT);\n\treturn (slice * slice) * AP_SLICE_COUNT; // squared distribution\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn render_aerial_perspective_lut(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(aerial_perspective_lut).xy);\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\n\tlet atmosphere = atmosphere_buffer;\n\tlet config = config_buffer;\n\n\tlet pix = vec2<f32>(global_id.xy) + 0.5;\n\tlet uv = pix / vec2<f32>(output_size.xy);\n\n\tvar world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\n\tlet cam_pos = config.camera_world_position - atmosphere.planet_center;\n\n\tvar world_pos = cam_pos;\n\n\tvar t_max = aerial_perspective_slice_to_depth(thread_z_to_slice(global_id.z));\n\tvar slice_start_pos = world_pos + t_max * world_dir;\n\n\tvar view_height = length(slice_start_pos);\n\tif view_height <= (atmosphere.bottom_radius + planet_radius_offset) {\n\t\tslice_start_pos = normalize(slice_start_pos) * (atmosphere.bottom_radius + planet_radius_offset + 0.001);\n\t\tworld_dir = normalize(slice_start_pos - cam_pos);\n\t\tt_max = length(slice_start_pos - cam_pos);\n\t}\n\n\tview_height = length(world_pos);\n\tif view_height >= atmosphere.top_radius {\n\t\tlet prev_world_pos = world_pos;\n\t\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\n\t\t\ttextureStore(aerial_perspective_lut, global_id, vec4(0.0, 0.0, 0.0, 1.0));\n\t\t\treturn;\n\t\t}\n\t\tlet distance_to_atmosphere = length(prev_world_pos - world_pos);\n\t\tif t_max < distance_to_atmosphere {\n\t\t\ttextureStore(aerial_perspective_lut, global_id, vec4(0.0, 0.0, 0.0, 1.0));\n\t\t\treturn;\n\t\t}\n\t\tt_max = max(0.0, t_max - distance_to_atmosphere);\n\t}\n\n\tlet sample_count = max(1.0, f32(global_id.z + 1) * 2.0);\n\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, config, sample_count, t_max);\n\n\tlet transmittance = dot(ss.transmittance, vec3(1.0 / 3.0));\n\ttextureStore(aerial_perspective_lut, global_id, vec4(ss.luminance, 1.0 - transmittance));\n}\n".replace("rgba16float",e);if(n){r=r.replace("let config = config_buffer","let config = get_uniforms()"),r=r.replace("@group(0) @binding(1) var<uniform> config_buffer: Uniforms;","");for(let e=2;e<6;++e)r=r.replace(`group(0) @binding(${e})`,`group(0) @binding(${e-1})`)}return`${G(t)}\n${i}\n${r}`}function A(e="rgba16float",t){const n=`${b}\n${S}\n${L}\n${P}\n${E}\n${z}\n${t?`${t}\n${y}\n`:""}${w}\n${g}\n${U}\n${v}\n${R}\n${x}\n${T}\n`;let i="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride USE_MOON: bool = false;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\n@group(0) @binding(2) var lut_sampler: sampler;\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(4) var sky_view_lut: texture_2d<f32>;\n@group(0) @binding(5) var aerial_perspective_lut : texture_3d<f32>;\n@group(0) @binding(6) var depth_buffer: texture_2d<f32>;\n@group(0) @binding(7) var backbuffer: texture_2d<f32>;\n@group(0) @binding(8) var render_target: texture_storage_2d<rgba16float, write>;\n\nfn use_sky_view_lut(view_height: f32, world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> vec4<f32> {\n\tlet zenith = normalize(world_pos);\n\tlet cos_view_zenith = dot(world_dir, zenith);\n\n\tlet side = normalize(cross(zenith, world_dir));\t// assumes non parallel vectors\n\tlet forward = normalize(cross(side, zenith));\t// aligns toward the sun light but perpendicular to up vector\n\tlet cos_light_view = normalize(vec2(dot(sun_dir, forward), dot(sun_dir, side))).x;\n\n\tlet intersects_ground = ray_intersects_sphere(world_pos, world_dir, vec3(), atmosphere.bottom_radius);\n\n\tlet uv = sky_view_lut_params_to_uv(atmosphere, intersects_ground, cos_view_zenith, cos_light_view, view_height);\n\n\tlet sky_view = textureSampleLevel(sky_view_lut, lut_sampler, uv, 0);\n\n\treturn vec4(sky_view.rgb + get_sun_luminance(world_pos, world_dir, atmosphere, config), sky_view.a);\n}\n\nfn render_sky(pix: vec2<u32>) -> vec4<f32> {\n\tlet atmosphere = atmosphere_buffer;\n\tlet config = config_buffer;\n\n\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\n\n\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\n\tvar world_pos = config.camera_world_position - atmosphere.planet_center;\n\tlet sun_dir = normalize(config.sun.direction);\n\n\tlet view_height = length(world_pos);\n\t\n\tlet depth = textureLoad(depth_buffer, pix, 0).r;\n\tif !is_valid_depth(depth) {\n\t\treturn use_sky_view_lut(view_height, world_pos, world_dir, sun_dir, atmosphere, config);\n\t}\n\n\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\n\tlet t_depth = length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center));\n\n\tvar slice = aerial_perspective_depth_to_slice(t_depth);\n\tvar weight = 1.0;\n\tif slice < 0.5 {\n\t\t// We multiply by weight to fade to 0 at depth 0. That works for luminance and opacity.\n\t\tweight = saturate(slice * 2.0);\n\t\tslice = 0.5;\n\t}\n\tlet w = sqrt(slice / AP_SLICE_COUNT);\t// squared distribution\n\n\tlet aerial_perspective = textureSampleLevel(aerial_perspective_lut, lut_sampler, vec3<f32>(uv, w), 0);\n\n\tif t_depth > (AP_SLICE_COUNT * AP_DISTANCE_PER_SLICE) && all(aerial_perspective == vec4<f32>(0, 0, 0, 1)) {\n\t\treturn vec4();\n\t}\n\n\treturn weight * aerial_perspective;\n}\n\nstruct RenderSkyFragment {\n\t@location(0) luminance: vec4<f32>,\n\t@location(1) transmittance: vec4<f32>,\n}\n\n@fragment\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\n\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\n\treturn RenderSkyFragment(vec4(result.rgb, 1.0), vec4(vec3(result.a), 1.0));\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(render_target));\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\tblend(global_id.xy, render_sky(global_id.xy));\n}\n\n".replace("rgba16float",e);if(t){i=i.replace("let config = config_buffer","let config = get_uniforms()"),i=i.replace("@group(0) @binding(1) var<uniform> config_buffer: Uniforms;","");for(let e=2;e<9;++e)i=i.replace(`group(0) @binding(${e})`,`group(0) @binding(${e-1})`)}return`${n}\n${i}`}function D(e="rgba16float",t,n){const i=`${b}\n${S}\n${L}\n${P}\n${E}\n${z}\n${n?`${n}\n${y}\n`:""}${w}\n${k}\n${v}\n${R}\n${x}\n${T}\n`;let r="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride USE_MOON: bool = false;\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\noverride USE_COLORED_TRANSMISSION: bool = true;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\n@group(0) @binding(2) var lut_sampler: sampler;\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\n@group(0) @binding(5) var depth_buffer: texture_2d<f32>;\n@group(0) @binding(6) var backbuffer: texture_2d<f32>;\n@group(0) @binding(7) var render_target: texture_storage_2d<rgba16float, write>;\n\nfn get_sample_shadow(atmosphere: Atmosphere, sample_position: vec3<f32>, light_index: u32) -> f32 {\n\treturn get_shadow(sample_position + atmosphere.planet_center, light_index);\n}\n\nstruct SingleScatteringResult {\n\tluminance: vec3<f32>,\t\t\t\t// Scattered light (luminance)\n\ttransmittance: vec3<f32>,\t\t\t// transmittance in [0,1] (unitless)\n}\n\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, depth: f32, config: Uniforms) -> SingleScatteringResult {\n\tvar result = SingleScatteringResult();\n\n\tlet planet_center = vec3<f32>();\n\tvar t_max: f32 = 0.0;\n\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\treturn result;\n\t}\n\n\tif is_valid_depth(depth) {\n\t\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\n\t\tt_max = min(t_max, length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center)));\n\t}\n\tt_max = min(t_max, t_max_max);\n\n\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\n\tlet sample_count_floored = floor(sample_count);\n\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\n\tlet t_max_floored = t_max * sample_count_floored / sample_count;\n\tlet sample_segment_t = get_sample_segment_t(uv, config);\n\n\tlet sun_direction = normalize(config.sun.direction);\n\tlet sun_illuminance = config.sun.illuminance;\n\n\tlet cos_theta = dot(sun_direction, world_dir);\n\tlet mie_phase_val = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta);\n\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\n\n\tvar moon_direction = config.moon.direction;\n\tvar moon_illuminance = config.moon.illuminance;\n\n\tvar cos_theta_moon = 0.0;\n\tvar mie_phase_val_moon = 0.0;\n\tvar rayleigh_phase_val_moon = 0.0;\n\n\tif USE_MOON {\n\t\tmoon_direction = normalize(moon_direction);\n\t\tmoon_illuminance = config.moon.illuminance;\n\n\t\tcos_theta_moon = dot(moon_direction, world_dir);\n\t\tmie_phase_val_moon = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta_moon);\n\t\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\n\t}\n\n\tresult.luminance = vec3(0.0);\n\tresult.transmittance = vec3(1.0);\n\tvar t = 0.0;\n\tvar dt = 0.0;\n\tfor (var s = 0.0; s < sample_count; s += 1.0) {\n\t\tvar t0 = s * inv_sample_count_floored;\n\t\tvar t1 = (s + 1.0) * inv_sample_count_floored;\n\t\tt0 = (t0 * t0) * t_max_floored;\n\t\tt1 = t1 * t1;\n\t\tif t1 > 1.0 {\n\t\t\tt1 = t_max;\n\t\t} else {\n\t\t\tt1 = t_max_floored * t1;\n\t\t}\n\t\tdt = t1 - t0;\n\t\tt = t0 + dt * sample_segment_t;\n\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height= length(sample_pos);\n\n\t\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\n\t\tlet sample_transmittance = exp(-medium.extinction * dt);\n\n\t\tlet zenith = sample_pos / sample_height;\n \n\t\tlet cos_sun_zenith = dot(sun_direction, zenith);\n\t\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\n\t\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\n\t\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\n\t\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\n\n\t\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\n\n\t\tif USE_MOON {\n\t\t\tlet cos_moon_zenith = dot(moon_direction, zenith);\n\t\t\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\n\t\t\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\n\t\t\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\n\t\t\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\t\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\n\n\t\t\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\n\t\t}\n\n\t\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\n\t\tresult.luminance += result.transmittance * intergrated_luminance;\n\t\tresult.transmittance *= sample_transmittance;\n\t}\n\n\treturn result;\n}\n\nstruct RenderSkyResult {\n\tluminance: vec4<f32>,\n\ttransmittance: vec4<f32>,\n}\n\nfn render_sky(pix: vec2<u32>) -> RenderSkyResult {\n\tlet atmosphere = atmosphere_buffer;\n\tlet config = config_buffer;\n\n\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\n\n\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\n\tvar world_pos = config.camera_world_position - atmosphere.planet_center;\n\tlet sun_dir = normalize(config.sun.direction);\n\n\tlet view_height = length(world_pos);\n\t\n\tvar luminance = vec3<f32>();\n\t\n\tlet depth = textureLoad(depth_buffer, pix, 0).r;\n\tif !is_valid_depth(depth) {\n\t\tluminance += get_sun_luminance(world_pos, world_dir, atmosphere, config);\n\t}\n\n\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\n\t\tluminance = get_sun_luminance(world_pos, world_dir, atmosphere, config);\n\t\treturn RenderSkyResult(max(vec4(luminance, 1.0), vec4()), max(vec4(0.0, 0.0, 0.0, 1.0), vec4()));\n\t}\n\t\n\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, depth, config);\n\tluminance += ss.luminance;\n\n\treturn RenderSkyResult(max(vec4(luminance, 1.0), vec4()), max(vec4(ss.transmittance, 1.0), vec4()));\n}\n\nstruct RenderSkyFragment {\n\t@location(0) luminance: vec4<f32>,\n\t@location(1) transmittance: vec4<f32>,\n}\n\n@fragment\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\n\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\n\treturn RenderSkyFragment(result.luminance, result.transmittance);\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y)\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(render_target));\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\tlet result = render_sky(global_id.xy);\n\tif USE_COLORED_TRANSMISSION {\n\t\tdual_source_blend(global_id.xy, result.luminance, result.transmittance);\n\t} else {\n\t\tblend(global_id.xy, vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))));\n\t}\n}\n\n".replace("rgba16float",e);if(n){r=r.replace("let config = config_buffer","let config = get_uniforms()"),r=r.replace("@group(0) @binding(1) var<uniform> config_buffer: Uniforms;","");for(let e=2;e<9;++e)r=r.replace(`group(0) @binding(${e})`,`group(0) @binding(${e-1})`)}return`${G(t)}\n${i}\n${r}`}function N(e="rgba16float",t,n){const i=`${b}\n${S}\n${L}\n${P}\n${E}\n${z}\n${n?`${n}\n${y}\n`:""}${w}\n${k}\n${U}\n${v}\n${R}\n${x}\n${T}\n`;let r="/*\n * Copyright (c) 2024 Lukas Herzberger\n * Copyright (c) 2020 Epic Games, Inc.\n * SPDX-License-Identifier: MIT\n */\n\noverride USE_MOON: bool = false;\noverride INV_DISTANCE_TO_MAX_SAMPLE_COUNT: f32 = 1.0 / 100.0;\noverride USE_COLORED_TRANSMISSION: bool = true;\n\noverride WORKGROUP_SIZE_X: u32 = 16;\noverride WORKGROUP_SIZE_Y: u32 = 16;\n\n@group(0) @binding(0) var<uniform> atmosphere_buffer: Atmosphere;\n@group(0) @binding(1) var<uniform> config_buffer: Uniforms;\n@group(0) @binding(2) var lut_sampler: sampler;\n@group(0) @binding(3) var transmittance_lut: texture_2d<f32>;\n@group(0) @binding(4) var multi_scattering_lut: texture_2d<f32>;\n@group(0) @binding(5) var sky_view_lut: texture_2d<f32>;\n@group(0) @binding(6) var depth_buffer: texture_2d<f32>;\n@group(0) @binding(7) var backbuffer: texture_2d<f32>;\n@group(0) @binding(8) var render_target: texture_storage_2d<rgba16float, write>;\n\nfn use_sky_view_lut(view_height: f32, world_pos: vec3<f32>, world_dir: vec3<f32>, sun_dir: vec3<f32>, atmosphere: Atmosphere, config: Uniforms) -> vec4<f32> {\n\tlet zenith = normalize(world_pos);\n\tlet cos_view_zenith = dot(world_dir, zenith);\n\n\tlet side = normalize(cross(zenith, world_dir));\t// assumes non parallel vectors\n\tlet forward = normalize(cross(side, zenith));\t// aligns toward the sun light but perpendicular to up vector\n\tlet cos_light_view = normalize(vec2(dot(sun_dir, forward), dot(sun_dir, side))).x;\n\n\tlet intersects_ground = ray_intersects_sphere(world_pos, world_dir, vec3(), atmosphere.bottom_radius);\n\n\tlet uv = sky_view_lut_params_to_uv(atmosphere, intersects_ground, cos_view_zenith, cos_light_view, view_height);\n\n\tlet sky_view = textureSampleLevel(sky_view_lut, lut_sampler, uv, 0);\n\n\treturn vec4(sky_view.rgb + get_sun_luminance(world_pos, world_dir, atmosphere, config), sky_view.a);\n}\n\nfn get_sample_shadow(atmosphere: Atmosphere, sample_position: vec3<f32>, light_index: u32) -> f32 {\n\treturn get_shadow(sample_position + atmosphere.planet_center, light_index);\n}\n\nstruct SingleScatteringResult {\n\tluminance: vec3<f32>,\t\t\t\t// Scattered light (luminance)\n\ttransmittance: vec3<f32>,\t\t\t// transmittance in [0,1] (unitless)\n}\n\nfn integrate_scattered_luminance(uv: vec2<f32>, world_pos: vec3<f32>, world_dir: vec3<f32>, atmosphere: Atmosphere, depth: f32, config: Uniforms) -> SingleScatteringResult {\n\tvar result = SingleScatteringResult();\n\n\tlet planet_center = vec3<f32>();\n\tvar t_max: f32 = 0.0;\n\tif !find_atmosphere_t_max(&t_max, world_pos, world_dir, planet_center, atmosphere.bottom_radius, atmosphere.top_radius) {\n\t\treturn result;\n\t}\n\n\tif is_valid_depth(depth) {\n\t\tlet depth_buffer_world_pos = uv_and_depth_to_world_pos(uv, config.inverse_projection, config.inverse_view, depth);\n\t\tt_max = min(t_max, length(depth_buffer_world_pos - (world_pos + atmosphere.planet_center)));\n\t}\n\tt_max = min(t_max, t_max_max);\n\n\tlet sample_count = mix(config.ray_march_min_spp, config.ray_march_max_spp, saturate(t_max * INV_DISTANCE_TO_MAX_SAMPLE_COUNT));\n\tlet sample_count_floored = floor(sample_count);\n\tlet inv_sample_count_floored = 1.0 / sample_count_floored;\n\tlet t_max_floored = t_max * sample_count_floored / sample_count;\n\tlet sample_segment_t = get_sample_segment_t(uv, config);\n\n\tlet sun_direction = normalize(config.sun.direction);\n\tlet sun_illuminance = config.sun.illuminance;\n\n\tlet cos_theta = dot(sun_direction, world_dir);\n\tlet mie_phase_val = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta);\n\tlet rayleigh_phase_val = rayleigh_phase(cos_theta);\n\n\tvar moon_direction = config.moon.direction;\n\tvar moon_illuminance = config.moon.illuminance;\n\n\tvar cos_theta_moon = 0.0;\n\tvar mie_phase_val_moon = 0.0;\n\tvar rayleigh_phase_val_moon = 0.0;\n\n\tif USE_MOON {\n\t\tmoon_direction = normalize(moon_direction);\n\t\tmoon_illuminance = config.moon.illuminance;\n\n\t\tcos_theta_moon = dot(moon_direction, world_dir);\n\t\tmie_phase_val_moon = cornette_shanks_phase(atmosphere.mie_phase_g, -cos_theta_moon);\n\t\trayleigh_phase_val_moon = rayleigh_phase(cos_theta_moon);\n\t}\n\n\tresult.luminance = vec3(0.0);\n\tresult.transmittance = vec3(1.0);\n\tvar t = 0.0;\n\tvar dt = 0.0;\n\tfor (var s = 0.0; s < sample_count; s += 1.0) {\n\t\tvar t0 = s * inv_sample_count_floored;\n\t\tvar t1 = (s + 1.0) * inv_sample_count_floored;\n\t\tt0 = (t0 * t0) * t_max_floored;\n\t\tt1 = t1 * t1;\n\t\tif t1 > 1.0 {\n\t\t\tt1 = t_max;\n\t\t} else {\n\t\t\tt1 = t_max_floored * t1;\n\t\t}\n\t\tdt = t1 - t0;\n\t\tt = t0 + dt * sample_segment_t;\n\n\t\tlet sample_pos = world_pos + t * world_dir;\n\t\tlet sample_height= length(sample_pos);\n\n\t\tlet medium = sample_medium(sample_height - atmosphere.bottom_radius, atmosphere);\n\t\tlet sample_transmittance = exp(-medium.extinction * dt);\n\n\t\tlet zenith = sample_pos / sample_height;\n \n\t\tlet cos_sun_zenith = dot(sun_direction, zenith);\n\t\tlet transmittance_to_sun = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_sun_zenith), 0).rgb;\n\t\tlet phase_times_scattering = medium.mie_scattering * mie_phase_val + medium.rayleigh_scattering * rayleigh_phase_val;\n\t\tlet multi_scattered_luminance = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_sun_zenith);\n\t\tlet planet_shadow = compute_planet_shadow(sample_pos, sun_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\tlet shadow = get_sample_shadow(atmosphere, sample_pos, 0);\n\n\t\tvar scattered_luminance = sun_illuminance * (planet_shadow * shadow * transmittance_to_sun * phase_times_scattering + multi_scattered_luminance * medium.scattering);\n\n\t\tif USE_MOON {\n\t\t\tlet cos_moon_zenith = dot(moon_direction, zenith);\n\t\t\tlet transmittance_to_moon = textureSampleLevel(transmittance_lut, lut_sampler, transmittance_lut_params_to_uv(atmosphere, sample_height, cos_moon_zenith), 0).rgb;\n\t\t\tlet phase_times_scattering_moon = medium.mie_scattering * mie_phase_val_moon + medium.rayleigh_scattering * rayleigh_phase_val_moon;\n\t\t\tlet multi_scattered_luminance_moon = get_multiple_scattering(atmosphere, medium.scattering, medium.extinction, sample_pos, cos_moon_zenith);\n\t\t\tlet planet_shadow_moon = compute_planet_shadow(sample_pos, moon_direction, planet_center + planet_radius_offset * zenith, atmosphere.bottom_radius);\n\t\t\tlet shadow_moon = get_sample_shadow(atmosphere, sample_pos, 1);\n\n\t\t\tscattered_luminance += moon_illuminance * (planet_shadow_moon * shadow_moon * transmittance_to_moon * phase_times_scattering_moon + multi_scattered_luminance_moon * medium.scattering);\n\t\t}\n\n\t\tlet intergrated_luminance = (scattered_luminance - scattered_luminance * sample_transmittance) / medium.extinction;\n\t\tresult.luminance += result.transmittance * intergrated_luminance;\n\t\tresult.transmittance *= sample_transmittance;\n\t}\n\n\treturn result;\n}\n\nstruct RenderSkyResult {\n\tluminance: vec4<f32>,\n\ttransmittance: vec4<f32>,\n}\n\nfn render_sky(pix: vec2<u32>) -> RenderSkyResult {\n\tlet atmosphere = atmosphere_buffer;\n\tlet config = config_buffer;\n\n\tlet uv = (vec2<f32>(pix) + 0.5) / vec2<f32>(config.screen_resolution);\n\n\tlet world_dir = uv_to_world_dir(uv, config.inverse_projection, config.inverse_view);\n\tvar world_pos = config.camera_world_position - atmosphere.planet_center;\n\tlet sun_dir = normalize(config.sun.direction);\n\n\tlet view_height = length(world_pos);\n\n\tlet depth = textureLoad(depth_buffer, pix, 0).r;\n\tif !is_valid_depth(depth) {\n\t\tlet sky_view = use_sky_view_lut(view_height, world_pos, world_dir, sun_dir, atmosphere, config);\n\t\treturn RenderSkyResult(vec4<f32>(sky_view.rgb, 1.0), vec4<f32>(vec3<f32>(sky_view.a), 1.0));\n\t}\n\t\n\tif !move_to_atmosphere_top(&world_pos, world_dir, atmosphere.top_radius) {\n\t\tlet black = vec4(vec3(), 1.0);\n\t\treturn RenderSkyResult(black, black);\n\t}\n\t\n\tlet ss = integrate_scattered_luminance(uv, world_pos, world_dir, atmosphere, depth, config);\n\n\treturn RenderSkyResult(max(vec4(ss.luminance, 1.0), vec4()), max(vec4(ss.transmittance, 1.0), vec4()));\n}\n\nstruct RenderSkyFragment {\n\t@location(0) luminance: vec4<f32>,\n\t@location(1) transmittance: vec4<f32>,\n}\n\n@fragment\nfn fragment(@builtin(position) coord: vec4<f32>) -> RenderSkyFragment {\n\tlet result = render_sky(vec2<u32>(floor(coord.xy)));\n\treturn RenderSkyFragment(result.luminance, result.transmittance);\n}\n\n@compute\n@workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y)\nfn render_sky_atmosphere(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\tlet output_size = vec2<u32>(textureDimensions(render_target));\n\tif output_size.x <= global_id.x || output_size.y <= global_id.y {\n\t\treturn;\n\t}\n\tlet result = render_sky(global_id.xy);\n\tif USE_COLORED_TRANSMISSION {\n\t\tdual_source_blend(global_id.xy, result.luminance, result.transmittance);\n\t} else {\n\t\tblend(global_id.xy, vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))));\n\t}\n}\n\n".replace("rgba16float",e);if(n){r=r.replace("let config = config_buffer","let config = get_uniforms()"),r=r.replace("@group(0) @binding(1) var<uniform> config_buffer: Uniforms;","");for(let e=2;e<9;++e)r=r.replace(`group(0) @binding(${e})`,`group(0) @binding(${e-1})`)}return`${G(t)}\n${i}\n${r}`}class B{device;pipeline;bindGroupLayout;transmittanceLutFormat;constructor(e,t,n,i){this.device=e,this.pipeline=t,this.bindGroupLayout=n,this.transmittanceLutFormat=i}static makeBindGroupLayout(e,t){return e.createBindGroupLayout({label:"transmittance LUT pass",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:m}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:t,viewDimension:"2d"}}]})}static makePipelineDescriptor(e,t,n,i){return{label:"transmittance LUT pass",layout:e.createPipelineLayout({label:"transmittance LUT pass",bindGroupLayouts:[t]}),compute:{module:e.createShaderModule({code:M(n)}),entryPoint:"render_transmittance_lut",constants:{SAMPLE_COUNT:Math.max(i,40)}}}}static async createAsync(e,t,n){const i=this.makeBindGroupLayout(e,t),r=await e.createComputePipelineAsync(this.makePipelineDescriptor(e,i,t,n));return new B(e,r,i,t)}static create(e,t,n){const i=this.makeBindGroupLayout(e,t),r=e.createComputePipeline(this.makePipelineDescriptor(e,i,t,n));return new B(e,r,i,t)}makeComputePass(e){if(this.device!==e.device)throw new Error("[TransmittanceLutPipeline::makeComputePass]: device mismatch");if(e.atmosphereBuffer.size<m)throw new Error(`[TransmittanceLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${e.atmosphereBuffer.size} < ${m})`);if(e.transmittanceLut.texture.format!==this.transmittanceLutFormat)throw new Error(`[TransmittanceLutPipeline::makeComputePass]: wrong texture format for transmittance LUT. expected '${this.transmittanceLutFormat}', got ${e.transmittanceLut.texture.format}`);const t=e.device.createBindGroup({label:`transmittance LUT pass [${e.label}]`,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.atmosphereBuffer}},{binding:1,resource:e.transmittanceLut.texture.createView()}]});return new n(this.pipeline,[t],[Math.ceil(e.transmittanceLut.texture.width/16),Math.ceil(e.transmittanceLut.texture.height/16),1])}}class ${device;pipeline;bindGroupLayout;multiScatteringLutFormat;constructor(e,t,n,i){this.device=e,this.pipeline=t,this.bindGroupLayout=n,this.multiScatteringLutFormat=i}static makeBindGroupLayout(e,t){return e.createBindGroupLayout({label:"mulitple scattering LUT pass",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:m}},{binding:1,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}},{binding:3,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:t,viewDimension:"2d"}}]})}static makePipelineDescriptor(e,t,n,i){return{label:"mulitple scattering LUT pass",layout:e.createPipelineLayout({label:"mulitple scattering LUT pass",bindGroupLayouts:[t]}),compute:{module:e.createShaderModule({code:I(n)}),entryPoint:"render_multi_scattering_lut",constants:{SAMPLE_COUNT:Math.max(i,10)}}}}static async createAsync(e,t,n){const i=this.makeBindGroupLayout(e,t),r=await e.createComputePipelineAsync(this.makePipelineDescriptor(e,i,t,n));return new $(e,r,i,t)}static create(e,t,n){const i=this.makeBindGroupLayout(e,t),r=e.createComputePipeline(this.makePipelineDescriptor(e,i,t,n));return new $(e,r,i,t)}makeComputePass(e){if(this.device!==e.device)throw new Error("[MultiScatteringLutPipeline::makeComputePass]: device mismatch");if(e.atmosphereBuffer.size<m)throw new Error(`[MultiScatteringLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${e.atmosphereBuffer.size} < ${m})`);if(e.multiScatteringLut.texture.format!==this.multiScatteringLutFormat)throw new Error(`[MultiScatteringLutPipeline::makeComputePass]: wrong texture format for multiple scattering LUT. expected '${this.multiScatteringLutFormat}', got ${e.multiScatteringLut.texture.format}`);const t=e.device.createBindGroup({label:`mulitple scattering LUT pass [${e.label}]`,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.atmosphereBuffer}},{binding:1,resource:e.lutSampler},{binding:2,resource:e.transmittanceLut.view},{binding:3,resource:e.multiScatteringLut.texture.createView()}]});return new n(this.pipeline,[t],[e.multiScatteringLut.texture.width,e.multiScatteringLut.texture.height,1])}}class V{device;pipeline;bindGroupLayout;skyViewLutFormat;skyViewLutSize;multiscatteringLutSize;constructor(e,t,n,i,r,s){this.device=e,this.pipeline=t,this.bindGroupLayout=n,this.skyViewLutFormat=i,this.skyViewLutSize=r,this.multiscatteringLutSize=s}static makeBindGroupLayout(e,t,n){return e.createBindGroupLayout({label:"sky view LUT pass",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:m}},n?void 0:{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:p}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}},{binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}},{binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:t,viewDimension:"2d"}}].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))})}static makePipelineDescriptor(e,t,n,i,r,s,a,o,_){return{label:"sky view LUT pass",layout:e.createPipelineLayout({label:"sky view LUT pass",bindGroupLayouts:[t,...o?.bindGroupLayouts??[],..._?.bindGroupLayouts??[]]}),compute:{module:e.createShaderModule({label:"sky view LUT",code:C(n,o?.wgslCode,_?.wgslCode)}),entryPoint:"render_sky_view_lut",constants:{SKY_VIEW_LUT_RES_X:i[0],SKY_VIEW_LUT_RES_Y:i[1],INV_DISTANCE_TO_MAX_SAMPLE_COUNT:1/s,MULTI_SCATTERING_LUT_RES_X:r[0],MULTI_SCATTERING_LUT_RES_Y:r[1],USE_MOON:Number(a)}}}}static async createAsync(e,t,n,i,r,s,a,o){const _=this.makeBindGroupLayout(e,t,o),l=await e.createComputePipelineAsync(this.makePipelineDescriptor(e,_,t,n,i,r,s,a,o));return new V(e,l,_,t,n,i)}static create(e,t,n,i,r,s,a,o){const _=this.makeBindGroupLayout(e,t,o),l=e.createComputePipeline(this.makePipelineDescriptor(e,_,t,n,i,r,s,a,o));return new V(e,l,_,t,n,i)}makeComputePass(e,t,i){if(this.device!==e.device)throw new Error("[SkyViewLutPipeline::makeComputePass]: device mismatch");if(e.atmosphereBuffer.size<m)throw new Error(`[SkyViewLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${e.atmosphereBuffer.size} < ${m})`);if(e.uniformsBuffer&&e.uniformsBuffer.size<p)throw new Error(`[SkyViewLutPipeline::makeComputePass]: buffer too small for config (${e.atmosphereBuffer.size} < ${m})`);if(e.multiScatteringLut.texture.width!==this.multiscatteringLutSize[0]||e.multiScatteringLut.texture.height!==this.multiscatteringLutSize[1])throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture size for multiple scattering LUT. expected '${this.multiscatteringLutSize}', got ${[e.multiScatteringLut.texture.width,e.multiScatteringLut.texture.height]}`);if(e.skyViewLut.texture.format!==this.skyViewLutFormat)throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture format for sky view LUT. expected '${this.skyViewLutFormat}', got ${e.skyViewLut.texture.format}`);if(e.skyViewLut.texture.width!==this.skyViewLutSize[0]||e.skyViewLut.texture.height!==this.skyViewLutSize[1])throw new Error(`[SkyViewLutPipeline::makeComputePass]: wrong texture size for sky view LUT. expected '${this.skyViewLutSize}', got ${[e.skyViewLut.texture.width,e.skyViewLut.texture.height]}`);const r=e.device.createBindGroup({label:`sky view LUT pass [${e.label}]`,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.atmosphereBuffer}},i?void 0:{binding:1,resource:{buffer:e.uniformsBuffer}},{binding:2,resource:e.lutSampler},{binding:3,resource:e.transmittanceLut.view},{binding:4,resource:e.multiScatteringLut.view},{binding:5,resource:e.skyViewLut.texture.createView()}].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))});return new n(this.pipeline,[r,...t??[],...i??[]],[Math.ceil(e.skyViewLut.texture.width/16),Math.ceil(e.skyViewLut.texture.height/16),1])}}class F{device;pipeline;bindGroupLayout;aerialPerspectiveLutFormat;aerialPerspectiveSliceCount;aerialPerspectiveDistancePerSlice;multiscatteringLutSize;constructor(e,t,n,i,r,s,a){this.device=e,this.pipeline=t,this.bindGroupLayout=n,this.aerialPerspectiveLutFormat=i,this.aerialPerspectiveSliceCount=r,this.aerialPerspectiveDistancePerSlice=s,this.multiscatteringLutSize=a}static makeBindGroupLayout(e,t,n){return e.createBindGroupLayout({label:"aerial perspective LUT pass",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:m}},n?void 0:{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:p}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}},{binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}},{binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:t,viewDimension:"3d"}}].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))})}static makePipelineDescriptor(e,t,n,i,r,s,a,o,_,l){return{label:"aerial perspective LUT pass",layout:e.createPipelineLayout({label:"aerial perspective LUT pass",bindGroupLayouts:[t,..._?.bindGroupLayouts??[],...l?.bindGroupLayouts??[]]}),compute:{module:e.createShaderModule({label:"aerial perspective LUT",code:O(n,_?.wgslCode,l?.wgslCode)}),entryPoint:"render_aerial_perspective_lut",constants:{AP_SLICE_COUNT:i,AP_DISTANCE_PER_SLICE:r,MULTI_SCATTERING_LUT_RES_X:s[0],MULTI_SCATTERING_LUT_RES_Y:s[1],RANDOMIZE_SAMPLE_OFFSET:Number(a),USE_MOON:Number(o)}}}}static async createAsync(e,t,n,i,r,s,a,o,_){const l=this.makeBindGroupLayout(e,t,_),u=await e.createComputePipelineAsync(this.makePipelineDescriptor(e,l,t,n,i,r,s,a,o,_));return new F(e,u,l,t,n,i,r)}static create(e,t,n,i,r,s,a,o,_){const l=this.makeBindGroupLayout(e,t,_),u=e.createComputePipeline(this.makePipelineDescriptor(e,l,t,n,i,r,s,a,o,_));return new F(e,u,l,t,n,i,r)}makeComputePass(e,t,i){if(this.device!==e.device)throw new Error("[AerialPerspectiveLutPipeline::makeComputePass]: device mismatch");if(e.atmosphereBuffer.size<m)throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: buffer too small for atmosphere parameters (${e.atmosphereBuffer.size} < ${m})`);if(e.uniformsBuffer&&e.uniformsBuffer.size<p)throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: buffer too small for config (${e.atmosphereBuffer.size} < ${m})`);if(e.multiScatteringLut.texture.width!==this.multiscatteringLutSize[0]||e.multiScatteringLut.texture.height!==this.multiscatteringLutSize[1])throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture size for multiple scattering LUT. expected '${this.multiscatteringLutSize}', got ${[e.multiScatteringLut.texture.width,e.multiScatteringLut.texture.height]}`);if(e.aerialPerspectiveLut.texture.format!==this.aerialPerspectiveLutFormat)throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture format for aerial perspective LUT. expected '${this.aerialPerspectiveLutFormat}', got ${e.aerialPerspectiveLut.texture.format}`);if(e.aerialPerspectiveLut.texture.depthOrArrayLayers!==this.aerialPerspectiveSliceCount)throw new Error(`[AerialPerspectiveLutPipeline::makeComputePass]: wrong texture depth for aerial perspective LUT. expected '${this.aerialPerspectiveSliceCount}', got ${e.aerialPerspectiveLut.texture.depthOrArrayLayers}`);const r=e.device.createBindGroup({label:`aerial perspective LUT pass [${e.label}]`,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.atmosphereBuffer}},i?void 0:{binding:1,resource:{buffer:e.uniformsBuffer}},{binding:2,resource:e.lutSampler},{binding:3,resource:e.transmittanceLut.view},{binding:4,resource:e.multiScatteringLut.view},{binding:5,resource:e.aerialPerspectiveLut.texture.createView()}].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))});return new n(this.pipeline,[r,...t??[],...i??[]],[Math.ceil(e.aerialPerspectiveLut.texture.width/16),Math.ceil(e.aerialPerspectiveLut.texture.height/16),e.aerialPerspectiveLut.texture.depthOrArrayLayers])}get aerialPerspectiveInvDistancePerSlice(){return 1/this.aerialPerspectiveDistancePerSlice}}class X{transmittanceLutPipeline;multiScatteringLutPipeline;skyViewLutPipeline;aerialPerspectiveLutPipeline;constructor(e,t,n,i){this.transmittanceLutPipeline=e,this.multiScatteringLutPipeline=t,this.skyViewLutPipeline=n,this.aerialPerspectiveLutPipeline=i}static getTransmittanceLutArgs(e){return[e.lookUpTables?.transmittanceLut?.format??_,e.lookUpTables?.transmittanceLut?.sampleCount??40]}static getMultiScatteringLutArgs(e){return[e.lookUpTables?.multiScatteringLut?.format??l,e.lookUpTables?.multiScatteringLut?.sampleCount??20]}static getSkyViewLutArgs(e){return[e.lookUpTables?.skyViewLut?.format??u,e.lookUpTables?.skyViewLut?.size??a,e.lookUpTables?.multiScatteringLut?.size??[s,s],e.skyRenderer?.distanceToMaxSampleCount??100*(e.distanceScaleFactor??1),e.lights?.useMoon??!1,e.lookUpTables?.skyViewLut?.affectedByShadow??1?e.shadow:void 0,e.customUniformsSource]}static getAerialPerspectiveLutArgs(e){return[e.lookUpTables?.aerialPerspectiveLut?.format??c,(e.lookUpTables?.aerialPerspectiveLut?.size??o)[2],e.lookUpTables?.aerialPerspectiveLut?.distancePerSlice??4*(e.distanceScaleFactor??1),e.lookUpTables?.multiScatteringLut?.size??[s,s],e.lookUpTables?.aerialPerspectiveLut?.randomizeRayOffsets??!1,e.lights?.useMoon??!1,e.lookUpTables?.aerialPerspectiveLut?.affectedByShadow??1?e.shadow:void 0,e.customUniformsSource]}static async createAsync(e,t){const n=this.getTransmittanceLutArgs(t),i=this.getMultiScatteringLutArgs(t),r=this.getSkyViewLutArgs(t),s=this.getAerialPerspectiveLutArgs(t),a=B.createAsync(e,n[0],n[1]),o=$.createAsync(e,i[0],i[1]),_=V.createAsync(e,r[0],r[1],r[2],r[3],r[4],r[5],r[6]),l=F.createAsync(e,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7]);return new X(await a,await o,await _,await l)}static create(e,t){const n=this.getTransmittanceLutArgs(t),i=this.getMultiScatteringLutArgs(t),r=this.getSkyViewLutArgs(t),s=this.getAerialPerspectiveLutArgs(t),a=B.create(e,n[0],n[1]),o=$.create(e,i[0],i[1]),_=V.create(e,r[0],r[1],r[2],r[3],r[4],r[5],r[6]),l=F.create(e,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7]);return new X(a,o,_,l)}}class W{resources;lutPipelines;defaultToFullResolutionRayMarch;usesCustomUniforms;transmittanceLutPass;multiScatteringLutPass;skyViewLutPass;aerialPerspectiveLutPass;constructor(e,t,n,i,r,s,a,o,_){e?(this.resources=e.resources,this.lutPipelines=e.lutPipelines,this.defaultToFullResolutionRayMarch=e.defaultToFullResolutionRayMarch,this.usesCustomUniforms=e.usesCustomUniforms,this.transmittanceLutPass=e.transmittanceLutPass,this.multiScatteringLutPass=e.multiScatteringLutPass,this.skyViewLutPass=e.skyViewLutPass,this.aerialPerspectiveLutPass=e.aerialPerspectiveLutPass):(this.resources=t,this.lutPipelines=n,this.defaultToFullResolutionRayMarch=i,this.usesCustomUniforms=r,this.transmittanceLutPass=s,this.multiScatteringLutPass=a,this.skyViewLutPass=o,this.aerialPerspectiveLutPass=_)}static create(e,t,n,i){let r;r=(n?.transmittanceLutPipeline.device||e)!==e?X.create(e,t):n||X.create(e,t);const s=t.skyRenderer?.defaultToPerPixelRayMarch??!1,a=void 0!==t.customUniformsSource,o=i||new d(e,t),_=r.transmittanceLutPipeline.makeComputePass(o),l=r.multiScatteringLutPipeline.makeComputePass(o),u=r.skyViewLutPipeline.makeComputePass(o,t.lookUpTables?.skyViewLut?.affectedByShadow??1?t.shadow?.bindGroups:void 0,t.customUniformsSource?.bindGroups),c=r.aerialPerspectiveLutPipeline.makeComputePass(o,t.lookUpTables?.aerialPerspectiveLut?.affectedByShadow??1?t.shadow?.bindGroups:void 0,t.customUniformsSource?.bindGroups),m=new W(void 0,o,r,s,a,_,l,u,c);if(t.initializeConstantLuts??1){const t=e.createCommandEncoder(),n=t.beginComputePass();m.renderConstantLuts(n),n.end(),e.queue.submit([t.finish()])}return m}static async createAsync(e,t,n,i){let r;return r=(n?.transmittanceLutPipeline.device||e)!==e?await X.createAsync(e,t):n||await X.createAsync(e,t),this.create(e,t,r,i)}updateAtmosphere(e){this.resources.updateAtmosphere(e)}updateUniforms(e){this.usesCustomUniforms||this.resources.updateUniforms(e)}renderTransmittanceLut(e){this.transmittanceLutPass.encode(e)}renderMultiScatteringLut(e){this.multiScatteringLutPass.encode(e)}renderConstantLuts(e,t){t&&this.updateAtmosphere(t),this.renderTransmittanceLut(e),this.renderMultiScatteringLut(e)}renderSkyViewLut(e){this.skyViewLutPass.encode(e)}renderAerialPerspectiveLut(e){this.aerialPerspectiveLutPass.encode(e)}renderDynamicLuts(e,t){t&&this.updateUniforms(t),this.renderSkyViewLut(e),this.renderAerialPerspectiveLut(e)}renderLuts(e,t,n,i,r,s){(n||r)&&this.renderConstantLuts(e,n),i?(t&&this.updateUniforms(t),s&&this.renderSkyViewLut(e)):this.renderDynamicLuts(e,t)}}function K(e,t,n,i,r,s){const a=[{binding:0,visibility:s,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:m}},t.customUniformsSource?void 0:{binding:1,visibility:s,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:p}},{binding:2,visibility:s,sampler:{type:"filtering"}},{binding:3,visibility:s,texture:{sampleType:"float",viewDimension:i.transmittanceLut.texture.dimension,multisampled:!1}}].filter((e=>void 0!==e));return[e.createBindGroupLayout({label:`Render sky with luts bind group layout [${i.label}]`,entries:[...a,{binding:4,visibility:s,texture:{sampleType:"float",viewDimension:i.skyViewLut.texture.dimension,multisampled:!1}},{binding:5,visibility:s,texture:{sampleType:"float",viewDimension:i.aerialPerspectiveLut.texture.dimension,multisampled:!1}},...n].map(((e,t)=>(e.binding=t,e)))}),e.createBindGroupLayout({label:`Render sky raymarching bind group layout [${i.label}]`,entries:[...a,{binding:4,visibility:s,texture:{sampleType:"float",viewDimension:i.multiScatteringLut.texture.dimension,multisampled:!1}},r?void 0:{binding:5,visibility:s,texture:{sampleType:"float",viewDimension:i.skyViewLut.texture.dimension,multisampled:!1}},...n].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))})]}function q(e,t,n,i,r,s){const a=[{binding:0,resource:{buffer:e.atmosphereBuffer}},i?void 0:{binding:1,resource:{buffer:e.uniformsBuffer}},{binding:2,resource:e.lutSampler},{binding:3,resource:e.transmittanceLut.view}].filter((e=>void 0!==e));return[e.device.createBindGroup({label:`Render sky with LUTs bind group [${e.label}]`,layout:t,entries:[...a,{binding:4,resource:e.skyViewLut.view},{binding:5,resource:e.aerialPerspectiveLut.view},...r].map(((e,t)=>(e.binding=t,e)))}),e.device.createBindGroup({label:`Render sky raymarching bind group [${e.label}]`,layout:n,entries:[...a,{binding:4,resource:e.multiScatteringLut.view},s?void 0:{binding:5,resource:e.skyViewLut.view},...r].filter((e=>void 0!==e)).map(((e,t)=>(e.binding=t,e)))})]}function Y(e,t){return{AP_SLICE_COUNT:t.resources.aerialPerspectiveLut.texture.depthOrArrayLayers,AP_DISTANCE_PER_SLICE:t.lutPipelines.aerialPerspectiveLutPipeline.aerialPerspectiveDistancePerSlice,AP_INV_DISTANCE_PER_SLICE:t.lutPipelines.aerialPerspectiveLutPipeline.aerialPerspectiveInvDistancePerSlice,SKY_VIEW_LUT_RES_X:t.resources.skyViewLut.texture.width,SKY_VIEW_LUT_RES_Y:t.resources.skyViewLut.texture.height,IS_REVERSE_Z:Number(e.skyRenderer.depthBuffer.reverseZ??!1),RENDER_SUN_DISK:Number(e.lights?.renderSunDisk??!0),RENDER_MOON_DISK:Number(e.lights?.renderMoonDisk??e.lights?.useMoon??!1),LIMB_DARKENING_ON_SUN:Number(e.lights?.applyLimbDarkeningOnSun??!0),LIMB_DARKENING_ON_MOON:Number(e.lights?.applyLimbDarkeningOnMoon??!1),USE_MOON:Number(e.lights?.useMoon??!1)}}function Z(e,t,n){const i={INV_DISTANCE_TO_MAX_SAMPLE_COUNT:1/(e.skyRenderer.distanceToMaxSampleCount??100*(e.distanceScaleFactor??1)),RANDOMIZE_SAMPLE_OFFSET:Number(e.skyRenderer.rayMarch?.randomizeRayOffsets??!0),MULTI_SCATTERING_LUT_RES_X:t.resources.multiScatteringLut.texture.width,MULTI_SCATTERING_LUT_RES_Y:t.resources.multiScatteringLut.texture.height,IS_REVERSE_Z:Number(e.skyRenderer.depthBuffer.reverseZ??!1),RENDER_SUN_DISK:Number(e.lights?.renderSunDisk??!0),RENDER_MOON_DISK:Number(e.lights?.renderMoonDisk??e.lights?.useMoon??!1),LIMB_DARKENING_ON_SUN:Number(e.lights?.applyLimbDarkeningOnSun??!0),LIMB_DARKENING_ON_MOON:Number(e.lights?.applyLimbDarkeningOnMoon??!1),USE_MOON:Number(e.lights?.useMoon??!1)};return n||(i.SKY_VIEW_LUT_RES_X=t.resources.skyViewLut.texture.width,i.SKY_VIEW_LUT_RES_Y=t.resources.skyViewLut.texture.height),i}class H extends W{withLutsLayout;rayMarchLayout;rayMarchDistantSky;withLutsPass;rayMarchPass;constructor(e,t,i,r,s,a,o){super(e),this.withLutsLayout=t,this.rayMarchLayout=i,this.rayMarchDistantSky=r;const[_,l]=this.makeBindGroups({depthBuffer:o.skyRenderer.depthBuffer.view??o.skyRenderer.depthBuffer.texture,backBuffer:o.skyRenderer.backBuffer.view??o.skyRenderer.backBuffer.texture,renderTarget:o.skyRenderer.renderTarget.view??o.skyRenderer.renderTarget.texture}),u=[Math.ceil(o.skyRenderer.renderTarget.texture.width/16),Math.ceil(o.skyRenderer.renderTarget.texture.height/16),1];this.withLutsPass=new n(s,[_,...o.customUniformsSource?.bindGroups??[]],u),this.rayMarchPass=new n(a,[l,...o.shadow?.bindGroups??[],...o.customUniformsSource?.bindGroups??[]],u)}static makeBindGroupLayouts(e,t,n,i){return K(e,t,[{binding:5,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:t.skyRenderer.depthBuffer.texture.dimension,multisampled:!1}},{binding:6,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:t.skyRenderer.backBuffer.texture.dimension,multisampled:!1}},{binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:t.skyRenderer.renderTarget.texture.format,viewDimension:t.skyRenderer.renderTarget.texture.dimension}}],n,i,GPUShaderStage.COMPUTE)}static makeWithLutsPiplelineDescriptor(e,t,n,i){return{label:`Render sky with LUTs pipeline [${n.resources.label}]`,layout:e.createPipelineLayout({label:`Render sky with LUTs pipeline layout [${n.resources.label}]`,bindGroupLayouts:[i,...t.customUniformsSource?.bindGroupLayouts??[]]}),compute:{module:e.createShaderModule({code:A(t.skyRenderer.renderTarget.texture.format,t.customUniformsSource?.wgslCode)}),entryPoint:"render_sky_atmosphere",constants:Y(t,n)}}}static makeRayMarchPipelineDescriptor(e,t,n,i,r){const s={...Z(t,n,r),USE_COLORED_TRANSMISSION:Number(t.skyRenderer.rayMarch?.useColoredTransmittance??!0)},a=e.createShaderModule({code:(r?D:N)(t.skyRenderer.renderTarget.texture.format,t.shadow?.wgslCode,t.customUniformsSource?.wgslCode)});return{label:`Render sky raymarching pipeline [${n.resources.label}]`,layout:e.createPipelineLayout({label:"Render sky raymarching pipeline layout",bindGroupLayouts:[i,...t.shadow?.bindGroupLayouts??[],...t.customUniformsSource?.bindGroupLayouts??[]]}),compute:{module:a,entryPoint:"render_sky_atmosphere",constants:s}}}static async createAsync(e,t,n,i){const r=t.skyRenderer.rayMarch?.rayMarchDistantSky??!0,s=await super.createAsync(e,t,n,i),[a,o]=this.makeBindGroupLayouts(e,t,s.resources,r),[_,l]=await Promise.all([e.createComputePipelineAsync(this.makeWithLutsPiplelineDescriptor(e,t,s,a)),e.createComputePipelineAsync(this.makeRayMarchPipelineDescriptor(e,t,s,o,r))]);return new H(s,a,o,r,_,l,t)}static create(e,t,n,i){const r=t.skyRenderer.rayMarch?.rayMarchDistantSky??!0,s=super.create(e,t,n,i),[a,o]=this.makeBindGroupLayouts(e,t,s.resources,r),_=e.createComputePipeline(this.makeWithLutsPiplelineDescriptor(e,t,s,a)),l=e.createComputePipeline(this.makeRayMarchPipelineDescriptor(e,t,s,o,r));return new H(s,a,o,r,_,l,t)}makeBindGroups(e){const t=[{binding:5,resource:e.depthBuffer instanceof GPUTextureView?e.depthBuffer:e.depthBuffer.createView(e.depthBuffer.format.includes("depth")?{aspect:"depth-only"}:{})},{binding:6,resource:e.backBuffer instanceof GPUTextureView?e.backBuffer:e.backBuffer.createView()},{binding:7,resource:e.renderTarget instanceof GPUTextureView?e.renderTarget:e.renderTarget.createView()}];return q(this.resources,this.withLutsLayout,this.rayMarchLayout,this.usesCustomUniforms,t,this.rayMarchDistantSky)}onResize(e){let t=e.size??[-1,-1];if(t[0]<0&&(e.backBuffer instanceof GPUTexture&&(t=[e.backBuffer.width,e.backBuffer.height]),e.depthBuffer instanceof GPUTexture&&(t=[e.depthBuffer.width,e.depthBuffer.height]),e.renderTarget instanceof GPUTexture&&(t=[e.renderTarget.width,e.renderTarget.height])),t[0]<0||t[1]<0)throw new Error("[SkyAtmosphereComputeRenderer::onResize]: could not determine new size from config");const[n,i]=this.makeBindGroups(e);this.withLutsPass.replaceBindGroup(0,n),this.rayMarchPass.replaceBindGroup(0,i);const r=[Math.ceil(t[0]/16),Math.ceil(t[1]/16),1];this.withLutsPass.replaceDispatchDimensions(r),this.rayMarchPass.replaceDispatchDimensions(r)}renderSkyWithLuts(e){this.withLutsPass.encode(e)}renderSkyRaymarching(e){this.rayMarchPass.encode(e)}renderSky(e,t){t??this.defaultToFullResolutionRayMarch?this.renderSkyRaymarching(e):this.renderSkyWithLuts(e)}renderLutsAndSky(e,t,n,i,r){const s=i??this.defaultToFullResolutionRayMarch;this.renderLuts(e,t,n,s,r,!this.rayMarchDistantSky),this.renderSky(e,s)}}class j extends W{withLutsLayout;rayMarchLayout;withLutsTargetFormats;rayMarchTargetFormats;rayMarchDistantSky;withLutsPass;withLutsBundle;rayMarchPass;rayMarchBundle;constructor(e,t,n,r,s,a,o,_,l){super(e),this.withLutsLayout=t,this.rayMarchLayout=n,this.withLutsTargetFormats=r,this.rayMarchTargetFormats=s,this.rayMarchDistantSky=a;const[u,c]=this.makeBindGroups(l.skyRenderer.depthBuffer.view??l.skyRenderer.depthBuffer.texture);this.withLutsPass=new i(o,[u,...l.customUniformsSource?.bindGroups??[]]),this.rayMarchPass=new i(_,[c,...l.shadow?.bindGroups??[],...l.customUniformsSource?.bindGroups??[]]),(l.skyRenderer.recordInternalRenderBundles??1)&&([this.withLutsBundle,this.rayMarchBundle]=this.recordBundles())}static makeBindGroupLayouts(e,t,n,i){return K(e,t,[{binding:6,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:t.skyRenderer.depthBuffer.texture.dimension,multisampled:!1}}],n,i,GPUShaderStage.FRAGMENT)}static makeBlendStates(){return{single:{color:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one"}},dual:{color:{operation:"add",srcFactor:"one",dstFactor:"src1"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one"}}}}static makeWithLutsPiplelineDescriptor(e,t,n,i,r,s,a){const o=t.skyRenderer.writeTransmissionOnlyOnPerPixelRayMarch??!0,_=t.skyRenderer.transmissionFormat&&!a&&!o,l=[{format:t.skyRenderer.renderTargetFormat,writeMask:GPUColorWrite.ALL}];_?l.push({format:t.skyRenderer.transmissionFormat}):l[0].blend=a&&!o?s:r;let u=A("rgba16float",t.customUniformsSource?.wgslCode);a&&!o?(u=`enable dual_source_blending;\n${u}`,u=u.replace("@location(0)","@location(0) @blend_src(0)"),u=u.replace("@location(1)","@location(0) @blend_src(1)")):2!==l.length&&(u=u.replace("@location(1) transmittance: vec4<f32>,",""),u=u.replace("RenderSkyFragment(vec4(result.rgb, 1.0), vec4(vec3(result.a), 1.0))","RenderSkyFragment(result)"));const c=e.createShaderModule({label:"Render sky with LUTs",code:u});return[{label:`Render sky with LUTs pipeline [${n.resources.label}]`,layout:e.createPipelineLayout({label:"Render sky with LUTs pipeline layout",bindGroupLayouts:[i,...t.customUniformsSource?.bindGroupLayouts??[]]}),vertex:{module:c},fragment:{module:c,constants:Y(t,n),targets:l}},l.map((e=>e.format))]}static makeRayMarchPipelineDescriptor(e,t,n,i,r,s,a,o){const _=t.skyRenderer.transmissionFormat&&!o,l=[{format:t.skyRenderer.renderTargetFormat,writeMask:GPUColorWrite.ALL}];_?l.push({format:t.skyRenderer.transmissionFormat}):l[0].blend=o?a:s;let u=(r?D:N)("rgba16float",t.shadow?.wgslCode,t.customUniformsSource?.wgslCode);o?(u=u.replace("@location(0)","@location(0) @blend_src(0)"),u=u.replace("@location(1)","@location(0) @blend_src(1)")):2!==l.length&&(u=u.replace("@location(1) transmittance: vec4<f32>,",""),u=u.replace("RenderSkyFragment(result.luminance, result.transmittance)","RenderSkyFragment(vec4(result.luminance.rgb, 1.0 - dot(result.transmittance.rgb, vec3(1.0 / 3.0))))"));const c=e.createShaderModule({label:"Render sky raymarching",code:`${o?"enable dual_source_blending;\n":""}${u}`});return[{label:`Render sky raymarching pipeline [${n.resources.label}]`,layout:e.createPipelineLayout({label:`Render sky raymarching pipeline layout [${n.resources.label}]`,bindGroupLayouts:[i,...t.shadow?.bindGroupLayouts||[],...t.customUniformsSource?.bindGroupLayouts??[]]}),vertex:{module:c},fragment:{module:c,constants:Z(t,n,r),targets:l}},l.map((e=>e.format))]}static async createAsync(e,t,n,i){const r=e.features.has("dual-source-blending")&&(t.skyRenderer.rayMarch?.useColoredTransmittance??!1);!r&&t.skyRenderer.rayMarch?.useColoredTransmittance&&console.warn("[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled");const s=t.skyRenderer.rayMarch?.rayMarchDistantSky??!0,a=await super.createAsync(e,t,n,i),[o,_]=this.makeBindGroupLayouts(e,t,a.resources,s),l=this.makeBlendStates(),[u,c]=this.makeWithLutsPiplelineDescriptor(e,t,a,o,l.single,l.dual,r),[m,p]=this.makeRayMarchPipelineDescriptor(e,t,a,_,s,l.single,l.dual,r),[d,h]=await Promise.all([e.createRenderPipelineAsync(u),e.createRenderPipelineAsync(m)]);return new j(a,o,_,c,p,s,d,h,t)}static create(e,t,n,i){const r=e.features.has("dual-source-blending")&&(t.skyRenderer.rayMarch?.useColoredTransmittance??!1);!r&&t.skyRenderer.rayMarch?.useColoredTransmittance&&console.warn("[SkyAtmosphereRasterRenderer]: dual source blending was requested but the device feature is not enabled");const s=t.skyRenderer.rayMarch?.rayMarchDistantSky??!0,a=super.create(e,t,n,i),[o,_]=this.makeBindGroupLayouts(e,t,a.resources,s),l=this.makeBlendStates(),[u,c]=this.makeWithLutsPiplelineDescriptor(e,t,a,o,l.single,l.dual,r),[m,p]=this.makeRayMarchPipelineDescriptor(e,t,a,_,s,l.single,l.dual,r),d=e.createRenderPipeline(u),h=e.createRenderPipeline(m);return new j(a,o,_,c,p,s,d,h,t)}makeBindGroups(e){const t=[{binding:6,resource:e instanceof GPUTextureView?e:e.createView(e.format.includes("depth")?{aspect:"depth-only"}:{})}];return q(this.resources,this.withLutsLayout,this.rayMarchLayout,this.usesCustomUniforms,t,this.rayMarchDistantSky)}recordBundles(){const e=this.resources.device.createRenderBundleEncoder({label:"Render sky with LUTs",colorFormats:this.withLutsTargetFormats});this.renderSkyWithLuts(e);const t=e.finish(),n=this.resources.device.createRenderBundleEncoder({label:"Render sky with LUTs",colorFormats:this.rayMarchTargetFormats});this.renderSkyRaymarching(n);return[t,n.finish()]}onResize(e){const[t,n]=this.makeBindGroups(e);this.withLutsPass.replaceBindGroup(0,t),this.rayMarchPass.replaceBindGroup(0,n),this.withLutsBundle&&this.rayMarchBundle&&([this.withLutsBundle,this.rayMarchBundle]=this.recordBundles())}renderSkyWithLuts(e){e instanceof GPURenderPassEncoder&&this.withLutsBundle?e.executeBundles([this.withLutsBundle]):this.withLutsPass.encode(e)}renderSkyRaymarching(e){e instanceof GPURenderPassEncoder&&this.rayMarchBundle?e.executeBundles([this.rayMarchBundle]):this.rayMarchPass.encode(e)}renderSky(e,t){t??this.defaultToFullResolutionRayMarch?this.renderSkyRaymarching(e):this.renderSkyWithLuts(e)}renderLuts(e,t,n,i,r,s){super.renderLuts(e,t,n,i,r,!this.rayMarchDistantSky||s)}}export{m as ATMOSPHERE_BUFFER_SIZE,n as ComputePass,t as LookUpTable,i as RenderPass,H as SkyAtmosphereComputeRenderer,W as SkyAtmosphereLutRenderer,j as SkyAtmosphereRasterRenderer,d as SkyAtmosphereResources,p as UNIFORMS_BUFFER_SIZE,h as atmosphereToFloatArray,e as makeEarthAtmosphere,f as uniformsToFloatArray};
//# sourceMappingURL=webgpu-sky-atmosphere.module.min.js.map
